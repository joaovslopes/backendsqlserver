
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MEMB_INFO
 * 
 */
export type MEMB_INFO = $Result.DefaultSelection<Prisma.$MEMB_INFOPayload>
/**
 * Model AccountCharacter
 * 
 */
export type AccountCharacter = $Result.DefaultSelection<Prisma.$AccountCharacterPayload>
/**
 * Model CashShopData
 * 
 */
export type CashShopData = $Result.DefaultSelection<Prisma.$CashShopDataPayload>
/**
 * Model CashShopInventory
 * 
 */
export type CashShopInventory = $Result.DefaultSelection<Prisma.$CashShopInventoryPayload>
/**
 * Model CashShopPeriodicItem
 * 
 */
export type CashShopPeriodicItem = $Result.DefaultSelection<Prisma.$CashShopPeriodicItemPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model DefaultClassType
 * 
 */
export type DefaultClassType = $Result.DefaultSelection<Prisma.$DefaultClassTypePayload>
/**
 * Model EventLeoTheHelper
 * 
 */
export type EventLeoTheHelper = $Result.DefaultSelection<Prisma.$EventLeoTheHelperPayload>
/**
 * Model EventSantaClaus
 * 
 */
export type EventSantaClaus = $Result.DefaultSelection<Prisma.$EventSantaClausPayload>
/**
 * Model GameServerInfo
 * 
 */
export type GameServerInfo = $Result.DefaultSelection<Prisma.$GameServerInfoPayload>
/**
 * Model Gens_Rank
 * 
 */
export type Gens_Rank = $Result.DefaultSelection<Prisma.$Gens_RankPayload>
/**
 * Model Gens_Reward
 * 
 */
export type Gens_Reward = $Result.DefaultSelection<Prisma.$Gens_RewardPayload>
/**
 * Model Guild
 * 
 */
export type Guild = $Result.DefaultSelection<Prisma.$GuildPayload>
/**
 * Model GuildMember
 * 
 */
export type GuildMember = $Result.DefaultSelection<Prisma.$GuildMemberPayload>
/**
 * Model HelperData
 * 
 */
export type HelperData = $Result.DefaultSelection<Prisma.$HelperDataPayload>
/**
 * Model LuckyCoin
 * 
 */
export type LuckyCoin = $Result.DefaultSelection<Prisma.$LuckyCoinPayload>
/**
 * Model LuckyItem
 * 
 */
export type LuckyItem = $Result.DefaultSelection<Prisma.$LuckyItemPayload>
/**
 * Model MEMB_STAT
 * 
 */
export type MEMB_STAT = $Result.DefaultSelection<Prisma.$MEMB_STATPayload>
/**
 * Model MasterSkillTree
 * 
 */
export type MasterSkillTree = $Result.DefaultSelection<Prisma.$MasterSkillTreePayload>
/**
 * Model MuCastle_DATA
 * 
 */
export type MuCastle_DATA = $Result.DefaultSelection<Prisma.$MuCastle_DATAPayload>
/**
 * Model MuCastle_NPC
 * 
 */
export type MuCastle_NPC = $Result.DefaultSelection<Prisma.$MuCastle_NPCPayload>
/**
 * Model MuCastle_REG_SIEGE
 * 
 */
export type MuCastle_REG_SIEGE = $Result.DefaultSelection<Prisma.$MuCastle_REG_SIEGEPayload>
/**
 * Model OptionData
 * 
 */
export type OptionData = $Result.DefaultSelection<Prisma.$OptionDataPayload>
/**
 * Model QuestKillCount
 * 
 */
export type QuestKillCount = $Result.DefaultSelection<Prisma.$QuestKillCountPayload>
/**
 * Model QuestWorld
 * 
 */
export type QuestWorld = $Result.DefaultSelection<Prisma.$QuestWorldPayload>
/**
 * Model RankingBloodCastle
 * 
 */
export type RankingBloodCastle = $Result.DefaultSelection<Prisma.$RankingBloodCastlePayload>
/**
 * Model RankingChaosCastle
 * 
 */
export type RankingChaosCastle = $Result.DefaultSelection<Prisma.$RankingChaosCastlePayload>
/**
 * Model RankingDevilSquare
 * 
 */
export type RankingDevilSquare = $Result.DefaultSelection<Prisma.$RankingDevilSquarePayload>
/**
 * Model RankingDuel
 * 
 */
export type RankingDuel = $Result.DefaultSelection<Prisma.$RankingDuelPayload>
/**
 * Model RankingIllusionTemple
 * 
 */
export type RankingIllusionTemple = $Result.DefaultSelection<Prisma.$RankingIllusionTemplePayload>
/**
 * Model T_CGuid
 * 
 */
export type T_CGuid = $Result.DefaultSelection<Prisma.$T_CGuidPayload>
/**
 * Model T_FriendMail
 * 
 */
export type T_FriendMail = $Result.DefaultSelection<Prisma.$T_FriendMailPayload>
/**
 * Model T_FriendMain
 * 
 */
export type T_FriendMain = $Result.DefaultSelection<Prisma.$T_FriendMainPayload>
/**
 * Model T_PetItem_Info
 * 
 */
export type T_PetItem_Info = $Result.DefaultSelection<Prisma.$T_PetItem_InfoPayload>
/**
 * Model warehouse
 * 
 */
export type warehouse = $Result.DefaultSelection<Prisma.$warehousePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.mEMB_INFO`: Exposes CRUD operations for the **MEMB_INFO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEMB_INFOS
    * const mEMB_INFOS = await prisma.mEMB_INFO.findMany()
    * ```
    */
  get mEMB_INFO(): Prisma.MEMB_INFODelegate<ExtArgs>;

  /**
   * `prisma.accountCharacter`: Exposes CRUD operations for the **AccountCharacter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountCharacters
    * const accountCharacters = await prisma.accountCharacter.findMany()
    * ```
    */
  get accountCharacter(): Prisma.AccountCharacterDelegate<ExtArgs>;

  /**
   * `prisma.cashShopData`: Exposes CRUD operations for the **CashShopData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashShopData
    * const cashShopData = await prisma.cashShopData.findMany()
    * ```
    */
  get cashShopData(): Prisma.CashShopDataDelegate<ExtArgs>;

  /**
   * `prisma.cashShopInventory`: Exposes CRUD operations for the **CashShopInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashShopInventories
    * const cashShopInventories = await prisma.cashShopInventory.findMany()
    * ```
    */
  get cashShopInventory(): Prisma.CashShopInventoryDelegate<ExtArgs>;

  /**
   * `prisma.cashShopPeriodicItem`: Exposes CRUD operations for the **CashShopPeriodicItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashShopPeriodicItems
    * const cashShopPeriodicItems = await prisma.cashShopPeriodicItem.findMany()
    * ```
    */
  get cashShopPeriodicItem(): Prisma.CashShopPeriodicItemDelegate<ExtArgs>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs>;

  /**
   * `prisma.defaultClassType`: Exposes CRUD operations for the **DefaultClassType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DefaultClassTypes
    * const defaultClassTypes = await prisma.defaultClassType.findMany()
    * ```
    */
  get defaultClassType(): Prisma.DefaultClassTypeDelegate<ExtArgs>;

  /**
   * `prisma.eventLeoTheHelper`: Exposes CRUD operations for the **EventLeoTheHelper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventLeoTheHelpers
    * const eventLeoTheHelpers = await prisma.eventLeoTheHelper.findMany()
    * ```
    */
  get eventLeoTheHelper(): Prisma.EventLeoTheHelperDelegate<ExtArgs>;

  /**
   * `prisma.eventSantaClaus`: Exposes CRUD operations for the **EventSantaClaus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventSantaClaus
    * const eventSantaClaus = await prisma.eventSantaClaus.findMany()
    * ```
    */
  get eventSantaClaus(): Prisma.EventSantaClausDelegate<ExtArgs>;

  /**
   * `prisma.gameServerInfo`: Exposes CRUD operations for the **GameServerInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameServerInfos
    * const gameServerInfos = await prisma.gameServerInfo.findMany()
    * ```
    */
  get gameServerInfo(): Prisma.GameServerInfoDelegate<ExtArgs>;

  /**
   * `prisma.gens_Rank`: Exposes CRUD operations for the **Gens_Rank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gens_Ranks
    * const gens_Ranks = await prisma.gens_Rank.findMany()
    * ```
    */
  get gens_Rank(): Prisma.Gens_RankDelegate<ExtArgs>;

  /**
   * `prisma.gens_Reward`: Exposes CRUD operations for the **Gens_Reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gens_Rewards
    * const gens_Rewards = await prisma.gens_Reward.findMany()
    * ```
    */
  get gens_Reward(): Prisma.Gens_RewardDelegate<ExtArgs>;

  /**
   * `prisma.guild`: Exposes CRUD operations for the **Guild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guild.findMany()
    * ```
    */
  get guild(): Prisma.GuildDelegate<ExtArgs>;

  /**
   * `prisma.guildMember`: Exposes CRUD operations for the **GuildMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuildMembers
    * const guildMembers = await prisma.guildMember.findMany()
    * ```
    */
  get guildMember(): Prisma.GuildMemberDelegate<ExtArgs>;

  /**
   * `prisma.helperData`: Exposes CRUD operations for the **HelperData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelperData
    * const helperData = await prisma.helperData.findMany()
    * ```
    */
  get helperData(): Prisma.HelperDataDelegate<ExtArgs>;

  /**
   * `prisma.luckyCoin`: Exposes CRUD operations for the **LuckyCoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LuckyCoins
    * const luckyCoins = await prisma.luckyCoin.findMany()
    * ```
    */
  get luckyCoin(): Prisma.LuckyCoinDelegate<ExtArgs>;

  /**
   * `prisma.luckyItem`: Exposes CRUD operations for the **LuckyItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LuckyItems
    * const luckyItems = await prisma.luckyItem.findMany()
    * ```
    */
  get luckyItem(): Prisma.LuckyItemDelegate<ExtArgs>;

  /**
   * `prisma.mEMB_STAT`: Exposes CRUD operations for the **MEMB_STAT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MEMB_STATS
    * const mEMB_STATS = await prisma.mEMB_STAT.findMany()
    * ```
    */
  get mEMB_STAT(): Prisma.MEMB_STATDelegate<ExtArgs>;

  /**
   * `prisma.masterSkillTree`: Exposes CRUD operations for the **MasterSkillTree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterSkillTrees
    * const masterSkillTrees = await prisma.masterSkillTree.findMany()
    * ```
    */
  get masterSkillTree(): Prisma.MasterSkillTreeDelegate<ExtArgs>;

  /**
   * `prisma.muCastle_DATA`: Exposes CRUD operations for the **MuCastle_DATA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MuCastle_DATA
    * const muCastle_DATA = await prisma.muCastle_DATA.findMany()
    * ```
    */
  get muCastle_DATA(): Prisma.MuCastle_DATADelegate<ExtArgs>;

  /**
   * `prisma.muCastle_NPC`: Exposes CRUD operations for the **MuCastle_NPC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MuCastle_NPCS
    * const muCastle_NPCS = await prisma.muCastle_NPC.findMany()
    * ```
    */
  get muCastle_NPC(): Prisma.MuCastle_NPCDelegate<ExtArgs>;

  /**
   * `prisma.muCastle_REG_SIEGE`: Exposes CRUD operations for the **MuCastle_REG_SIEGE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MuCastle_REG_SIEGES
    * const muCastle_REG_SIEGES = await prisma.muCastle_REG_SIEGE.findMany()
    * ```
    */
  get muCastle_REG_SIEGE(): Prisma.MuCastle_REG_SIEGEDelegate<ExtArgs>;

  /**
   * `prisma.optionData`: Exposes CRUD operations for the **OptionData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OptionData
    * const optionData = await prisma.optionData.findMany()
    * ```
    */
  get optionData(): Prisma.OptionDataDelegate<ExtArgs>;

  /**
   * `prisma.questKillCount`: Exposes CRUD operations for the **QuestKillCount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestKillCounts
    * const questKillCounts = await prisma.questKillCount.findMany()
    * ```
    */
  get questKillCount(): Prisma.QuestKillCountDelegate<ExtArgs>;

  /**
   * `prisma.questWorld`: Exposes CRUD operations for the **QuestWorld** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestWorlds
    * const questWorlds = await prisma.questWorld.findMany()
    * ```
    */
  get questWorld(): Prisma.QuestWorldDelegate<ExtArgs>;

  /**
   * `prisma.rankingBloodCastle`: Exposes CRUD operations for the **RankingBloodCastle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RankingBloodCastles
    * const rankingBloodCastles = await prisma.rankingBloodCastle.findMany()
    * ```
    */
  get rankingBloodCastle(): Prisma.RankingBloodCastleDelegate<ExtArgs>;

  /**
   * `prisma.rankingChaosCastle`: Exposes CRUD operations for the **RankingChaosCastle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RankingChaosCastles
    * const rankingChaosCastles = await prisma.rankingChaosCastle.findMany()
    * ```
    */
  get rankingChaosCastle(): Prisma.RankingChaosCastleDelegate<ExtArgs>;

  /**
   * `prisma.rankingDevilSquare`: Exposes CRUD operations for the **RankingDevilSquare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RankingDevilSquares
    * const rankingDevilSquares = await prisma.rankingDevilSquare.findMany()
    * ```
    */
  get rankingDevilSquare(): Prisma.RankingDevilSquareDelegate<ExtArgs>;

  /**
   * `prisma.rankingDuel`: Exposes CRUD operations for the **RankingDuel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RankingDuels
    * const rankingDuels = await prisma.rankingDuel.findMany()
    * ```
    */
  get rankingDuel(): Prisma.RankingDuelDelegate<ExtArgs>;

  /**
   * `prisma.rankingIllusionTemple`: Exposes CRUD operations for the **RankingIllusionTemple** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RankingIllusionTemples
    * const rankingIllusionTemples = await prisma.rankingIllusionTemple.findMany()
    * ```
    */
  get rankingIllusionTemple(): Prisma.RankingIllusionTempleDelegate<ExtArgs>;

  /**
   * `prisma.t_CGuid`: Exposes CRUD operations for the **T_CGuid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_CGuids
    * const t_CGuids = await prisma.t_CGuid.findMany()
    * ```
    */
  get t_CGuid(): Prisma.T_CGuidDelegate<ExtArgs>;

  /**
   * `prisma.t_FriendMail`: Exposes CRUD operations for the **T_FriendMail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_FriendMails
    * const t_FriendMails = await prisma.t_FriendMail.findMany()
    * ```
    */
  get t_FriendMail(): Prisma.T_FriendMailDelegate<ExtArgs>;

  /**
   * `prisma.t_FriendMain`: Exposes CRUD operations for the **T_FriendMain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_FriendMains
    * const t_FriendMains = await prisma.t_FriendMain.findMany()
    * ```
    */
  get t_FriendMain(): Prisma.T_FriendMainDelegate<ExtArgs>;

  /**
   * `prisma.t_PetItem_Info`: Exposes CRUD operations for the **T_PetItem_Info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_PetItem_Infos
    * const t_PetItem_Infos = await prisma.t_PetItem_Info.findMany()
    * ```
    */
  get t_PetItem_Info(): Prisma.T_PetItem_InfoDelegate<ExtArgs>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.warehouseDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    MEMB_INFO: 'MEMB_INFO',
    AccountCharacter: 'AccountCharacter',
    CashShopData: 'CashShopData',
    CashShopInventory: 'CashShopInventory',
    CashShopPeriodicItem: 'CashShopPeriodicItem',
    Character: 'Character',
    DefaultClassType: 'DefaultClassType',
    EventLeoTheHelper: 'EventLeoTheHelper',
    EventSantaClaus: 'EventSantaClaus',
    GameServerInfo: 'GameServerInfo',
    Gens_Rank: 'Gens_Rank',
    Gens_Reward: 'Gens_Reward',
    Guild: 'Guild',
    GuildMember: 'GuildMember',
    HelperData: 'HelperData',
    LuckyCoin: 'LuckyCoin',
    LuckyItem: 'LuckyItem',
    MEMB_STAT: 'MEMB_STAT',
    MasterSkillTree: 'MasterSkillTree',
    MuCastle_DATA: 'MuCastle_DATA',
    MuCastle_NPC: 'MuCastle_NPC',
    MuCastle_REG_SIEGE: 'MuCastle_REG_SIEGE',
    OptionData: 'OptionData',
    QuestKillCount: 'QuestKillCount',
    QuestWorld: 'QuestWorld',
    RankingBloodCastle: 'RankingBloodCastle',
    RankingChaosCastle: 'RankingChaosCastle',
    RankingDevilSquare: 'RankingDevilSquare',
    RankingDuel: 'RankingDuel',
    RankingIllusionTemple: 'RankingIllusionTemple',
    T_CGuid: 'T_CGuid',
    T_FriendMail: 'T_FriendMail',
    T_FriendMain: 'T_FriendMain',
    T_PetItem_Info: 'T_PetItem_Info',
    warehouse: 'warehouse'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'mEMB_INFO' | 'accountCharacter' | 'cashShopData' | 'cashShopInventory' | 'cashShopPeriodicItem' | 'character' | 'defaultClassType' | 'eventLeoTheHelper' | 'eventSantaClaus' | 'gameServerInfo' | 'gens_Rank' | 'gens_Reward' | 'guild' | 'guildMember' | 'helperData' | 'luckyCoin' | 'luckyItem' | 'mEMB_STAT' | 'masterSkillTree' | 'muCastle_DATA' | 'muCastle_NPC' | 'muCastle_REG_SIEGE' | 'optionData' | 'questKillCount' | 'questWorld' | 'rankingBloodCastle' | 'rankingChaosCastle' | 'rankingDevilSquare' | 'rankingDuel' | 'rankingIllusionTemple' | 't_CGuid' | 't_FriendMail' | 't_FriendMain' | 't_PetItem_Info' | 'warehouse'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MEMB_INFO: {
        payload: Prisma.$MEMB_INFOPayload<ExtArgs>
        fields: Prisma.MEMB_INFOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEMB_INFOFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEMB_INFOFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload>
          }
          findFirst: {
            args: Prisma.MEMB_INFOFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEMB_INFOFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload>
          }
          findMany: {
            args: Prisma.MEMB_INFOFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload>[]
          }
          create: {
            args: Prisma.MEMB_INFOCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload>
          }
          createMany: {
            args: Prisma.MEMB_INFOCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEMB_INFODeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload>
          }
          update: {
            args: Prisma.MEMB_INFOUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload>
          }
          deleteMany: {
            args: Prisma.MEMB_INFODeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEMB_INFOUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEMB_INFOUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_INFOPayload>
          }
          aggregate: {
            args: Prisma.MEMB_INFOAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEMB_INFO>
          }
          groupBy: {
            args: Prisma.MEMB_INFOGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEMB_INFOGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEMB_INFOCountArgs<ExtArgs>,
            result: $Utils.Optional<MEMB_INFOCountAggregateOutputType> | number
          }
        }
      }
      AccountCharacter: {
        payload: Prisma.$AccountCharacterPayload<ExtArgs>
        fields: Prisma.AccountCharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountCharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountCharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload>
          }
          findFirst: {
            args: Prisma.AccountCharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountCharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload>
          }
          findMany: {
            args: Prisma.AccountCharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload>[]
          }
          create: {
            args: Prisma.AccountCharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload>
          }
          createMany: {
            args: Prisma.AccountCharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountCharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload>
          }
          update: {
            args: Prisma.AccountCharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload>
          }
          deleteMany: {
            args: Prisma.AccountCharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountCharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountCharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountCharacterPayload>
          }
          aggregate: {
            args: Prisma.AccountCharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccountCharacter>
          }
          groupBy: {
            args: Prisma.AccountCharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountCharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCharacterCountAggregateOutputType> | number
          }
        }
      }
      CashShopData: {
        payload: Prisma.$CashShopDataPayload<ExtArgs>
        fields: Prisma.CashShopDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashShopDataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashShopDataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload>
          }
          findFirst: {
            args: Prisma.CashShopDataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashShopDataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload>
          }
          findMany: {
            args: Prisma.CashShopDataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload>[]
          }
          create: {
            args: Prisma.CashShopDataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload>
          }
          createMany: {
            args: Prisma.CashShopDataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CashShopDataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload>
          }
          update: {
            args: Prisma.CashShopDataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload>
          }
          deleteMany: {
            args: Prisma.CashShopDataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CashShopDataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CashShopDataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopDataPayload>
          }
          aggregate: {
            args: Prisma.CashShopDataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCashShopData>
          }
          groupBy: {
            args: Prisma.CashShopDataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CashShopDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashShopDataCountArgs<ExtArgs>,
            result: $Utils.Optional<CashShopDataCountAggregateOutputType> | number
          }
        }
      }
      CashShopInventory: {
        payload: Prisma.$CashShopInventoryPayload<ExtArgs>
        fields: Prisma.CashShopInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashShopInventoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashShopInventoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload>
          }
          findFirst: {
            args: Prisma.CashShopInventoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashShopInventoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload>
          }
          findMany: {
            args: Prisma.CashShopInventoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload>[]
          }
          create: {
            args: Prisma.CashShopInventoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload>
          }
          createMany: {
            args: Prisma.CashShopInventoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CashShopInventoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload>
          }
          update: {
            args: Prisma.CashShopInventoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload>
          }
          deleteMany: {
            args: Prisma.CashShopInventoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CashShopInventoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CashShopInventoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopInventoryPayload>
          }
          aggregate: {
            args: Prisma.CashShopInventoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCashShopInventory>
          }
          groupBy: {
            args: Prisma.CashShopInventoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CashShopInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashShopInventoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CashShopInventoryCountAggregateOutputType> | number
          }
        }
      }
      CashShopPeriodicItem: {
        payload: Prisma.$CashShopPeriodicItemPayload<ExtArgs>
        fields: Prisma.CashShopPeriodicItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashShopPeriodicItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashShopPeriodicItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload>
          }
          findFirst: {
            args: Prisma.CashShopPeriodicItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashShopPeriodicItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload>
          }
          findMany: {
            args: Prisma.CashShopPeriodicItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload>[]
          }
          create: {
            args: Prisma.CashShopPeriodicItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload>
          }
          createMany: {
            args: Prisma.CashShopPeriodicItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CashShopPeriodicItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload>
          }
          update: {
            args: Prisma.CashShopPeriodicItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload>
          }
          deleteMany: {
            args: Prisma.CashShopPeriodicItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CashShopPeriodicItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CashShopPeriodicItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CashShopPeriodicItemPayload>
          }
          aggregate: {
            args: Prisma.CashShopPeriodicItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCashShopPeriodicItem>
          }
          groupBy: {
            args: Prisma.CashShopPeriodicItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CashShopPeriodicItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashShopPeriodicItemCountArgs<ExtArgs>,
            result: $Utils.Optional<CashShopPeriodicItemCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>,
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      DefaultClassType: {
        payload: Prisma.$DefaultClassTypePayload<ExtArgs>
        fields: Prisma.DefaultClassTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DefaultClassTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DefaultClassTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload>
          }
          findFirst: {
            args: Prisma.DefaultClassTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DefaultClassTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload>
          }
          findMany: {
            args: Prisma.DefaultClassTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload>[]
          }
          create: {
            args: Prisma.DefaultClassTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload>
          }
          createMany: {
            args: Prisma.DefaultClassTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DefaultClassTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload>
          }
          update: {
            args: Prisma.DefaultClassTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload>
          }
          deleteMany: {
            args: Prisma.DefaultClassTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DefaultClassTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DefaultClassTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DefaultClassTypePayload>
          }
          aggregate: {
            args: Prisma.DefaultClassTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDefaultClassType>
          }
          groupBy: {
            args: Prisma.DefaultClassTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DefaultClassTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DefaultClassTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<DefaultClassTypeCountAggregateOutputType> | number
          }
        }
      }
      EventLeoTheHelper: {
        payload: Prisma.$EventLeoTheHelperPayload<ExtArgs>
        fields: Prisma.EventLeoTheHelperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventLeoTheHelperFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventLeoTheHelperFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload>
          }
          findFirst: {
            args: Prisma.EventLeoTheHelperFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventLeoTheHelperFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload>
          }
          findMany: {
            args: Prisma.EventLeoTheHelperFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload>[]
          }
          create: {
            args: Prisma.EventLeoTheHelperCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload>
          }
          createMany: {
            args: Prisma.EventLeoTheHelperCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EventLeoTheHelperDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload>
          }
          update: {
            args: Prisma.EventLeoTheHelperUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload>
          }
          deleteMany: {
            args: Prisma.EventLeoTheHelperDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EventLeoTheHelperUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EventLeoTheHelperUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventLeoTheHelperPayload>
          }
          aggregate: {
            args: Prisma.EventLeoTheHelperAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEventLeoTheHelper>
          }
          groupBy: {
            args: Prisma.EventLeoTheHelperGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventLeoTheHelperGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventLeoTheHelperCountArgs<ExtArgs>,
            result: $Utils.Optional<EventLeoTheHelperCountAggregateOutputType> | number
          }
        }
      }
      EventSantaClaus: {
        payload: Prisma.$EventSantaClausPayload<ExtArgs>
        fields: Prisma.EventSantaClausFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventSantaClausFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventSantaClausFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload>
          }
          findFirst: {
            args: Prisma.EventSantaClausFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventSantaClausFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload>
          }
          findMany: {
            args: Prisma.EventSantaClausFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload>[]
          }
          create: {
            args: Prisma.EventSantaClausCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload>
          }
          createMany: {
            args: Prisma.EventSantaClausCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EventSantaClausDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload>
          }
          update: {
            args: Prisma.EventSantaClausUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload>
          }
          deleteMany: {
            args: Prisma.EventSantaClausDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EventSantaClausUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EventSantaClausUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EventSantaClausPayload>
          }
          aggregate: {
            args: Prisma.EventSantaClausAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEventSantaClaus>
          }
          groupBy: {
            args: Prisma.EventSantaClausGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EventSantaClausGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventSantaClausCountArgs<ExtArgs>,
            result: $Utils.Optional<EventSantaClausCountAggregateOutputType> | number
          }
        }
      }
      GameServerInfo: {
        payload: Prisma.$GameServerInfoPayload<ExtArgs>
        fields: Prisma.GameServerInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameServerInfoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameServerInfoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload>
          }
          findFirst: {
            args: Prisma.GameServerInfoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameServerInfoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload>
          }
          findMany: {
            args: Prisma.GameServerInfoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload>[]
          }
          create: {
            args: Prisma.GameServerInfoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload>
          }
          createMany: {
            args: Prisma.GameServerInfoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GameServerInfoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload>
          }
          update: {
            args: Prisma.GameServerInfoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload>
          }
          deleteMany: {
            args: Prisma.GameServerInfoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GameServerInfoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GameServerInfoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GameServerInfoPayload>
          }
          aggregate: {
            args: Prisma.GameServerInfoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGameServerInfo>
          }
          groupBy: {
            args: Prisma.GameServerInfoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GameServerInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameServerInfoCountArgs<ExtArgs>,
            result: $Utils.Optional<GameServerInfoCountAggregateOutputType> | number
          }
        }
      }
      Gens_Rank: {
        payload: Prisma.$Gens_RankPayload<ExtArgs>
        fields: Prisma.Gens_RankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Gens_RankFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gens_RankFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload>
          }
          findFirst: {
            args: Prisma.Gens_RankFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gens_RankFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload>
          }
          findMany: {
            args: Prisma.Gens_RankFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload>[]
          }
          create: {
            args: Prisma.Gens_RankCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload>
          }
          createMany: {
            args: Prisma.Gens_RankCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Gens_RankDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload>
          }
          update: {
            args: Prisma.Gens_RankUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload>
          }
          deleteMany: {
            args: Prisma.Gens_RankDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Gens_RankUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Gens_RankUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RankPayload>
          }
          aggregate: {
            args: Prisma.Gens_RankAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGens_Rank>
          }
          groupBy: {
            args: Prisma.Gens_RankGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gens_RankGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gens_RankCountArgs<ExtArgs>,
            result: $Utils.Optional<Gens_RankCountAggregateOutputType> | number
          }
        }
      }
      Gens_Reward: {
        payload: Prisma.$Gens_RewardPayload<ExtArgs>
        fields: Prisma.Gens_RewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Gens_RewardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Gens_RewardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload>
          }
          findFirst: {
            args: Prisma.Gens_RewardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Gens_RewardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload>
          }
          findMany: {
            args: Prisma.Gens_RewardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload>[]
          }
          create: {
            args: Prisma.Gens_RewardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload>
          }
          createMany: {
            args: Prisma.Gens_RewardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Gens_RewardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload>
          }
          update: {
            args: Prisma.Gens_RewardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload>
          }
          deleteMany: {
            args: Prisma.Gens_RewardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Gens_RewardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Gens_RewardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Gens_RewardPayload>
          }
          aggregate: {
            args: Prisma.Gens_RewardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGens_Reward>
          }
          groupBy: {
            args: Prisma.Gens_RewardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Gens_RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.Gens_RewardCountArgs<ExtArgs>,
            result: $Utils.Optional<Gens_RewardCountAggregateOutputType> | number
          }
        }
      }
      Guild: {
        payload: Prisma.$GuildPayload<ExtArgs>
        fields: Prisma.GuildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          findFirst: {
            args: Prisma.GuildFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          findMany: {
            args: Prisma.GuildFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>[]
          }
          create: {
            args: Prisma.GuildCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          createMany: {
            args: Prisma.GuildCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GuildDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          update: {
            args: Prisma.GuildUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          deleteMany: {
            args: Prisma.GuildDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GuildUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GuildUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildPayload>
          }
          aggregate: {
            args: Prisma.GuildAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuild>
          }
          groupBy: {
            args: Prisma.GuildGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GuildGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildCountArgs<ExtArgs>,
            result: $Utils.Optional<GuildCountAggregateOutputType> | number
          }
        }
      }
      GuildMember: {
        payload: Prisma.$GuildMemberPayload<ExtArgs>
        fields: Prisma.GuildMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuildMemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuildMemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          findFirst: {
            args: Prisma.GuildMemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuildMemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          findMany: {
            args: Prisma.GuildMemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>[]
          }
          create: {
            args: Prisma.GuildMemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          createMany: {
            args: Prisma.GuildMemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GuildMemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          update: {
            args: Prisma.GuildMemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          deleteMany: {
            args: Prisma.GuildMemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GuildMemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GuildMemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GuildMemberPayload>
          }
          aggregate: {
            args: Prisma.GuildMemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuildMember>
          }
          groupBy: {
            args: Prisma.GuildMemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GuildMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuildMemberCountArgs<ExtArgs>,
            result: $Utils.Optional<GuildMemberCountAggregateOutputType> | number
          }
        }
      }
      HelperData: {
        payload: Prisma.$HelperDataPayload<ExtArgs>
        fields: Prisma.HelperDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelperDataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelperDataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload>
          }
          findFirst: {
            args: Prisma.HelperDataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelperDataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload>
          }
          findMany: {
            args: Prisma.HelperDataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload>[]
          }
          create: {
            args: Prisma.HelperDataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload>
          }
          createMany: {
            args: Prisma.HelperDataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HelperDataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload>
          }
          update: {
            args: Prisma.HelperDataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload>
          }
          deleteMany: {
            args: Prisma.HelperDataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HelperDataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HelperDataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HelperDataPayload>
          }
          aggregate: {
            args: Prisma.HelperDataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHelperData>
          }
          groupBy: {
            args: Prisma.HelperDataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HelperDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelperDataCountArgs<ExtArgs>,
            result: $Utils.Optional<HelperDataCountAggregateOutputType> | number
          }
        }
      }
      LuckyCoin: {
        payload: Prisma.$LuckyCoinPayload<ExtArgs>
        fields: Prisma.LuckyCoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LuckyCoinFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LuckyCoinFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload>
          }
          findFirst: {
            args: Prisma.LuckyCoinFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LuckyCoinFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload>
          }
          findMany: {
            args: Prisma.LuckyCoinFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload>[]
          }
          create: {
            args: Prisma.LuckyCoinCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload>
          }
          createMany: {
            args: Prisma.LuckyCoinCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LuckyCoinDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload>
          }
          update: {
            args: Prisma.LuckyCoinUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload>
          }
          deleteMany: {
            args: Prisma.LuckyCoinDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LuckyCoinUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LuckyCoinUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyCoinPayload>
          }
          aggregate: {
            args: Prisma.LuckyCoinAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLuckyCoin>
          }
          groupBy: {
            args: Prisma.LuckyCoinGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LuckyCoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.LuckyCoinCountArgs<ExtArgs>,
            result: $Utils.Optional<LuckyCoinCountAggregateOutputType> | number
          }
        }
      }
      LuckyItem: {
        payload: Prisma.$LuckyItemPayload<ExtArgs>
        fields: Prisma.LuckyItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LuckyItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LuckyItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload>
          }
          findFirst: {
            args: Prisma.LuckyItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LuckyItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload>
          }
          findMany: {
            args: Prisma.LuckyItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload>[]
          }
          create: {
            args: Prisma.LuckyItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload>
          }
          createMany: {
            args: Prisma.LuckyItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LuckyItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload>
          }
          update: {
            args: Prisma.LuckyItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload>
          }
          deleteMany: {
            args: Prisma.LuckyItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LuckyItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LuckyItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LuckyItemPayload>
          }
          aggregate: {
            args: Prisma.LuckyItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLuckyItem>
          }
          groupBy: {
            args: Prisma.LuckyItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LuckyItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.LuckyItemCountArgs<ExtArgs>,
            result: $Utils.Optional<LuckyItemCountAggregateOutputType> | number
          }
        }
      }
      MEMB_STAT: {
        payload: Prisma.$MEMB_STATPayload<ExtArgs>
        fields: Prisma.MEMB_STATFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MEMB_STATFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MEMB_STATFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload>
          }
          findFirst: {
            args: Prisma.MEMB_STATFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MEMB_STATFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload>
          }
          findMany: {
            args: Prisma.MEMB_STATFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload>[]
          }
          create: {
            args: Prisma.MEMB_STATCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload>
          }
          createMany: {
            args: Prisma.MEMB_STATCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MEMB_STATDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload>
          }
          update: {
            args: Prisma.MEMB_STATUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload>
          }
          deleteMany: {
            args: Prisma.MEMB_STATDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MEMB_STATUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MEMB_STATUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MEMB_STATPayload>
          }
          aggregate: {
            args: Prisma.MEMB_STATAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMEMB_STAT>
          }
          groupBy: {
            args: Prisma.MEMB_STATGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MEMB_STATGroupByOutputType>[]
          }
          count: {
            args: Prisma.MEMB_STATCountArgs<ExtArgs>,
            result: $Utils.Optional<MEMB_STATCountAggregateOutputType> | number
          }
        }
      }
      MasterSkillTree: {
        payload: Prisma.$MasterSkillTreePayload<ExtArgs>
        fields: Prisma.MasterSkillTreeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterSkillTreeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterSkillTreeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload>
          }
          findFirst: {
            args: Prisma.MasterSkillTreeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterSkillTreeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload>
          }
          findMany: {
            args: Prisma.MasterSkillTreeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload>[]
          }
          create: {
            args: Prisma.MasterSkillTreeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload>
          }
          createMany: {
            args: Prisma.MasterSkillTreeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MasterSkillTreeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload>
          }
          update: {
            args: Prisma.MasterSkillTreeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload>
          }
          deleteMany: {
            args: Prisma.MasterSkillTreeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MasterSkillTreeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MasterSkillTreeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MasterSkillTreePayload>
          }
          aggregate: {
            args: Prisma.MasterSkillTreeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMasterSkillTree>
          }
          groupBy: {
            args: Prisma.MasterSkillTreeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MasterSkillTreeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterSkillTreeCountArgs<ExtArgs>,
            result: $Utils.Optional<MasterSkillTreeCountAggregateOutputType> | number
          }
        }
      }
      MuCastle_DATA: {
        payload: Prisma.$MuCastle_DATAPayload<ExtArgs>
        fields: Prisma.MuCastle_DATAFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MuCastle_DATAFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MuCastle_DATAFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload>
          }
          findFirst: {
            args: Prisma.MuCastle_DATAFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MuCastle_DATAFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload>
          }
          findMany: {
            args: Prisma.MuCastle_DATAFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload>[]
          }
          create: {
            args: Prisma.MuCastle_DATACreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload>
          }
          createMany: {
            args: Prisma.MuCastle_DATACreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MuCastle_DATADeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload>
          }
          update: {
            args: Prisma.MuCastle_DATAUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload>
          }
          deleteMany: {
            args: Prisma.MuCastle_DATADeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MuCastle_DATAUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MuCastle_DATAUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_DATAPayload>
          }
          aggregate: {
            args: Prisma.MuCastle_DATAAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMuCastle_DATA>
          }
          groupBy: {
            args: Prisma.MuCastle_DATAGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MuCastle_DATAGroupByOutputType>[]
          }
          count: {
            args: Prisma.MuCastle_DATACountArgs<ExtArgs>,
            result: $Utils.Optional<MuCastle_DATACountAggregateOutputType> | number
          }
        }
      }
      MuCastle_NPC: {
        payload: Prisma.$MuCastle_NPCPayload<ExtArgs>
        fields: Prisma.MuCastle_NPCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MuCastle_NPCFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MuCastle_NPCFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload>
          }
          findFirst: {
            args: Prisma.MuCastle_NPCFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MuCastle_NPCFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload>
          }
          findMany: {
            args: Prisma.MuCastle_NPCFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload>[]
          }
          create: {
            args: Prisma.MuCastle_NPCCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload>
          }
          createMany: {
            args: Prisma.MuCastle_NPCCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MuCastle_NPCDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload>
          }
          update: {
            args: Prisma.MuCastle_NPCUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload>
          }
          deleteMany: {
            args: Prisma.MuCastle_NPCDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MuCastle_NPCUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MuCastle_NPCUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_NPCPayload>
          }
          aggregate: {
            args: Prisma.MuCastle_NPCAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMuCastle_NPC>
          }
          groupBy: {
            args: Prisma.MuCastle_NPCGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MuCastle_NPCGroupByOutputType>[]
          }
          count: {
            args: Prisma.MuCastle_NPCCountArgs<ExtArgs>,
            result: $Utils.Optional<MuCastle_NPCCountAggregateOutputType> | number
          }
        }
      }
      MuCastle_REG_SIEGE: {
        payload: Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>
        fields: Prisma.MuCastle_REG_SIEGEFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MuCastle_REG_SIEGEFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MuCastle_REG_SIEGEFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload>
          }
          findFirst: {
            args: Prisma.MuCastle_REG_SIEGEFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MuCastle_REG_SIEGEFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload>
          }
          findMany: {
            args: Prisma.MuCastle_REG_SIEGEFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload>[]
          }
          create: {
            args: Prisma.MuCastle_REG_SIEGECreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload>
          }
          createMany: {
            args: Prisma.MuCastle_REG_SIEGECreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MuCastle_REG_SIEGEDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload>
          }
          update: {
            args: Prisma.MuCastle_REG_SIEGEUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload>
          }
          deleteMany: {
            args: Prisma.MuCastle_REG_SIEGEDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MuCastle_REG_SIEGEUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MuCastle_REG_SIEGEUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MuCastle_REG_SIEGEPayload>
          }
          aggregate: {
            args: Prisma.MuCastle_REG_SIEGEAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMuCastle_REG_SIEGE>
          }
          groupBy: {
            args: Prisma.MuCastle_REG_SIEGEGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MuCastle_REG_SIEGEGroupByOutputType>[]
          }
          count: {
            args: Prisma.MuCastle_REG_SIEGECountArgs<ExtArgs>,
            result: $Utils.Optional<MuCastle_REG_SIEGECountAggregateOutputType> | number
          }
        }
      }
      OptionData: {
        payload: Prisma.$OptionDataPayload<ExtArgs>
        fields: Prisma.OptionDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionDataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionDataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload>
          }
          findFirst: {
            args: Prisma.OptionDataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionDataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload>
          }
          findMany: {
            args: Prisma.OptionDataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload>[]
          }
          create: {
            args: Prisma.OptionDataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload>
          }
          createMany: {
            args: Prisma.OptionDataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OptionDataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload>
          }
          update: {
            args: Prisma.OptionDataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload>
          }
          deleteMany: {
            args: Prisma.OptionDataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OptionDataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OptionDataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OptionDataPayload>
          }
          aggregate: {
            args: Prisma.OptionDataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOptionData>
          }
          groupBy: {
            args: Prisma.OptionDataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OptionDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptionDataCountArgs<ExtArgs>,
            result: $Utils.Optional<OptionDataCountAggregateOutputType> | number
          }
        }
      }
      QuestKillCount: {
        payload: Prisma.$QuestKillCountPayload<ExtArgs>
        fields: Prisma.QuestKillCountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestKillCountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestKillCountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload>
          }
          findFirst: {
            args: Prisma.QuestKillCountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestKillCountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload>
          }
          findMany: {
            args: Prisma.QuestKillCountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload>[]
          }
          create: {
            args: Prisma.QuestKillCountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload>
          }
          createMany: {
            args: Prisma.QuestKillCountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.QuestKillCountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload>
          }
          update: {
            args: Prisma.QuestKillCountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload>
          }
          deleteMany: {
            args: Prisma.QuestKillCountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuestKillCountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuestKillCountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestKillCountPayload>
          }
          aggregate: {
            args: Prisma.QuestKillCountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuestKillCount>
          }
          groupBy: {
            args: Prisma.QuestKillCountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuestKillCountGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestKillCountCountArgs<ExtArgs>,
            result: $Utils.Optional<QuestKillCountCountAggregateOutputType> | number
          }
        }
      }
      QuestWorld: {
        payload: Prisma.$QuestWorldPayload<ExtArgs>
        fields: Prisma.QuestWorldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestWorldFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestWorldFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload>
          }
          findFirst: {
            args: Prisma.QuestWorldFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestWorldFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload>
          }
          findMany: {
            args: Prisma.QuestWorldFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload>[]
          }
          create: {
            args: Prisma.QuestWorldCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload>
          }
          createMany: {
            args: Prisma.QuestWorldCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.QuestWorldDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload>
          }
          update: {
            args: Prisma.QuestWorldUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload>
          }
          deleteMany: {
            args: Prisma.QuestWorldDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuestWorldUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuestWorldUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$QuestWorldPayload>
          }
          aggregate: {
            args: Prisma.QuestWorldAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuestWorld>
          }
          groupBy: {
            args: Prisma.QuestWorldGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuestWorldGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestWorldCountArgs<ExtArgs>,
            result: $Utils.Optional<QuestWorldCountAggregateOutputType> | number
          }
        }
      }
      RankingBloodCastle: {
        payload: Prisma.$RankingBloodCastlePayload<ExtArgs>
        fields: Prisma.RankingBloodCastleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankingBloodCastleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankingBloodCastleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload>
          }
          findFirst: {
            args: Prisma.RankingBloodCastleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankingBloodCastleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload>
          }
          findMany: {
            args: Prisma.RankingBloodCastleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload>[]
          }
          create: {
            args: Prisma.RankingBloodCastleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload>
          }
          createMany: {
            args: Prisma.RankingBloodCastleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RankingBloodCastleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload>
          }
          update: {
            args: Prisma.RankingBloodCastleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload>
          }
          deleteMany: {
            args: Prisma.RankingBloodCastleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RankingBloodCastleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RankingBloodCastleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingBloodCastlePayload>
          }
          aggregate: {
            args: Prisma.RankingBloodCastleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRankingBloodCastle>
          }
          groupBy: {
            args: Prisma.RankingBloodCastleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RankingBloodCastleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankingBloodCastleCountArgs<ExtArgs>,
            result: $Utils.Optional<RankingBloodCastleCountAggregateOutputType> | number
          }
        }
      }
      RankingChaosCastle: {
        payload: Prisma.$RankingChaosCastlePayload<ExtArgs>
        fields: Prisma.RankingChaosCastleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankingChaosCastleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankingChaosCastleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload>
          }
          findFirst: {
            args: Prisma.RankingChaosCastleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankingChaosCastleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload>
          }
          findMany: {
            args: Prisma.RankingChaosCastleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload>[]
          }
          create: {
            args: Prisma.RankingChaosCastleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload>
          }
          createMany: {
            args: Prisma.RankingChaosCastleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RankingChaosCastleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload>
          }
          update: {
            args: Prisma.RankingChaosCastleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload>
          }
          deleteMany: {
            args: Prisma.RankingChaosCastleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RankingChaosCastleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RankingChaosCastleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingChaosCastlePayload>
          }
          aggregate: {
            args: Prisma.RankingChaosCastleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRankingChaosCastle>
          }
          groupBy: {
            args: Prisma.RankingChaosCastleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RankingChaosCastleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankingChaosCastleCountArgs<ExtArgs>,
            result: $Utils.Optional<RankingChaosCastleCountAggregateOutputType> | number
          }
        }
      }
      RankingDevilSquare: {
        payload: Prisma.$RankingDevilSquarePayload<ExtArgs>
        fields: Prisma.RankingDevilSquareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankingDevilSquareFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankingDevilSquareFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload>
          }
          findFirst: {
            args: Prisma.RankingDevilSquareFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankingDevilSquareFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload>
          }
          findMany: {
            args: Prisma.RankingDevilSquareFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload>[]
          }
          create: {
            args: Prisma.RankingDevilSquareCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload>
          }
          createMany: {
            args: Prisma.RankingDevilSquareCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RankingDevilSquareDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload>
          }
          update: {
            args: Prisma.RankingDevilSquareUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload>
          }
          deleteMany: {
            args: Prisma.RankingDevilSquareDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RankingDevilSquareUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RankingDevilSquareUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDevilSquarePayload>
          }
          aggregate: {
            args: Prisma.RankingDevilSquareAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRankingDevilSquare>
          }
          groupBy: {
            args: Prisma.RankingDevilSquareGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RankingDevilSquareGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankingDevilSquareCountArgs<ExtArgs>,
            result: $Utils.Optional<RankingDevilSquareCountAggregateOutputType> | number
          }
        }
      }
      RankingDuel: {
        payload: Prisma.$RankingDuelPayload<ExtArgs>
        fields: Prisma.RankingDuelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankingDuelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankingDuelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload>
          }
          findFirst: {
            args: Prisma.RankingDuelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankingDuelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload>
          }
          findMany: {
            args: Prisma.RankingDuelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload>[]
          }
          create: {
            args: Prisma.RankingDuelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload>
          }
          createMany: {
            args: Prisma.RankingDuelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RankingDuelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload>
          }
          update: {
            args: Prisma.RankingDuelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload>
          }
          deleteMany: {
            args: Prisma.RankingDuelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RankingDuelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RankingDuelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingDuelPayload>
          }
          aggregate: {
            args: Prisma.RankingDuelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRankingDuel>
          }
          groupBy: {
            args: Prisma.RankingDuelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RankingDuelGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankingDuelCountArgs<ExtArgs>,
            result: $Utils.Optional<RankingDuelCountAggregateOutputType> | number
          }
        }
      }
      RankingIllusionTemple: {
        payload: Prisma.$RankingIllusionTemplePayload<ExtArgs>
        fields: Prisma.RankingIllusionTempleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankingIllusionTempleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankingIllusionTempleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload>
          }
          findFirst: {
            args: Prisma.RankingIllusionTempleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankingIllusionTempleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload>
          }
          findMany: {
            args: Prisma.RankingIllusionTempleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload>[]
          }
          create: {
            args: Prisma.RankingIllusionTempleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload>
          }
          createMany: {
            args: Prisma.RankingIllusionTempleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RankingIllusionTempleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload>
          }
          update: {
            args: Prisma.RankingIllusionTempleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload>
          }
          deleteMany: {
            args: Prisma.RankingIllusionTempleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RankingIllusionTempleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RankingIllusionTempleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RankingIllusionTemplePayload>
          }
          aggregate: {
            args: Prisma.RankingIllusionTempleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRankingIllusionTemple>
          }
          groupBy: {
            args: Prisma.RankingIllusionTempleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RankingIllusionTempleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankingIllusionTempleCountArgs<ExtArgs>,
            result: $Utils.Optional<RankingIllusionTempleCountAggregateOutputType> | number
          }
        }
      }
      T_CGuid: {
        payload: Prisma.$T_CGuidPayload<ExtArgs>
        fields: Prisma.T_CGuidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.T_CGuidFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.T_CGuidFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload>
          }
          findFirst: {
            args: Prisma.T_CGuidFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.T_CGuidFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload>
          }
          findMany: {
            args: Prisma.T_CGuidFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload>[]
          }
          create: {
            args: Prisma.T_CGuidCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload>
          }
          createMany: {
            args: Prisma.T_CGuidCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.T_CGuidDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload>
          }
          update: {
            args: Prisma.T_CGuidUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload>
          }
          deleteMany: {
            args: Prisma.T_CGuidDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.T_CGuidUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.T_CGuidUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_CGuidPayload>
          }
          aggregate: {
            args: Prisma.T_CGuidAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateT_CGuid>
          }
          groupBy: {
            args: Prisma.T_CGuidGroupByArgs<ExtArgs>,
            result: $Utils.Optional<T_CGuidGroupByOutputType>[]
          }
          count: {
            args: Prisma.T_CGuidCountArgs<ExtArgs>,
            result: $Utils.Optional<T_CGuidCountAggregateOutputType> | number
          }
        }
      }
      T_FriendMail: {
        payload: Prisma.$T_FriendMailPayload<ExtArgs>
        fields: Prisma.T_FriendMailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.T_FriendMailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.T_FriendMailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload>
          }
          findFirst: {
            args: Prisma.T_FriendMailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.T_FriendMailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload>
          }
          findMany: {
            args: Prisma.T_FriendMailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload>[]
          }
          create: {
            args: Prisma.T_FriendMailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload>
          }
          createMany: {
            args: Prisma.T_FriendMailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.T_FriendMailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload>
          }
          update: {
            args: Prisma.T_FriendMailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload>
          }
          deleteMany: {
            args: Prisma.T_FriendMailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.T_FriendMailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.T_FriendMailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMailPayload>
          }
          aggregate: {
            args: Prisma.T_FriendMailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateT_FriendMail>
          }
          groupBy: {
            args: Prisma.T_FriendMailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<T_FriendMailGroupByOutputType>[]
          }
          count: {
            args: Prisma.T_FriendMailCountArgs<ExtArgs>,
            result: $Utils.Optional<T_FriendMailCountAggregateOutputType> | number
          }
        }
      }
      T_FriendMain: {
        payload: Prisma.$T_FriendMainPayload<ExtArgs>
        fields: Prisma.T_FriendMainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.T_FriendMainFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.T_FriendMainFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload>
          }
          findFirst: {
            args: Prisma.T_FriendMainFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.T_FriendMainFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload>
          }
          findMany: {
            args: Prisma.T_FriendMainFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload>[]
          }
          create: {
            args: Prisma.T_FriendMainCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload>
          }
          createMany: {
            args: Prisma.T_FriendMainCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.T_FriendMainDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload>
          }
          update: {
            args: Prisma.T_FriendMainUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload>
          }
          deleteMany: {
            args: Prisma.T_FriendMainDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.T_FriendMainUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.T_FriendMainUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_FriendMainPayload>
          }
          aggregate: {
            args: Prisma.T_FriendMainAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateT_FriendMain>
          }
          groupBy: {
            args: Prisma.T_FriendMainGroupByArgs<ExtArgs>,
            result: $Utils.Optional<T_FriendMainGroupByOutputType>[]
          }
          count: {
            args: Prisma.T_FriendMainCountArgs<ExtArgs>,
            result: $Utils.Optional<T_FriendMainCountAggregateOutputType> | number
          }
        }
      }
      T_PetItem_Info: {
        payload: Prisma.$T_PetItem_InfoPayload<ExtArgs>
        fields: Prisma.T_PetItem_InfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.T_PetItem_InfoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.T_PetItem_InfoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload>
          }
          findFirst: {
            args: Prisma.T_PetItem_InfoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.T_PetItem_InfoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload>
          }
          findMany: {
            args: Prisma.T_PetItem_InfoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload>[]
          }
          create: {
            args: Prisma.T_PetItem_InfoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload>
          }
          createMany: {
            args: Prisma.T_PetItem_InfoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.T_PetItem_InfoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload>
          }
          update: {
            args: Prisma.T_PetItem_InfoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload>
          }
          deleteMany: {
            args: Prisma.T_PetItem_InfoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.T_PetItem_InfoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.T_PetItem_InfoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$T_PetItem_InfoPayload>
          }
          aggregate: {
            args: Prisma.T_PetItem_InfoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateT_PetItem_Info>
          }
          groupBy: {
            args: Prisma.T_PetItem_InfoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<T_PetItem_InfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.T_PetItem_InfoCountArgs<ExtArgs>,
            result: $Utils.Optional<T_PetItem_InfoCountAggregateOutputType> | number
          }
        }
      }
      warehouse: {
        payload: Prisma.$warehousePayload<ExtArgs>
        fields: Prisma.warehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.warehouseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.warehouseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          findFirst: {
            args: Prisma.warehouseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.warehouseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          findMany: {
            args: Prisma.warehouseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>[]
          }
          create: {
            args: Prisma.warehouseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          createMany: {
            args: Prisma.warehouseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.warehouseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          update: {
            args: Prisma.warehouseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          deleteMany: {
            args: Prisma.warehouseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.warehouseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.warehouseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$warehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.warehouseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.warehouseCountArgs<ExtArgs>,
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }



  /**
   * Model MEMB_INFO
   */

  export type AggregateMEMB_INFO = {
    _count: MEMB_INFOCountAggregateOutputType | null
    _avg: MEMB_INFOAvgAggregateOutputType | null
    _sum: MEMB_INFOSumAggregateOutputType | null
    _min: MEMB_INFOMinAggregateOutputType | null
    _max: MEMB_INFOMaxAggregateOutputType | null
  }

  export type MEMB_INFOAvgAggregateOutputType = {
    memb_guid: number | null
    AccountLevel: number | null
    vip: number | null
    cash: number | null
    RewardPlayer: number | null
    ChaosPoints: number | null
    BlessPoints: number | null
    SoulPoints: number | null
    LifePoints: number | null
    CreationPoints: number | null
    GuardianPoints: number | null
    GemstonePoints: number | null
    HarmonyPoints: number | null
    LRefiningPoints: number | null
    HRefiningPoints: number | null
    LockPassword: number | null
  }

  export type MEMB_INFOSumAggregateOutputType = {
    memb_guid: number | null
    AccountLevel: number | null
    vip: number | null
    cash: number | null
    RewardPlayer: number | null
    ChaosPoints: number | null
    BlessPoints: number | null
    SoulPoints: number | null
    LifePoints: number | null
    CreationPoints: number | null
    GuardianPoints: number | null
    GemstonePoints: number | null
    HarmonyPoints: number | null
    LRefiningPoints: number | null
    HRefiningPoints: number | null
    LockPassword: number | null
  }

  export type MEMB_INFOMinAggregateOutputType = {
    memb_guid: number | null
    memb___id: string | null
    memb__pwd: string | null
    memb_name: string | null
    sno__numb: string | null
    post_code: string | null
    addr_info: string | null
    addr_deta: string | null
    tel__numb: string | null
    phon_numb: string | null
    mail_addr: string | null
    fpas_ques: string | null
    fpas_answ: string | null
    job__code: string | null
    appl_days: Date | null
    modi_days: Date | null
    out__days: Date | null
    true_days: Date | null
    mail_chek: string | null
    bloc_code: string | null
    ctl1_code: string | null
    AccountLevel: number | null
    AccountExpireDate: Date | null
    vip: number | null
    cash: number | null
    RewardPlayer: number | null
    ChaosPoints: number | null
    BlessPoints: number | null
    SoulPoints: number | null
    LifePoints: number | null
    CreationPoints: number | null
    GuardianPoints: number | null
    GemstonePoints: number | null
    HarmonyPoints: number | null
    LRefiningPoints: number | null
    HRefiningPoints: number | null
    LockPassword: number | null
  }

  export type MEMB_INFOMaxAggregateOutputType = {
    memb_guid: number | null
    memb___id: string | null
    memb__pwd: string | null
    memb_name: string | null
    sno__numb: string | null
    post_code: string | null
    addr_info: string | null
    addr_deta: string | null
    tel__numb: string | null
    phon_numb: string | null
    mail_addr: string | null
    fpas_ques: string | null
    fpas_answ: string | null
    job__code: string | null
    appl_days: Date | null
    modi_days: Date | null
    out__days: Date | null
    true_days: Date | null
    mail_chek: string | null
    bloc_code: string | null
    ctl1_code: string | null
    AccountLevel: number | null
    AccountExpireDate: Date | null
    vip: number | null
    cash: number | null
    RewardPlayer: number | null
    ChaosPoints: number | null
    BlessPoints: number | null
    SoulPoints: number | null
    LifePoints: number | null
    CreationPoints: number | null
    GuardianPoints: number | null
    GemstonePoints: number | null
    HarmonyPoints: number | null
    LRefiningPoints: number | null
    HRefiningPoints: number | null
    LockPassword: number | null
  }

  export type MEMB_INFOCountAggregateOutputType = {
    memb_guid: number
    memb___id: number
    memb__pwd: number
    memb_name: number
    sno__numb: number
    post_code: number
    addr_info: number
    addr_deta: number
    tel__numb: number
    phon_numb: number
    mail_addr: number
    fpas_ques: number
    fpas_answ: number
    job__code: number
    appl_days: number
    modi_days: number
    out__days: number
    true_days: number
    mail_chek: number
    bloc_code: number
    ctl1_code: number
    AccountLevel: number
    AccountExpireDate: number
    vip: number
    cash: number
    RewardPlayer: number
    ChaosPoints: number
    BlessPoints: number
    SoulPoints: number
    LifePoints: number
    CreationPoints: number
    GuardianPoints: number
    GemstonePoints: number
    HarmonyPoints: number
    LRefiningPoints: number
    HRefiningPoints: number
    LockPassword: number
    _all: number
  }


  export type MEMB_INFOAvgAggregateInputType = {
    memb_guid?: true
    AccountLevel?: true
    vip?: true
    cash?: true
    RewardPlayer?: true
    ChaosPoints?: true
    BlessPoints?: true
    SoulPoints?: true
    LifePoints?: true
    CreationPoints?: true
    GuardianPoints?: true
    GemstonePoints?: true
    HarmonyPoints?: true
    LRefiningPoints?: true
    HRefiningPoints?: true
    LockPassword?: true
  }

  export type MEMB_INFOSumAggregateInputType = {
    memb_guid?: true
    AccountLevel?: true
    vip?: true
    cash?: true
    RewardPlayer?: true
    ChaosPoints?: true
    BlessPoints?: true
    SoulPoints?: true
    LifePoints?: true
    CreationPoints?: true
    GuardianPoints?: true
    GemstonePoints?: true
    HarmonyPoints?: true
    LRefiningPoints?: true
    HRefiningPoints?: true
    LockPassword?: true
  }

  export type MEMB_INFOMinAggregateInputType = {
    memb_guid?: true
    memb___id?: true
    memb__pwd?: true
    memb_name?: true
    sno__numb?: true
    post_code?: true
    addr_info?: true
    addr_deta?: true
    tel__numb?: true
    phon_numb?: true
    mail_addr?: true
    fpas_ques?: true
    fpas_answ?: true
    job__code?: true
    appl_days?: true
    modi_days?: true
    out__days?: true
    true_days?: true
    mail_chek?: true
    bloc_code?: true
    ctl1_code?: true
    AccountLevel?: true
    AccountExpireDate?: true
    vip?: true
    cash?: true
    RewardPlayer?: true
    ChaosPoints?: true
    BlessPoints?: true
    SoulPoints?: true
    LifePoints?: true
    CreationPoints?: true
    GuardianPoints?: true
    GemstonePoints?: true
    HarmonyPoints?: true
    LRefiningPoints?: true
    HRefiningPoints?: true
    LockPassword?: true
  }

  export type MEMB_INFOMaxAggregateInputType = {
    memb_guid?: true
    memb___id?: true
    memb__pwd?: true
    memb_name?: true
    sno__numb?: true
    post_code?: true
    addr_info?: true
    addr_deta?: true
    tel__numb?: true
    phon_numb?: true
    mail_addr?: true
    fpas_ques?: true
    fpas_answ?: true
    job__code?: true
    appl_days?: true
    modi_days?: true
    out__days?: true
    true_days?: true
    mail_chek?: true
    bloc_code?: true
    ctl1_code?: true
    AccountLevel?: true
    AccountExpireDate?: true
    vip?: true
    cash?: true
    RewardPlayer?: true
    ChaosPoints?: true
    BlessPoints?: true
    SoulPoints?: true
    LifePoints?: true
    CreationPoints?: true
    GuardianPoints?: true
    GemstonePoints?: true
    HarmonyPoints?: true
    LRefiningPoints?: true
    HRefiningPoints?: true
    LockPassword?: true
  }

  export type MEMB_INFOCountAggregateInputType = {
    memb_guid?: true
    memb___id?: true
    memb__pwd?: true
    memb_name?: true
    sno__numb?: true
    post_code?: true
    addr_info?: true
    addr_deta?: true
    tel__numb?: true
    phon_numb?: true
    mail_addr?: true
    fpas_ques?: true
    fpas_answ?: true
    job__code?: true
    appl_days?: true
    modi_days?: true
    out__days?: true
    true_days?: true
    mail_chek?: true
    bloc_code?: true
    ctl1_code?: true
    AccountLevel?: true
    AccountExpireDate?: true
    vip?: true
    cash?: true
    RewardPlayer?: true
    ChaosPoints?: true
    BlessPoints?: true
    SoulPoints?: true
    LifePoints?: true
    CreationPoints?: true
    GuardianPoints?: true
    GemstonePoints?: true
    HarmonyPoints?: true
    LRefiningPoints?: true
    HRefiningPoints?: true
    LockPassword?: true
    _all?: true
  }

  export type MEMB_INFOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEMB_INFO to aggregate.
     */
    where?: MEMB_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEMB_INFOS to fetch.
     */
    orderBy?: MEMB_INFOOrderByWithRelationInput | MEMB_INFOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEMB_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEMB_INFOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEMB_INFOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEMB_INFOS
    **/
    _count?: true | MEMB_INFOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MEMB_INFOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MEMB_INFOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEMB_INFOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEMB_INFOMaxAggregateInputType
  }

  export type GetMEMB_INFOAggregateType<T extends MEMB_INFOAggregateArgs> = {
        [P in keyof T & keyof AggregateMEMB_INFO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEMB_INFO[P]>
      : GetScalarType<T[P], AggregateMEMB_INFO[P]>
  }




  export type MEMB_INFOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEMB_INFOWhereInput
    orderBy?: MEMB_INFOOrderByWithAggregationInput | MEMB_INFOOrderByWithAggregationInput[]
    by: MEMB_INFOScalarFieldEnum[] | MEMB_INFOScalarFieldEnum
    having?: MEMB_INFOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEMB_INFOCountAggregateInputType | true
    _avg?: MEMB_INFOAvgAggregateInputType
    _sum?: MEMB_INFOSumAggregateInputType
    _min?: MEMB_INFOMinAggregateInputType
    _max?: MEMB_INFOMaxAggregateInputType
  }

  export type MEMB_INFOGroupByOutputType = {
    memb_guid: number
    memb___id: string
    memb__pwd: string
    memb_name: string
    sno__numb: string
    post_code: string | null
    addr_info: string | null
    addr_deta: string | null
    tel__numb: string | null
    phon_numb: string | null
    mail_addr: string | null
    fpas_ques: string | null
    fpas_answ: string | null
    job__code: string | null
    appl_days: Date | null
    modi_days: Date | null
    out__days: Date | null
    true_days: Date | null
    mail_chek: string | null
    bloc_code: string
    ctl1_code: string
    AccountLevel: number
    AccountExpireDate: Date
    vip: number
    cash: number
    RewardPlayer: number
    ChaosPoints: number
    BlessPoints: number
    SoulPoints: number
    LifePoints: number
    CreationPoints: number
    GuardianPoints: number
    GemstonePoints: number
    HarmonyPoints: number
    LRefiningPoints: number
    HRefiningPoints: number
    LockPassword: number
    _count: MEMB_INFOCountAggregateOutputType | null
    _avg: MEMB_INFOAvgAggregateOutputType | null
    _sum: MEMB_INFOSumAggregateOutputType | null
    _min: MEMB_INFOMinAggregateOutputType | null
    _max: MEMB_INFOMaxAggregateOutputType | null
  }

  type GetMEMB_INFOGroupByPayload<T extends MEMB_INFOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEMB_INFOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEMB_INFOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEMB_INFOGroupByOutputType[P]>
            : GetScalarType<T[P], MEMB_INFOGroupByOutputType[P]>
        }
      >
    >


  export type MEMB_INFOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    memb_guid?: boolean
    memb___id?: boolean
    memb__pwd?: boolean
    memb_name?: boolean
    sno__numb?: boolean
    post_code?: boolean
    addr_info?: boolean
    addr_deta?: boolean
    tel__numb?: boolean
    phon_numb?: boolean
    mail_addr?: boolean
    fpas_ques?: boolean
    fpas_answ?: boolean
    job__code?: boolean
    appl_days?: boolean
    modi_days?: boolean
    out__days?: boolean
    true_days?: boolean
    mail_chek?: boolean
    bloc_code?: boolean
    ctl1_code?: boolean
    AccountLevel?: boolean
    AccountExpireDate?: boolean
    vip?: boolean
    cash?: boolean
    RewardPlayer?: boolean
    ChaosPoints?: boolean
    BlessPoints?: boolean
    SoulPoints?: boolean
    LifePoints?: boolean
    CreationPoints?: boolean
    GuardianPoints?: boolean
    GemstonePoints?: boolean
    HarmonyPoints?: boolean
    LRefiningPoints?: boolean
    HRefiningPoints?: boolean
    LockPassword?: boolean
  }, ExtArgs["result"]["mEMB_INFO"]>

  export type MEMB_INFOSelectScalar = {
    memb_guid?: boolean
    memb___id?: boolean
    memb__pwd?: boolean
    memb_name?: boolean
    sno__numb?: boolean
    post_code?: boolean
    addr_info?: boolean
    addr_deta?: boolean
    tel__numb?: boolean
    phon_numb?: boolean
    mail_addr?: boolean
    fpas_ques?: boolean
    fpas_answ?: boolean
    job__code?: boolean
    appl_days?: boolean
    modi_days?: boolean
    out__days?: boolean
    true_days?: boolean
    mail_chek?: boolean
    bloc_code?: boolean
    ctl1_code?: boolean
    AccountLevel?: boolean
    AccountExpireDate?: boolean
    vip?: boolean
    cash?: boolean
    RewardPlayer?: boolean
    ChaosPoints?: boolean
    BlessPoints?: boolean
    SoulPoints?: boolean
    LifePoints?: boolean
    CreationPoints?: boolean
    GuardianPoints?: boolean
    GemstonePoints?: boolean
    HarmonyPoints?: boolean
    LRefiningPoints?: boolean
    HRefiningPoints?: boolean
    LockPassword?: boolean
  }


  export type $MEMB_INFOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEMB_INFO"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      memb_guid: number
      memb___id: string
      memb__pwd: string
      memb_name: string
      sno__numb: string
      post_code: string | null
      addr_info: string | null
      addr_deta: string | null
      tel__numb: string | null
      phon_numb: string | null
      mail_addr: string | null
      fpas_ques: string | null
      fpas_answ: string | null
      job__code: string | null
      appl_days: Date | null
      modi_days: Date | null
      out__days: Date | null
      true_days: Date | null
      mail_chek: string | null
      bloc_code: string
      ctl1_code: string
      AccountLevel: number
      AccountExpireDate: Date
      vip: number
      cash: number
      RewardPlayer: number
      ChaosPoints: number
      BlessPoints: number
      SoulPoints: number
      LifePoints: number
      CreationPoints: number
      GuardianPoints: number
      GemstonePoints: number
      HarmonyPoints: number
      LRefiningPoints: number
      HRefiningPoints: number
      LockPassword: number
    }, ExtArgs["result"]["mEMB_INFO"]>
    composites: {}
  }


  type MEMB_INFOGetPayload<S extends boolean | null | undefined | MEMB_INFODefaultArgs> = $Result.GetResult<Prisma.$MEMB_INFOPayload, S>

  type MEMB_INFOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEMB_INFOFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MEMB_INFOCountAggregateInputType | true
    }

  export interface MEMB_INFODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEMB_INFO'], meta: { name: 'MEMB_INFO' } }
    /**
     * Find zero or one MEMB_INFO that matches the filter.
     * @param {MEMB_INFOFindUniqueArgs} args - Arguments to find a MEMB_INFO
     * @example
     * // Get one MEMB_INFO
     * const mEMB_INFO = await prisma.mEMB_INFO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEMB_INFOFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_INFOFindUniqueArgs<ExtArgs>>
    ): Prisma__MEMB_INFOClient<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEMB_INFO that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEMB_INFOFindUniqueOrThrowArgs} args - Arguments to find a MEMB_INFO
     * @example
     * // Get one MEMB_INFO
     * const mEMB_INFO = await prisma.mEMB_INFO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEMB_INFOFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_INFOFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEMB_INFOClient<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEMB_INFO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_INFOFindFirstArgs} args - Arguments to find a MEMB_INFO
     * @example
     * // Get one MEMB_INFO
     * const mEMB_INFO = await prisma.mEMB_INFO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEMB_INFOFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_INFOFindFirstArgs<ExtArgs>>
    ): Prisma__MEMB_INFOClient<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEMB_INFO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_INFOFindFirstOrThrowArgs} args - Arguments to find a MEMB_INFO
     * @example
     * // Get one MEMB_INFO
     * const mEMB_INFO = await prisma.mEMB_INFO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEMB_INFOFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_INFOFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEMB_INFOClient<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEMB_INFOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_INFOFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEMB_INFOS
     * const mEMB_INFOS = await prisma.mEMB_INFO.findMany()
     * 
     * // Get first 10 MEMB_INFOS
     * const mEMB_INFOS = await prisma.mEMB_INFO.findMany({ take: 10 })
     * 
     * // Only select the `memb_guid`
     * const mEMB_INFOWithMemb_guidOnly = await prisma.mEMB_INFO.findMany({ select: { memb_guid: true } })
     * 
    **/
    findMany<T extends MEMB_INFOFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_INFOFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEMB_INFO.
     * @param {MEMB_INFOCreateArgs} args - Arguments to create a MEMB_INFO.
     * @example
     * // Create one MEMB_INFO
     * const MEMB_INFO = await prisma.mEMB_INFO.create({
     *   data: {
     *     // ... data to create a MEMB_INFO
     *   }
     * })
     * 
    **/
    create<T extends MEMB_INFOCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_INFOCreateArgs<ExtArgs>>
    ): Prisma__MEMB_INFOClient<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEMB_INFOS.
     *     @param {MEMB_INFOCreateManyArgs} args - Arguments to create many MEMB_INFOS.
     *     @example
     *     // Create many MEMB_INFOS
     *     const mEMB_INFO = await prisma.mEMB_INFO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEMB_INFOCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_INFOCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEMB_INFO.
     * @param {MEMB_INFODeleteArgs} args - Arguments to delete one MEMB_INFO.
     * @example
     * // Delete one MEMB_INFO
     * const MEMB_INFO = await prisma.mEMB_INFO.delete({
     *   where: {
     *     // ... filter to delete one MEMB_INFO
     *   }
     * })
     * 
    **/
    delete<T extends MEMB_INFODeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_INFODeleteArgs<ExtArgs>>
    ): Prisma__MEMB_INFOClient<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEMB_INFO.
     * @param {MEMB_INFOUpdateArgs} args - Arguments to update one MEMB_INFO.
     * @example
     * // Update one MEMB_INFO
     * const mEMB_INFO = await prisma.mEMB_INFO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEMB_INFOUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_INFOUpdateArgs<ExtArgs>>
    ): Prisma__MEMB_INFOClient<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEMB_INFOS.
     * @param {MEMB_INFODeleteManyArgs} args - Arguments to filter MEMB_INFOS to delete.
     * @example
     * // Delete a few MEMB_INFOS
     * const { count } = await prisma.mEMB_INFO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEMB_INFODeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_INFODeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEMB_INFOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_INFOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEMB_INFOS
     * const mEMB_INFO = await prisma.mEMB_INFO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEMB_INFOUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_INFOUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEMB_INFO.
     * @param {MEMB_INFOUpsertArgs} args - Arguments to update or create a MEMB_INFO.
     * @example
     * // Update or create a MEMB_INFO
     * const mEMB_INFO = await prisma.mEMB_INFO.upsert({
     *   create: {
     *     // ... data to create a MEMB_INFO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEMB_INFO we want to update
     *   }
     * })
    **/
    upsert<T extends MEMB_INFOUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_INFOUpsertArgs<ExtArgs>>
    ): Prisma__MEMB_INFOClient<$Result.GetResult<Prisma.$MEMB_INFOPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEMB_INFOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_INFOCountArgs} args - Arguments to filter MEMB_INFOS to count.
     * @example
     * // Count the number of MEMB_INFOS
     * const count = await prisma.mEMB_INFO.count({
     *   where: {
     *     // ... the filter for the MEMB_INFOS we want to count
     *   }
     * })
    **/
    count<T extends MEMB_INFOCountArgs>(
      args?: Subset<T, MEMB_INFOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEMB_INFOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEMB_INFO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_INFOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEMB_INFOAggregateArgs>(args: Subset<T, MEMB_INFOAggregateArgs>): Prisma.PrismaPromise<GetMEMB_INFOAggregateType<T>>

    /**
     * Group by MEMB_INFO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_INFOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEMB_INFOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEMB_INFOGroupByArgs['orderBy'] }
        : { orderBy?: MEMB_INFOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEMB_INFOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEMB_INFOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEMB_INFO model
   */
  readonly fields: MEMB_INFOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEMB_INFO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEMB_INFOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEMB_INFO model
   */ 
  interface MEMB_INFOFieldRefs {
    readonly memb_guid: FieldRef<"MEMB_INFO", 'Int'>
    readonly memb___id: FieldRef<"MEMB_INFO", 'String'>
    readonly memb__pwd: FieldRef<"MEMB_INFO", 'String'>
    readonly memb_name: FieldRef<"MEMB_INFO", 'String'>
    readonly sno__numb: FieldRef<"MEMB_INFO", 'String'>
    readonly post_code: FieldRef<"MEMB_INFO", 'String'>
    readonly addr_info: FieldRef<"MEMB_INFO", 'String'>
    readonly addr_deta: FieldRef<"MEMB_INFO", 'String'>
    readonly tel__numb: FieldRef<"MEMB_INFO", 'String'>
    readonly phon_numb: FieldRef<"MEMB_INFO", 'String'>
    readonly mail_addr: FieldRef<"MEMB_INFO", 'String'>
    readonly fpas_ques: FieldRef<"MEMB_INFO", 'String'>
    readonly fpas_answ: FieldRef<"MEMB_INFO", 'String'>
    readonly job__code: FieldRef<"MEMB_INFO", 'String'>
    readonly appl_days: FieldRef<"MEMB_INFO", 'DateTime'>
    readonly modi_days: FieldRef<"MEMB_INFO", 'DateTime'>
    readonly out__days: FieldRef<"MEMB_INFO", 'DateTime'>
    readonly true_days: FieldRef<"MEMB_INFO", 'DateTime'>
    readonly mail_chek: FieldRef<"MEMB_INFO", 'String'>
    readonly bloc_code: FieldRef<"MEMB_INFO", 'String'>
    readonly ctl1_code: FieldRef<"MEMB_INFO", 'String'>
    readonly AccountLevel: FieldRef<"MEMB_INFO", 'Int'>
    readonly AccountExpireDate: FieldRef<"MEMB_INFO", 'DateTime'>
    readonly vip: FieldRef<"MEMB_INFO", 'Int'>
    readonly cash: FieldRef<"MEMB_INFO", 'Int'>
    readonly RewardPlayer: FieldRef<"MEMB_INFO", 'Int'>
    readonly ChaosPoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly BlessPoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly SoulPoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly LifePoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly CreationPoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly GuardianPoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly GemstonePoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly HarmonyPoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly LRefiningPoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly HRefiningPoints: FieldRef<"MEMB_INFO", 'Int'>
    readonly LockPassword: FieldRef<"MEMB_INFO", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MEMB_INFO findUnique
   */
  export type MEMB_INFOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_INFO to fetch.
     */
    where: MEMB_INFOWhereUniqueInput
  }


  /**
   * MEMB_INFO findUniqueOrThrow
   */
  export type MEMB_INFOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_INFO to fetch.
     */
    where: MEMB_INFOWhereUniqueInput
  }


  /**
   * MEMB_INFO findFirst
   */
  export type MEMB_INFOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_INFO to fetch.
     */
    where?: MEMB_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEMB_INFOS to fetch.
     */
    orderBy?: MEMB_INFOOrderByWithRelationInput | MEMB_INFOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEMB_INFOS.
     */
    cursor?: MEMB_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEMB_INFOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEMB_INFOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEMB_INFOS.
     */
    distinct?: MEMB_INFOScalarFieldEnum | MEMB_INFOScalarFieldEnum[]
  }


  /**
   * MEMB_INFO findFirstOrThrow
   */
  export type MEMB_INFOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_INFO to fetch.
     */
    where?: MEMB_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEMB_INFOS to fetch.
     */
    orderBy?: MEMB_INFOOrderByWithRelationInput | MEMB_INFOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEMB_INFOS.
     */
    cursor?: MEMB_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEMB_INFOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEMB_INFOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEMB_INFOS.
     */
    distinct?: MEMB_INFOScalarFieldEnum | MEMB_INFOScalarFieldEnum[]
  }


  /**
   * MEMB_INFO findMany
   */
  export type MEMB_INFOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_INFOS to fetch.
     */
    where?: MEMB_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEMB_INFOS to fetch.
     */
    orderBy?: MEMB_INFOOrderByWithRelationInput | MEMB_INFOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEMB_INFOS.
     */
    cursor?: MEMB_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEMB_INFOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEMB_INFOS.
     */
    skip?: number
    distinct?: MEMB_INFOScalarFieldEnum | MEMB_INFOScalarFieldEnum[]
  }


  /**
   * MEMB_INFO create
   */
  export type MEMB_INFOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * The data needed to create a MEMB_INFO.
     */
    data: XOR<MEMB_INFOCreateInput, MEMB_INFOUncheckedCreateInput>
  }


  /**
   * MEMB_INFO createMany
   */
  export type MEMB_INFOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEMB_INFOS.
     */
    data: MEMB_INFOCreateManyInput | MEMB_INFOCreateManyInput[]
  }


  /**
   * MEMB_INFO update
   */
  export type MEMB_INFOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * The data needed to update a MEMB_INFO.
     */
    data: XOR<MEMB_INFOUpdateInput, MEMB_INFOUncheckedUpdateInput>
    /**
     * Choose, which MEMB_INFO to update.
     */
    where: MEMB_INFOWhereUniqueInput
  }


  /**
   * MEMB_INFO updateMany
   */
  export type MEMB_INFOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEMB_INFOS.
     */
    data: XOR<MEMB_INFOUpdateManyMutationInput, MEMB_INFOUncheckedUpdateManyInput>
    /**
     * Filter which MEMB_INFOS to update
     */
    where?: MEMB_INFOWhereInput
  }


  /**
   * MEMB_INFO upsert
   */
  export type MEMB_INFOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * The filter to search for the MEMB_INFO to update in case it exists.
     */
    where: MEMB_INFOWhereUniqueInput
    /**
     * In case the MEMB_INFO found by the `where` argument doesn't exist, create a new MEMB_INFO with this data.
     */
    create: XOR<MEMB_INFOCreateInput, MEMB_INFOUncheckedCreateInput>
    /**
     * In case the MEMB_INFO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEMB_INFOUpdateInput, MEMB_INFOUncheckedUpdateInput>
  }


  /**
   * MEMB_INFO delete
   */
  export type MEMB_INFODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
    /**
     * Filter which MEMB_INFO to delete.
     */
    where: MEMB_INFOWhereUniqueInput
  }


  /**
   * MEMB_INFO deleteMany
   */
  export type MEMB_INFODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEMB_INFOS to delete
     */
    where?: MEMB_INFOWhereInput
  }


  /**
   * MEMB_INFO without action
   */
  export type MEMB_INFODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_INFO
     */
    select?: MEMB_INFOSelect<ExtArgs> | null
  }



  /**
   * Model AccountCharacter
   */

  export type AggregateAccountCharacter = {
    _count: AccountCharacterCountAggregateOutputType | null
    _avg: AccountCharacterAvgAggregateOutputType | null
    _sum: AccountCharacterSumAggregateOutputType | null
    _min: AccountCharacterMinAggregateOutputType | null
    _max: AccountCharacterMaxAggregateOutputType | null
  }

  export type AccountCharacterAvgAggregateOutputType = {
    Number: number | null
    MoveCnt: number | null
    ExtClass: number | null
    ExtWarehouse: number | null
    MaxCharacter: number | null
  }

  export type AccountCharacterSumAggregateOutputType = {
    Number: number | null
    MoveCnt: number | null
    ExtClass: number | null
    ExtWarehouse: number | null
    MaxCharacter: number | null
  }

  export type AccountCharacterMinAggregateOutputType = {
    Number: number | null
    Id: string | null
    GameID1: string | null
    GameID2: string | null
    GameID3: string | null
    GameID4: string | null
    GameID5: string | null
    GameIDC: string | null
    MoveCnt: number | null
    ExtClass: number | null
    ExtWarehouse: number | null
    GameID6: string | null
    GameID7: string | null
    GameID8: string | null
    GameID9: string | null
    GameID10: string | null
    MaxCharacter: number | null
  }

  export type AccountCharacterMaxAggregateOutputType = {
    Number: number | null
    Id: string | null
    GameID1: string | null
    GameID2: string | null
    GameID3: string | null
    GameID4: string | null
    GameID5: string | null
    GameIDC: string | null
    MoveCnt: number | null
    ExtClass: number | null
    ExtWarehouse: number | null
    GameID6: string | null
    GameID7: string | null
    GameID8: string | null
    GameID9: string | null
    GameID10: string | null
    MaxCharacter: number | null
  }

  export type AccountCharacterCountAggregateOutputType = {
    Number: number
    Id: number
    GameID1: number
    GameID2: number
    GameID3: number
    GameID4: number
    GameID5: number
    GameIDC: number
    MoveCnt: number
    ExtClass: number
    ExtWarehouse: number
    GameID6: number
    GameID7: number
    GameID8: number
    GameID9: number
    GameID10: number
    MaxCharacter: number
    _all: number
  }


  export type AccountCharacterAvgAggregateInputType = {
    Number?: true
    MoveCnt?: true
    ExtClass?: true
    ExtWarehouse?: true
    MaxCharacter?: true
  }

  export type AccountCharacterSumAggregateInputType = {
    Number?: true
    MoveCnt?: true
    ExtClass?: true
    ExtWarehouse?: true
    MaxCharacter?: true
  }

  export type AccountCharacterMinAggregateInputType = {
    Number?: true
    Id?: true
    GameID1?: true
    GameID2?: true
    GameID3?: true
    GameID4?: true
    GameID5?: true
    GameIDC?: true
    MoveCnt?: true
    ExtClass?: true
    ExtWarehouse?: true
    GameID6?: true
    GameID7?: true
    GameID8?: true
    GameID9?: true
    GameID10?: true
    MaxCharacter?: true
  }

  export type AccountCharacterMaxAggregateInputType = {
    Number?: true
    Id?: true
    GameID1?: true
    GameID2?: true
    GameID3?: true
    GameID4?: true
    GameID5?: true
    GameIDC?: true
    MoveCnt?: true
    ExtClass?: true
    ExtWarehouse?: true
    GameID6?: true
    GameID7?: true
    GameID8?: true
    GameID9?: true
    GameID10?: true
    MaxCharacter?: true
  }

  export type AccountCharacterCountAggregateInputType = {
    Number?: true
    Id?: true
    GameID1?: true
    GameID2?: true
    GameID3?: true
    GameID4?: true
    GameID5?: true
    GameIDC?: true
    MoveCnt?: true
    ExtClass?: true
    ExtWarehouse?: true
    GameID6?: true
    GameID7?: true
    GameID8?: true
    GameID9?: true
    GameID10?: true
    MaxCharacter?: true
    _all?: true
  }

  export type AccountCharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountCharacter to aggregate.
     */
    where?: AccountCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountCharacters to fetch.
     */
    orderBy?: AccountCharacterOrderByWithRelationInput | AccountCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountCharacters
    **/
    _count?: true | AccountCharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountCharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountCharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountCharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountCharacterMaxAggregateInputType
  }

  export type GetAccountCharacterAggregateType<T extends AccountCharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountCharacter[P]>
      : GetScalarType<T[P], AggregateAccountCharacter[P]>
  }




  export type AccountCharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountCharacterWhereInput
    orderBy?: AccountCharacterOrderByWithAggregationInput | AccountCharacterOrderByWithAggregationInput[]
    by: AccountCharacterScalarFieldEnum[] | AccountCharacterScalarFieldEnum
    having?: AccountCharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCharacterCountAggregateInputType | true
    _avg?: AccountCharacterAvgAggregateInputType
    _sum?: AccountCharacterSumAggregateInputType
    _min?: AccountCharacterMinAggregateInputType
    _max?: AccountCharacterMaxAggregateInputType
  }

  export type AccountCharacterGroupByOutputType = {
    Number: number
    Id: string
    GameID1: string | null
    GameID2: string | null
    GameID3: string | null
    GameID4: string | null
    GameID5: string | null
    GameIDC: string | null
    MoveCnt: number | null
    ExtClass: number
    ExtWarehouse: number
    GameID6: string | null
    GameID7: string | null
    GameID8: string | null
    GameID9: string | null
    GameID10: string | null
    MaxCharacter: number
    _count: AccountCharacterCountAggregateOutputType | null
    _avg: AccountCharacterAvgAggregateOutputType | null
    _sum: AccountCharacterSumAggregateOutputType | null
    _min: AccountCharacterMinAggregateOutputType | null
    _max: AccountCharacterMaxAggregateOutputType | null
  }

  type GetAccountCharacterGroupByPayload<T extends AccountCharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountCharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountCharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountCharacterGroupByOutputType[P]>
            : GetScalarType<T[P], AccountCharacterGroupByOutputType[P]>
        }
      >
    >


  export type AccountCharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Number?: boolean
    Id?: boolean
    GameID1?: boolean
    GameID2?: boolean
    GameID3?: boolean
    GameID4?: boolean
    GameID5?: boolean
    GameIDC?: boolean
    MoveCnt?: boolean
    ExtClass?: boolean
    ExtWarehouse?: boolean
    GameID6?: boolean
    GameID7?: boolean
    GameID8?: boolean
    GameID9?: boolean
    GameID10?: boolean
    MaxCharacter?: boolean
  }, ExtArgs["result"]["accountCharacter"]>

  export type AccountCharacterSelectScalar = {
    Number?: boolean
    Id?: boolean
    GameID1?: boolean
    GameID2?: boolean
    GameID3?: boolean
    GameID4?: boolean
    GameID5?: boolean
    GameIDC?: boolean
    MoveCnt?: boolean
    ExtClass?: boolean
    ExtWarehouse?: boolean
    GameID6?: boolean
    GameID7?: boolean
    GameID8?: boolean
    GameID9?: boolean
    GameID10?: boolean
    MaxCharacter?: boolean
  }


  export type $AccountCharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountCharacter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Number: number
      Id: string
      GameID1: string | null
      GameID2: string | null
      GameID3: string | null
      GameID4: string | null
      GameID5: string | null
      GameIDC: string | null
      MoveCnt: number | null
      ExtClass: number
      ExtWarehouse: number
      GameID6: string | null
      GameID7: string | null
      GameID8: string | null
      GameID9: string | null
      GameID10: string | null
      MaxCharacter: number
    }, ExtArgs["result"]["accountCharacter"]>
    composites: {}
  }


  type AccountCharacterGetPayload<S extends boolean | null | undefined | AccountCharacterDefaultArgs> = $Result.GetResult<Prisma.$AccountCharacterPayload, S>

  type AccountCharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountCharacterFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AccountCharacterCountAggregateInputType | true
    }

  export interface AccountCharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountCharacter'], meta: { name: 'AccountCharacter' } }
    /**
     * Find zero or one AccountCharacter that matches the filter.
     * @param {AccountCharacterFindUniqueArgs} args - Arguments to find a AccountCharacter
     * @example
     * // Get one AccountCharacter
     * const accountCharacter = await prisma.accountCharacter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountCharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountCharacterClient<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AccountCharacter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountCharacterFindUniqueOrThrowArgs} args - Arguments to find a AccountCharacter
     * @example
     * // Get one AccountCharacter
     * const accountCharacter = await prisma.accountCharacter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountCharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountCharacterClient<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AccountCharacter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCharacterFindFirstArgs} args - Arguments to find a AccountCharacter
     * @example
     * // Get one AccountCharacter
     * const accountCharacter = await prisma.accountCharacter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountCharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCharacterFindFirstArgs<ExtArgs>>
    ): Prisma__AccountCharacterClient<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AccountCharacter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCharacterFindFirstOrThrowArgs} args - Arguments to find a AccountCharacter
     * @example
     * // Get one AccountCharacter
     * const accountCharacter = await prisma.accountCharacter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountCharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountCharacterClient<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AccountCharacters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountCharacters
     * const accountCharacters = await prisma.accountCharacter.findMany()
     * 
     * // Get first 10 AccountCharacters
     * const accountCharacters = await prisma.accountCharacter.findMany({ take: 10 })
     * 
     * // Only select the `Number`
     * const accountCharacterWithNumberOnly = await prisma.accountCharacter.findMany({ select: { Number: true } })
     * 
    **/
    findMany<T extends AccountCharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AccountCharacter.
     * @param {AccountCharacterCreateArgs} args - Arguments to create a AccountCharacter.
     * @example
     * // Create one AccountCharacter
     * const AccountCharacter = await prisma.accountCharacter.create({
     *   data: {
     *     // ... data to create a AccountCharacter
     *   }
     * })
     * 
    **/
    create<T extends AccountCharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCharacterCreateArgs<ExtArgs>>
    ): Prisma__AccountCharacterClient<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AccountCharacters.
     *     @param {AccountCharacterCreateManyArgs} args - Arguments to create many AccountCharacters.
     *     @example
     *     // Create many AccountCharacters
     *     const accountCharacter = await prisma.accountCharacter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountCharacter.
     * @param {AccountCharacterDeleteArgs} args - Arguments to delete one AccountCharacter.
     * @example
     * // Delete one AccountCharacter
     * const AccountCharacter = await prisma.accountCharacter.delete({
     *   where: {
     *     // ... filter to delete one AccountCharacter
     *   }
     * })
     * 
    **/
    delete<T extends AccountCharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCharacterDeleteArgs<ExtArgs>>
    ): Prisma__AccountCharacterClient<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AccountCharacter.
     * @param {AccountCharacterUpdateArgs} args - Arguments to update one AccountCharacter.
     * @example
     * // Update one AccountCharacter
     * const accountCharacter = await prisma.accountCharacter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountCharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCharacterUpdateArgs<ExtArgs>>
    ): Prisma__AccountCharacterClient<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AccountCharacters.
     * @param {AccountCharacterDeleteManyArgs} args - Arguments to filter AccountCharacters to delete.
     * @example
     * // Delete a few AccountCharacters
     * const { count } = await prisma.accountCharacter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountCharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountCharacters
     * const accountCharacter = await prisma.accountCharacter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountCharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountCharacter.
     * @param {AccountCharacterUpsertArgs} args - Arguments to update or create a AccountCharacter.
     * @example
     * // Update or create a AccountCharacter
     * const accountCharacter = await prisma.accountCharacter.upsert({
     *   create: {
     *     // ... data to create a AccountCharacter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountCharacter we want to update
     *   }
     * })
    **/
    upsert<T extends AccountCharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCharacterUpsertArgs<ExtArgs>>
    ): Prisma__AccountCharacterClient<$Result.GetResult<Prisma.$AccountCharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AccountCharacters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCharacterCountArgs} args - Arguments to filter AccountCharacters to count.
     * @example
     * // Count the number of AccountCharacters
     * const count = await prisma.accountCharacter.count({
     *   where: {
     *     // ... the filter for the AccountCharacters we want to count
     *   }
     * })
    **/
    count<T extends AccountCharacterCountArgs>(
      args?: Subset<T, AccountCharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountCharacterAggregateArgs>(args: Subset<T, AccountCharacterAggregateArgs>): Prisma.PrismaPromise<GetAccountCharacterAggregateType<T>>

    /**
     * Group by AccountCharacter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountCharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountCharacterGroupByArgs['orderBy'] }
        : { orderBy?: AccountCharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountCharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountCharacter model
   */
  readonly fields: AccountCharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountCharacter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountCharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AccountCharacter model
   */ 
  interface AccountCharacterFieldRefs {
    readonly Number: FieldRef<"AccountCharacter", 'Int'>
    readonly Id: FieldRef<"AccountCharacter", 'String'>
    readonly GameID1: FieldRef<"AccountCharacter", 'String'>
    readonly GameID2: FieldRef<"AccountCharacter", 'String'>
    readonly GameID3: FieldRef<"AccountCharacter", 'String'>
    readonly GameID4: FieldRef<"AccountCharacter", 'String'>
    readonly GameID5: FieldRef<"AccountCharacter", 'String'>
    readonly GameIDC: FieldRef<"AccountCharacter", 'String'>
    readonly MoveCnt: FieldRef<"AccountCharacter", 'Int'>
    readonly ExtClass: FieldRef<"AccountCharacter", 'Int'>
    readonly ExtWarehouse: FieldRef<"AccountCharacter", 'Int'>
    readonly GameID6: FieldRef<"AccountCharacter", 'String'>
    readonly GameID7: FieldRef<"AccountCharacter", 'String'>
    readonly GameID8: FieldRef<"AccountCharacter", 'String'>
    readonly GameID9: FieldRef<"AccountCharacter", 'String'>
    readonly GameID10: FieldRef<"AccountCharacter", 'String'>
    readonly MaxCharacter: FieldRef<"AccountCharacter", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * AccountCharacter findUnique
   */
  export type AccountCharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * Filter, which AccountCharacter to fetch.
     */
    where: AccountCharacterWhereUniqueInput
  }


  /**
   * AccountCharacter findUniqueOrThrow
   */
  export type AccountCharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * Filter, which AccountCharacter to fetch.
     */
    where: AccountCharacterWhereUniqueInput
  }


  /**
   * AccountCharacter findFirst
   */
  export type AccountCharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * Filter, which AccountCharacter to fetch.
     */
    where?: AccountCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountCharacters to fetch.
     */
    orderBy?: AccountCharacterOrderByWithRelationInput | AccountCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountCharacters.
     */
    cursor?: AccountCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountCharacters.
     */
    distinct?: AccountCharacterScalarFieldEnum | AccountCharacterScalarFieldEnum[]
  }


  /**
   * AccountCharacter findFirstOrThrow
   */
  export type AccountCharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * Filter, which AccountCharacter to fetch.
     */
    where?: AccountCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountCharacters to fetch.
     */
    orderBy?: AccountCharacterOrderByWithRelationInput | AccountCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountCharacters.
     */
    cursor?: AccountCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountCharacters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountCharacters.
     */
    distinct?: AccountCharacterScalarFieldEnum | AccountCharacterScalarFieldEnum[]
  }


  /**
   * AccountCharacter findMany
   */
  export type AccountCharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * Filter, which AccountCharacters to fetch.
     */
    where?: AccountCharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountCharacters to fetch.
     */
    orderBy?: AccountCharacterOrderByWithRelationInput | AccountCharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountCharacters.
     */
    cursor?: AccountCharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountCharacters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountCharacters.
     */
    skip?: number
    distinct?: AccountCharacterScalarFieldEnum | AccountCharacterScalarFieldEnum[]
  }


  /**
   * AccountCharacter create
   */
  export type AccountCharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * The data needed to create a AccountCharacter.
     */
    data: XOR<AccountCharacterCreateInput, AccountCharacterUncheckedCreateInput>
  }


  /**
   * AccountCharacter createMany
   */
  export type AccountCharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountCharacters.
     */
    data: AccountCharacterCreateManyInput | AccountCharacterCreateManyInput[]
  }


  /**
   * AccountCharacter update
   */
  export type AccountCharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * The data needed to update a AccountCharacter.
     */
    data: XOR<AccountCharacterUpdateInput, AccountCharacterUncheckedUpdateInput>
    /**
     * Choose, which AccountCharacter to update.
     */
    where: AccountCharacterWhereUniqueInput
  }


  /**
   * AccountCharacter updateMany
   */
  export type AccountCharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountCharacters.
     */
    data: XOR<AccountCharacterUpdateManyMutationInput, AccountCharacterUncheckedUpdateManyInput>
    /**
     * Filter which AccountCharacters to update
     */
    where?: AccountCharacterWhereInput
  }


  /**
   * AccountCharacter upsert
   */
  export type AccountCharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * The filter to search for the AccountCharacter to update in case it exists.
     */
    where: AccountCharacterWhereUniqueInput
    /**
     * In case the AccountCharacter found by the `where` argument doesn't exist, create a new AccountCharacter with this data.
     */
    create: XOR<AccountCharacterCreateInput, AccountCharacterUncheckedCreateInput>
    /**
     * In case the AccountCharacter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountCharacterUpdateInput, AccountCharacterUncheckedUpdateInput>
  }


  /**
   * AccountCharacter delete
   */
  export type AccountCharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
    /**
     * Filter which AccountCharacter to delete.
     */
    where: AccountCharacterWhereUniqueInput
  }


  /**
   * AccountCharacter deleteMany
   */
  export type AccountCharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountCharacters to delete
     */
    where?: AccountCharacterWhereInput
  }


  /**
   * AccountCharacter without action
   */
  export type AccountCharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCharacter
     */
    select?: AccountCharacterSelect<ExtArgs> | null
  }



  /**
   * Model CashShopData
   */

  export type AggregateCashShopData = {
    _count: CashShopDataCountAggregateOutputType | null
    _avg: CashShopDataAvgAggregateOutputType | null
    _sum: CashShopDataSumAggregateOutputType | null
    _min: CashShopDataMinAggregateOutputType | null
    _max: CashShopDataMaxAggregateOutputType | null
  }

  export type CashShopDataAvgAggregateOutputType = {
    WCoinC: number | null
    WCoinP: number | null
    GoblinPoint: number | null
  }

  export type CashShopDataSumAggregateOutputType = {
    WCoinC: number | null
    WCoinP: number | null
    GoblinPoint: number | null
  }

  export type CashShopDataMinAggregateOutputType = {
    AccountID: string | null
    WCoinC: number | null
    WCoinP: number | null
    GoblinPoint: number | null
  }

  export type CashShopDataMaxAggregateOutputType = {
    AccountID: string | null
    WCoinC: number | null
    WCoinP: number | null
    GoblinPoint: number | null
  }

  export type CashShopDataCountAggregateOutputType = {
    AccountID: number
    WCoinC: number
    WCoinP: number
    GoblinPoint: number
    _all: number
  }


  export type CashShopDataAvgAggregateInputType = {
    WCoinC?: true
    WCoinP?: true
    GoblinPoint?: true
  }

  export type CashShopDataSumAggregateInputType = {
    WCoinC?: true
    WCoinP?: true
    GoblinPoint?: true
  }

  export type CashShopDataMinAggregateInputType = {
    AccountID?: true
    WCoinC?: true
    WCoinP?: true
    GoblinPoint?: true
  }

  export type CashShopDataMaxAggregateInputType = {
    AccountID?: true
    WCoinC?: true
    WCoinP?: true
    GoblinPoint?: true
  }

  export type CashShopDataCountAggregateInputType = {
    AccountID?: true
    WCoinC?: true
    WCoinP?: true
    GoblinPoint?: true
    _all?: true
  }

  export type CashShopDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashShopData to aggregate.
     */
    where?: CashShopDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopData to fetch.
     */
    orderBy?: CashShopDataOrderByWithRelationInput | CashShopDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashShopDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashShopData
    **/
    _count?: true | CashShopDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashShopDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashShopDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashShopDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashShopDataMaxAggregateInputType
  }

  export type GetCashShopDataAggregateType<T extends CashShopDataAggregateArgs> = {
        [P in keyof T & keyof AggregateCashShopData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashShopData[P]>
      : GetScalarType<T[P], AggregateCashShopData[P]>
  }




  export type CashShopDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashShopDataWhereInput
    orderBy?: CashShopDataOrderByWithAggregationInput | CashShopDataOrderByWithAggregationInput[]
    by: CashShopDataScalarFieldEnum[] | CashShopDataScalarFieldEnum
    having?: CashShopDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashShopDataCountAggregateInputType | true
    _avg?: CashShopDataAvgAggregateInputType
    _sum?: CashShopDataSumAggregateInputType
    _min?: CashShopDataMinAggregateInputType
    _max?: CashShopDataMaxAggregateInputType
  }

  export type CashShopDataGroupByOutputType = {
    AccountID: string
    WCoinC: number | null
    WCoinP: number | null
    GoblinPoint: number | null
    _count: CashShopDataCountAggregateOutputType | null
    _avg: CashShopDataAvgAggregateOutputType | null
    _sum: CashShopDataSumAggregateOutputType | null
    _min: CashShopDataMinAggregateOutputType | null
    _max: CashShopDataMaxAggregateOutputType | null
  }

  type GetCashShopDataGroupByPayload<T extends CashShopDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashShopDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashShopDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashShopDataGroupByOutputType[P]>
            : GetScalarType<T[P], CashShopDataGroupByOutputType[P]>
        }
      >
    >


  export type CashShopDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AccountID?: boolean
    WCoinC?: boolean
    WCoinP?: boolean
    GoblinPoint?: boolean
  }, ExtArgs["result"]["cashShopData"]>

  export type CashShopDataSelectScalar = {
    AccountID?: boolean
    WCoinC?: boolean
    WCoinP?: boolean
    GoblinPoint?: boolean
  }


  export type $CashShopDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashShopData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AccountID: string
      WCoinC: number | null
      WCoinP: number | null
      GoblinPoint: number | null
    }, ExtArgs["result"]["cashShopData"]>
    composites: {}
  }


  type CashShopDataGetPayload<S extends boolean | null | undefined | CashShopDataDefaultArgs> = $Result.GetResult<Prisma.$CashShopDataPayload, S>

  type CashShopDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashShopDataFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CashShopDataCountAggregateInputType | true
    }

  export interface CashShopDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashShopData'], meta: { name: 'CashShopData' } }
    /**
     * Find zero or one CashShopData that matches the filter.
     * @param {CashShopDataFindUniqueArgs} args - Arguments to find a CashShopData
     * @example
     * // Get one CashShopData
     * const cashShopData = await prisma.cashShopData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashShopDataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopDataFindUniqueArgs<ExtArgs>>
    ): Prisma__CashShopDataClient<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CashShopData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CashShopDataFindUniqueOrThrowArgs} args - Arguments to find a CashShopData
     * @example
     * // Get one CashShopData
     * const cashShopData = await prisma.cashShopData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CashShopDataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopDataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CashShopDataClient<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CashShopData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopDataFindFirstArgs} args - Arguments to find a CashShopData
     * @example
     * // Get one CashShopData
     * const cashShopData = await prisma.cashShopData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashShopDataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopDataFindFirstArgs<ExtArgs>>
    ): Prisma__CashShopDataClient<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CashShopData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopDataFindFirstOrThrowArgs} args - Arguments to find a CashShopData
     * @example
     * // Get one CashShopData
     * const cashShopData = await prisma.cashShopData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CashShopDataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopDataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CashShopDataClient<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CashShopData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashShopData
     * const cashShopData = await prisma.cashShopData.findMany()
     * 
     * // Get first 10 CashShopData
     * const cashShopData = await prisma.cashShopData.findMany({ take: 10 })
     * 
     * // Only select the `AccountID`
     * const cashShopDataWithAccountIDOnly = await prisma.cashShopData.findMany({ select: { AccountID: true } })
     * 
    **/
    findMany<T extends CashShopDataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopDataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CashShopData.
     * @param {CashShopDataCreateArgs} args - Arguments to create a CashShopData.
     * @example
     * // Create one CashShopData
     * const CashShopData = await prisma.cashShopData.create({
     *   data: {
     *     // ... data to create a CashShopData
     *   }
     * })
     * 
    **/
    create<T extends CashShopDataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopDataCreateArgs<ExtArgs>>
    ): Prisma__CashShopDataClient<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CashShopData.
     *     @param {CashShopDataCreateManyArgs} args - Arguments to create many CashShopData.
     *     @example
     *     // Create many CashShopData
     *     const cashShopData = await prisma.cashShopData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashShopDataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopDataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CashShopData.
     * @param {CashShopDataDeleteArgs} args - Arguments to delete one CashShopData.
     * @example
     * // Delete one CashShopData
     * const CashShopData = await prisma.cashShopData.delete({
     *   where: {
     *     // ... filter to delete one CashShopData
     *   }
     * })
     * 
    **/
    delete<T extends CashShopDataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopDataDeleteArgs<ExtArgs>>
    ): Prisma__CashShopDataClient<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CashShopData.
     * @param {CashShopDataUpdateArgs} args - Arguments to update one CashShopData.
     * @example
     * // Update one CashShopData
     * const cashShopData = await prisma.cashShopData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashShopDataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopDataUpdateArgs<ExtArgs>>
    ): Prisma__CashShopDataClient<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CashShopData.
     * @param {CashShopDataDeleteManyArgs} args - Arguments to filter CashShopData to delete.
     * @example
     * // Delete a few CashShopData
     * const { count } = await prisma.cashShopData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashShopDataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopDataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashShopData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashShopData
     * const cashShopData = await prisma.cashShopData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashShopDataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopDataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashShopData.
     * @param {CashShopDataUpsertArgs} args - Arguments to update or create a CashShopData.
     * @example
     * // Update or create a CashShopData
     * const cashShopData = await prisma.cashShopData.upsert({
     *   create: {
     *     // ... data to create a CashShopData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashShopData we want to update
     *   }
     * })
    **/
    upsert<T extends CashShopDataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopDataUpsertArgs<ExtArgs>>
    ): Prisma__CashShopDataClient<$Result.GetResult<Prisma.$CashShopDataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CashShopData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopDataCountArgs} args - Arguments to filter CashShopData to count.
     * @example
     * // Count the number of CashShopData
     * const count = await prisma.cashShopData.count({
     *   where: {
     *     // ... the filter for the CashShopData we want to count
     *   }
     * })
    **/
    count<T extends CashShopDataCountArgs>(
      args?: Subset<T, CashShopDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashShopDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashShopData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashShopDataAggregateArgs>(args: Subset<T, CashShopDataAggregateArgs>): Prisma.PrismaPromise<GetCashShopDataAggregateType<T>>

    /**
     * Group by CashShopData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashShopDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashShopDataGroupByArgs['orderBy'] }
        : { orderBy?: CashShopDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashShopDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashShopDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashShopData model
   */
  readonly fields: CashShopDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashShopData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashShopDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CashShopData model
   */ 
  interface CashShopDataFieldRefs {
    readonly AccountID: FieldRef<"CashShopData", 'String'>
    readonly WCoinC: FieldRef<"CashShopData", 'Int'>
    readonly WCoinP: FieldRef<"CashShopData", 'Int'>
    readonly GoblinPoint: FieldRef<"CashShopData", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CashShopData findUnique
   */
  export type CashShopDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * Filter, which CashShopData to fetch.
     */
    where: CashShopDataWhereUniqueInput
  }


  /**
   * CashShopData findUniqueOrThrow
   */
  export type CashShopDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * Filter, which CashShopData to fetch.
     */
    where: CashShopDataWhereUniqueInput
  }


  /**
   * CashShopData findFirst
   */
  export type CashShopDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * Filter, which CashShopData to fetch.
     */
    where?: CashShopDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopData to fetch.
     */
    orderBy?: CashShopDataOrderByWithRelationInput | CashShopDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashShopData.
     */
    cursor?: CashShopDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashShopData.
     */
    distinct?: CashShopDataScalarFieldEnum | CashShopDataScalarFieldEnum[]
  }


  /**
   * CashShopData findFirstOrThrow
   */
  export type CashShopDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * Filter, which CashShopData to fetch.
     */
    where?: CashShopDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopData to fetch.
     */
    orderBy?: CashShopDataOrderByWithRelationInput | CashShopDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashShopData.
     */
    cursor?: CashShopDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashShopData.
     */
    distinct?: CashShopDataScalarFieldEnum | CashShopDataScalarFieldEnum[]
  }


  /**
   * CashShopData findMany
   */
  export type CashShopDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * Filter, which CashShopData to fetch.
     */
    where?: CashShopDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopData to fetch.
     */
    orderBy?: CashShopDataOrderByWithRelationInput | CashShopDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashShopData.
     */
    cursor?: CashShopDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopData.
     */
    skip?: number
    distinct?: CashShopDataScalarFieldEnum | CashShopDataScalarFieldEnum[]
  }


  /**
   * CashShopData create
   */
  export type CashShopDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * The data needed to create a CashShopData.
     */
    data: XOR<CashShopDataCreateInput, CashShopDataUncheckedCreateInput>
  }


  /**
   * CashShopData createMany
   */
  export type CashShopDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashShopData.
     */
    data: CashShopDataCreateManyInput | CashShopDataCreateManyInput[]
  }


  /**
   * CashShopData update
   */
  export type CashShopDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * The data needed to update a CashShopData.
     */
    data: XOR<CashShopDataUpdateInput, CashShopDataUncheckedUpdateInput>
    /**
     * Choose, which CashShopData to update.
     */
    where: CashShopDataWhereUniqueInput
  }


  /**
   * CashShopData updateMany
   */
  export type CashShopDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashShopData.
     */
    data: XOR<CashShopDataUpdateManyMutationInput, CashShopDataUncheckedUpdateManyInput>
    /**
     * Filter which CashShopData to update
     */
    where?: CashShopDataWhereInput
  }


  /**
   * CashShopData upsert
   */
  export type CashShopDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * The filter to search for the CashShopData to update in case it exists.
     */
    where: CashShopDataWhereUniqueInput
    /**
     * In case the CashShopData found by the `where` argument doesn't exist, create a new CashShopData with this data.
     */
    create: XOR<CashShopDataCreateInput, CashShopDataUncheckedCreateInput>
    /**
     * In case the CashShopData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashShopDataUpdateInput, CashShopDataUncheckedUpdateInput>
  }


  /**
   * CashShopData delete
   */
  export type CashShopDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
    /**
     * Filter which CashShopData to delete.
     */
    where: CashShopDataWhereUniqueInput
  }


  /**
   * CashShopData deleteMany
   */
  export type CashShopDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashShopData to delete
     */
    where?: CashShopDataWhereInput
  }


  /**
   * CashShopData without action
   */
  export type CashShopDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopData
     */
    select?: CashShopDataSelect<ExtArgs> | null
  }



  /**
   * Model CashShopInventory
   */

  export type AggregateCashShopInventory = {
    _count: CashShopInventoryCountAggregateOutputType | null
    _avg: CashShopInventoryAvgAggregateOutputType | null
    _sum: CashShopInventorySumAggregateOutputType | null
    _min: CashShopInventoryMinAggregateOutputType | null
    _max: CashShopInventoryMaxAggregateOutputType | null
  }

  export type CashShopInventoryAvgAggregateOutputType = {
    BaseItemCode: number | null
    MainItemCode: number | null
    InventoryType: number | null
    PackageMainIndex: number | null
    ProductBaseIndex: number | null
    ProductMainIndex: number | null
    CoinValue: number | null
    ProductType: number | null
  }

  export type CashShopInventorySumAggregateOutputType = {
    BaseItemCode: number | null
    MainItemCode: number | null
    InventoryType: number | null
    PackageMainIndex: number | null
    ProductBaseIndex: number | null
    ProductMainIndex: number | null
    CoinValue: number | null
    ProductType: number | null
  }

  export type CashShopInventoryMinAggregateOutputType = {
    BaseItemCode: number | null
    MainItemCode: number | null
    AccountID: string | null
    InventoryType: number | null
    PackageMainIndex: number | null
    ProductBaseIndex: number | null
    ProductMainIndex: number | null
    CoinValue: number | null
    ProductType: number | null
    GiftName: string | null
    GiftText: string | null
  }

  export type CashShopInventoryMaxAggregateOutputType = {
    BaseItemCode: number | null
    MainItemCode: number | null
    AccountID: string | null
    InventoryType: number | null
    PackageMainIndex: number | null
    ProductBaseIndex: number | null
    ProductMainIndex: number | null
    CoinValue: number | null
    ProductType: number | null
    GiftName: string | null
    GiftText: string | null
  }

  export type CashShopInventoryCountAggregateOutputType = {
    BaseItemCode: number
    MainItemCode: number
    AccountID: number
    InventoryType: number
    PackageMainIndex: number
    ProductBaseIndex: number
    ProductMainIndex: number
    CoinValue: number
    ProductType: number
    GiftName: number
    GiftText: number
    _all: number
  }


  export type CashShopInventoryAvgAggregateInputType = {
    BaseItemCode?: true
    MainItemCode?: true
    InventoryType?: true
    PackageMainIndex?: true
    ProductBaseIndex?: true
    ProductMainIndex?: true
    CoinValue?: true
    ProductType?: true
  }

  export type CashShopInventorySumAggregateInputType = {
    BaseItemCode?: true
    MainItemCode?: true
    InventoryType?: true
    PackageMainIndex?: true
    ProductBaseIndex?: true
    ProductMainIndex?: true
    CoinValue?: true
    ProductType?: true
  }

  export type CashShopInventoryMinAggregateInputType = {
    BaseItemCode?: true
    MainItemCode?: true
    AccountID?: true
    InventoryType?: true
    PackageMainIndex?: true
    ProductBaseIndex?: true
    ProductMainIndex?: true
    CoinValue?: true
    ProductType?: true
    GiftName?: true
    GiftText?: true
  }

  export type CashShopInventoryMaxAggregateInputType = {
    BaseItemCode?: true
    MainItemCode?: true
    AccountID?: true
    InventoryType?: true
    PackageMainIndex?: true
    ProductBaseIndex?: true
    ProductMainIndex?: true
    CoinValue?: true
    ProductType?: true
    GiftName?: true
    GiftText?: true
  }

  export type CashShopInventoryCountAggregateInputType = {
    BaseItemCode?: true
    MainItemCode?: true
    AccountID?: true
    InventoryType?: true
    PackageMainIndex?: true
    ProductBaseIndex?: true
    ProductMainIndex?: true
    CoinValue?: true
    ProductType?: true
    GiftName?: true
    GiftText?: true
    _all?: true
  }

  export type CashShopInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashShopInventory to aggregate.
     */
    where?: CashShopInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopInventories to fetch.
     */
    orderBy?: CashShopInventoryOrderByWithRelationInput | CashShopInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashShopInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashShopInventories
    **/
    _count?: true | CashShopInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashShopInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashShopInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashShopInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashShopInventoryMaxAggregateInputType
  }

  export type GetCashShopInventoryAggregateType<T extends CashShopInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCashShopInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashShopInventory[P]>
      : GetScalarType<T[P], AggregateCashShopInventory[P]>
  }




  export type CashShopInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashShopInventoryWhereInput
    orderBy?: CashShopInventoryOrderByWithAggregationInput | CashShopInventoryOrderByWithAggregationInput[]
    by: CashShopInventoryScalarFieldEnum[] | CashShopInventoryScalarFieldEnum
    having?: CashShopInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashShopInventoryCountAggregateInputType | true
    _avg?: CashShopInventoryAvgAggregateInputType
    _sum?: CashShopInventorySumAggregateInputType
    _min?: CashShopInventoryMinAggregateInputType
    _max?: CashShopInventoryMaxAggregateInputType
  }

  export type CashShopInventoryGroupByOutputType = {
    BaseItemCode: number
    MainItemCode: number | null
    AccountID: string | null
    InventoryType: number | null
    PackageMainIndex: number | null
    ProductBaseIndex: number | null
    ProductMainIndex: number | null
    CoinValue: number | null
    ProductType: number | null
    GiftName: string | null
    GiftText: string | null
    _count: CashShopInventoryCountAggregateOutputType | null
    _avg: CashShopInventoryAvgAggregateOutputType | null
    _sum: CashShopInventorySumAggregateOutputType | null
    _min: CashShopInventoryMinAggregateOutputType | null
    _max: CashShopInventoryMaxAggregateOutputType | null
  }

  type GetCashShopInventoryGroupByPayload<T extends CashShopInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashShopInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashShopInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashShopInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], CashShopInventoryGroupByOutputType[P]>
        }
      >
    >


  export type CashShopInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BaseItemCode?: boolean
    MainItemCode?: boolean
    AccountID?: boolean
    InventoryType?: boolean
    PackageMainIndex?: boolean
    ProductBaseIndex?: boolean
    ProductMainIndex?: boolean
    CoinValue?: boolean
    ProductType?: boolean
    GiftName?: boolean
    GiftText?: boolean
  }, ExtArgs["result"]["cashShopInventory"]>

  export type CashShopInventorySelectScalar = {
    BaseItemCode?: boolean
    MainItemCode?: boolean
    AccountID?: boolean
    InventoryType?: boolean
    PackageMainIndex?: boolean
    ProductBaseIndex?: boolean
    ProductMainIndex?: boolean
    CoinValue?: boolean
    ProductType?: boolean
    GiftName?: boolean
    GiftText?: boolean
  }


  export type $CashShopInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashShopInventory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      BaseItemCode: number
      MainItemCode: number | null
      AccountID: string | null
      InventoryType: number | null
      PackageMainIndex: number | null
      ProductBaseIndex: number | null
      ProductMainIndex: number | null
      CoinValue: number | null
      ProductType: number | null
      GiftName: string | null
      GiftText: string | null
    }, ExtArgs["result"]["cashShopInventory"]>
    composites: {}
  }


  type CashShopInventoryGetPayload<S extends boolean | null | undefined | CashShopInventoryDefaultArgs> = $Result.GetResult<Prisma.$CashShopInventoryPayload, S>

  type CashShopInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashShopInventoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CashShopInventoryCountAggregateInputType | true
    }

  export interface CashShopInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashShopInventory'], meta: { name: 'CashShopInventory' } }
    /**
     * Find zero or one CashShopInventory that matches the filter.
     * @param {CashShopInventoryFindUniqueArgs} args - Arguments to find a CashShopInventory
     * @example
     * // Get one CashShopInventory
     * const cashShopInventory = await prisma.cashShopInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashShopInventoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopInventoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CashShopInventoryClient<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CashShopInventory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CashShopInventoryFindUniqueOrThrowArgs} args - Arguments to find a CashShopInventory
     * @example
     * // Get one CashShopInventory
     * const cashShopInventory = await prisma.cashShopInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CashShopInventoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopInventoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CashShopInventoryClient<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CashShopInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopInventoryFindFirstArgs} args - Arguments to find a CashShopInventory
     * @example
     * // Get one CashShopInventory
     * const cashShopInventory = await prisma.cashShopInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashShopInventoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopInventoryFindFirstArgs<ExtArgs>>
    ): Prisma__CashShopInventoryClient<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CashShopInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopInventoryFindFirstOrThrowArgs} args - Arguments to find a CashShopInventory
     * @example
     * // Get one CashShopInventory
     * const cashShopInventory = await prisma.cashShopInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CashShopInventoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopInventoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CashShopInventoryClient<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CashShopInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopInventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashShopInventories
     * const cashShopInventories = await prisma.cashShopInventory.findMany()
     * 
     * // Get first 10 CashShopInventories
     * const cashShopInventories = await prisma.cashShopInventory.findMany({ take: 10 })
     * 
     * // Only select the `BaseItemCode`
     * const cashShopInventoryWithBaseItemCodeOnly = await prisma.cashShopInventory.findMany({ select: { BaseItemCode: true } })
     * 
    **/
    findMany<T extends CashShopInventoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopInventoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CashShopInventory.
     * @param {CashShopInventoryCreateArgs} args - Arguments to create a CashShopInventory.
     * @example
     * // Create one CashShopInventory
     * const CashShopInventory = await prisma.cashShopInventory.create({
     *   data: {
     *     // ... data to create a CashShopInventory
     *   }
     * })
     * 
    **/
    create<T extends CashShopInventoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopInventoryCreateArgs<ExtArgs>>
    ): Prisma__CashShopInventoryClient<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CashShopInventories.
     *     @param {CashShopInventoryCreateManyArgs} args - Arguments to create many CashShopInventories.
     *     @example
     *     // Create many CashShopInventories
     *     const cashShopInventory = await prisma.cashShopInventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashShopInventoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopInventoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CashShopInventory.
     * @param {CashShopInventoryDeleteArgs} args - Arguments to delete one CashShopInventory.
     * @example
     * // Delete one CashShopInventory
     * const CashShopInventory = await prisma.cashShopInventory.delete({
     *   where: {
     *     // ... filter to delete one CashShopInventory
     *   }
     * })
     * 
    **/
    delete<T extends CashShopInventoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopInventoryDeleteArgs<ExtArgs>>
    ): Prisma__CashShopInventoryClient<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CashShopInventory.
     * @param {CashShopInventoryUpdateArgs} args - Arguments to update one CashShopInventory.
     * @example
     * // Update one CashShopInventory
     * const cashShopInventory = await prisma.cashShopInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashShopInventoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopInventoryUpdateArgs<ExtArgs>>
    ): Prisma__CashShopInventoryClient<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CashShopInventories.
     * @param {CashShopInventoryDeleteManyArgs} args - Arguments to filter CashShopInventories to delete.
     * @example
     * // Delete a few CashShopInventories
     * const { count } = await prisma.cashShopInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashShopInventoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopInventoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashShopInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashShopInventories
     * const cashShopInventory = await prisma.cashShopInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashShopInventoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopInventoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashShopInventory.
     * @param {CashShopInventoryUpsertArgs} args - Arguments to update or create a CashShopInventory.
     * @example
     * // Update or create a CashShopInventory
     * const cashShopInventory = await prisma.cashShopInventory.upsert({
     *   create: {
     *     // ... data to create a CashShopInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashShopInventory we want to update
     *   }
     * })
    **/
    upsert<T extends CashShopInventoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopInventoryUpsertArgs<ExtArgs>>
    ): Prisma__CashShopInventoryClient<$Result.GetResult<Prisma.$CashShopInventoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CashShopInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopInventoryCountArgs} args - Arguments to filter CashShopInventories to count.
     * @example
     * // Count the number of CashShopInventories
     * const count = await prisma.cashShopInventory.count({
     *   where: {
     *     // ... the filter for the CashShopInventories we want to count
     *   }
     * })
    **/
    count<T extends CashShopInventoryCountArgs>(
      args?: Subset<T, CashShopInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashShopInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashShopInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashShopInventoryAggregateArgs>(args: Subset<T, CashShopInventoryAggregateArgs>): Prisma.PrismaPromise<GetCashShopInventoryAggregateType<T>>

    /**
     * Group by CashShopInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashShopInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashShopInventoryGroupByArgs['orderBy'] }
        : { orderBy?: CashShopInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashShopInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashShopInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashShopInventory model
   */
  readonly fields: CashShopInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashShopInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashShopInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CashShopInventory model
   */ 
  interface CashShopInventoryFieldRefs {
    readonly BaseItemCode: FieldRef<"CashShopInventory", 'Int'>
    readonly MainItemCode: FieldRef<"CashShopInventory", 'Int'>
    readonly AccountID: FieldRef<"CashShopInventory", 'String'>
    readonly InventoryType: FieldRef<"CashShopInventory", 'Int'>
    readonly PackageMainIndex: FieldRef<"CashShopInventory", 'Int'>
    readonly ProductBaseIndex: FieldRef<"CashShopInventory", 'Int'>
    readonly ProductMainIndex: FieldRef<"CashShopInventory", 'Int'>
    readonly CoinValue: FieldRef<"CashShopInventory", 'Float'>
    readonly ProductType: FieldRef<"CashShopInventory", 'Int'>
    readonly GiftName: FieldRef<"CashShopInventory", 'String'>
    readonly GiftText: FieldRef<"CashShopInventory", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CashShopInventory findUnique
   */
  export type CashShopInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * Filter, which CashShopInventory to fetch.
     */
    where: CashShopInventoryWhereUniqueInput
  }


  /**
   * CashShopInventory findUniqueOrThrow
   */
  export type CashShopInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * Filter, which CashShopInventory to fetch.
     */
    where: CashShopInventoryWhereUniqueInput
  }


  /**
   * CashShopInventory findFirst
   */
  export type CashShopInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * Filter, which CashShopInventory to fetch.
     */
    where?: CashShopInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopInventories to fetch.
     */
    orderBy?: CashShopInventoryOrderByWithRelationInput | CashShopInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashShopInventories.
     */
    cursor?: CashShopInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashShopInventories.
     */
    distinct?: CashShopInventoryScalarFieldEnum | CashShopInventoryScalarFieldEnum[]
  }


  /**
   * CashShopInventory findFirstOrThrow
   */
  export type CashShopInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * Filter, which CashShopInventory to fetch.
     */
    where?: CashShopInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopInventories to fetch.
     */
    orderBy?: CashShopInventoryOrderByWithRelationInput | CashShopInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashShopInventories.
     */
    cursor?: CashShopInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashShopInventories.
     */
    distinct?: CashShopInventoryScalarFieldEnum | CashShopInventoryScalarFieldEnum[]
  }


  /**
   * CashShopInventory findMany
   */
  export type CashShopInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * Filter, which CashShopInventories to fetch.
     */
    where?: CashShopInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopInventories to fetch.
     */
    orderBy?: CashShopInventoryOrderByWithRelationInput | CashShopInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashShopInventories.
     */
    cursor?: CashShopInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopInventories.
     */
    skip?: number
    distinct?: CashShopInventoryScalarFieldEnum | CashShopInventoryScalarFieldEnum[]
  }


  /**
   * CashShopInventory create
   */
  export type CashShopInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * The data needed to create a CashShopInventory.
     */
    data?: XOR<CashShopInventoryCreateInput, CashShopInventoryUncheckedCreateInput>
  }


  /**
   * CashShopInventory createMany
   */
  export type CashShopInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashShopInventories.
     */
    data: CashShopInventoryCreateManyInput | CashShopInventoryCreateManyInput[]
  }


  /**
   * CashShopInventory update
   */
  export type CashShopInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * The data needed to update a CashShopInventory.
     */
    data: XOR<CashShopInventoryUpdateInput, CashShopInventoryUncheckedUpdateInput>
    /**
     * Choose, which CashShopInventory to update.
     */
    where: CashShopInventoryWhereUniqueInput
  }


  /**
   * CashShopInventory updateMany
   */
  export type CashShopInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashShopInventories.
     */
    data: XOR<CashShopInventoryUpdateManyMutationInput, CashShopInventoryUncheckedUpdateManyInput>
    /**
     * Filter which CashShopInventories to update
     */
    where?: CashShopInventoryWhereInput
  }


  /**
   * CashShopInventory upsert
   */
  export type CashShopInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * The filter to search for the CashShopInventory to update in case it exists.
     */
    where: CashShopInventoryWhereUniqueInput
    /**
     * In case the CashShopInventory found by the `where` argument doesn't exist, create a new CashShopInventory with this data.
     */
    create: XOR<CashShopInventoryCreateInput, CashShopInventoryUncheckedCreateInput>
    /**
     * In case the CashShopInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashShopInventoryUpdateInput, CashShopInventoryUncheckedUpdateInput>
  }


  /**
   * CashShopInventory delete
   */
  export type CashShopInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
    /**
     * Filter which CashShopInventory to delete.
     */
    where: CashShopInventoryWhereUniqueInput
  }


  /**
   * CashShopInventory deleteMany
   */
  export type CashShopInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashShopInventories to delete
     */
    where?: CashShopInventoryWhereInput
  }


  /**
   * CashShopInventory without action
   */
  export type CashShopInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopInventory
     */
    select?: CashShopInventorySelect<ExtArgs> | null
  }



  /**
   * Model CashShopPeriodicItem
   */

  export type AggregateCashShopPeriodicItem = {
    _count: CashShopPeriodicItemCountAggregateOutputType | null
    _avg: CashShopPeriodicItemAvgAggregateOutputType | null
    _sum: CashShopPeriodicItemSumAggregateOutputType | null
    _min: CashShopPeriodicItemMinAggregateOutputType | null
    _max: CashShopPeriodicItemMaxAggregateOutputType | null
  }

  export type CashShopPeriodicItemAvgAggregateOutputType = {
    ItemSerial: number | null
    Time: number | null
  }

  export type CashShopPeriodicItemSumAggregateOutputType = {
    ItemSerial: number | null
    Time: number | null
  }

  export type CashShopPeriodicItemMinAggregateOutputType = {
    ItemSerial: number | null
    Time: number | null
  }

  export type CashShopPeriodicItemMaxAggregateOutputType = {
    ItemSerial: number | null
    Time: number | null
  }

  export type CashShopPeriodicItemCountAggregateOutputType = {
    ItemSerial: number
    Time: number
    _all: number
  }


  export type CashShopPeriodicItemAvgAggregateInputType = {
    ItemSerial?: true
    Time?: true
  }

  export type CashShopPeriodicItemSumAggregateInputType = {
    ItemSerial?: true
    Time?: true
  }

  export type CashShopPeriodicItemMinAggregateInputType = {
    ItemSerial?: true
    Time?: true
  }

  export type CashShopPeriodicItemMaxAggregateInputType = {
    ItemSerial?: true
    Time?: true
  }

  export type CashShopPeriodicItemCountAggregateInputType = {
    ItemSerial?: true
    Time?: true
    _all?: true
  }

  export type CashShopPeriodicItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashShopPeriodicItem to aggregate.
     */
    where?: CashShopPeriodicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopPeriodicItems to fetch.
     */
    orderBy?: CashShopPeriodicItemOrderByWithRelationInput | CashShopPeriodicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashShopPeriodicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopPeriodicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopPeriodicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashShopPeriodicItems
    **/
    _count?: true | CashShopPeriodicItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashShopPeriodicItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashShopPeriodicItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashShopPeriodicItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashShopPeriodicItemMaxAggregateInputType
  }

  export type GetCashShopPeriodicItemAggregateType<T extends CashShopPeriodicItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCashShopPeriodicItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashShopPeriodicItem[P]>
      : GetScalarType<T[P], AggregateCashShopPeriodicItem[P]>
  }




  export type CashShopPeriodicItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashShopPeriodicItemWhereInput
    orderBy?: CashShopPeriodicItemOrderByWithAggregationInput | CashShopPeriodicItemOrderByWithAggregationInput[]
    by: CashShopPeriodicItemScalarFieldEnum[] | CashShopPeriodicItemScalarFieldEnum
    having?: CashShopPeriodicItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashShopPeriodicItemCountAggregateInputType | true
    _avg?: CashShopPeriodicItemAvgAggregateInputType
    _sum?: CashShopPeriodicItemSumAggregateInputType
    _min?: CashShopPeriodicItemMinAggregateInputType
    _max?: CashShopPeriodicItemMaxAggregateInputType
  }

  export type CashShopPeriodicItemGroupByOutputType = {
    ItemSerial: number
    Time: number | null
    _count: CashShopPeriodicItemCountAggregateOutputType | null
    _avg: CashShopPeriodicItemAvgAggregateOutputType | null
    _sum: CashShopPeriodicItemSumAggregateOutputType | null
    _min: CashShopPeriodicItemMinAggregateOutputType | null
    _max: CashShopPeriodicItemMaxAggregateOutputType | null
  }

  type GetCashShopPeriodicItemGroupByPayload<T extends CashShopPeriodicItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashShopPeriodicItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashShopPeriodicItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashShopPeriodicItemGroupByOutputType[P]>
            : GetScalarType<T[P], CashShopPeriodicItemGroupByOutputType[P]>
        }
      >
    >


  export type CashShopPeriodicItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ItemSerial?: boolean
    Time?: boolean
  }, ExtArgs["result"]["cashShopPeriodicItem"]>

  export type CashShopPeriodicItemSelectScalar = {
    ItemSerial?: boolean
    Time?: boolean
  }


  export type $CashShopPeriodicItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashShopPeriodicItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ItemSerial: number
      Time: number | null
    }, ExtArgs["result"]["cashShopPeriodicItem"]>
    composites: {}
  }


  type CashShopPeriodicItemGetPayload<S extends boolean | null | undefined | CashShopPeriodicItemDefaultArgs> = $Result.GetResult<Prisma.$CashShopPeriodicItemPayload, S>

  type CashShopPeriodicItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashShopPeriodicItemFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CashShopPeriodicItemCountAggregateInputType | true
    }

  export interface CashShopPeriodicItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashShopPeriodicItem'], meta: { name: 'CashShopPeriodicItem' } }
    /**
     * Find zero or one CashShopPeriodicItem that matches the filter.
     * @param {CashShopPeriodicItemFindUniqueArgs} args - Arguments to find a CashShopPeriodicItem
     * @example
     * // Get one CashShopPeriodicItem
     * const cashShopPeriodicItem = await prisma.cashShopPeriodicItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CashShopPeriodicItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopPeriodicItemFindUniqueArgs<ExtArgs>>
    ): Prisma__CashShopPeriodicItemClient<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CashShopPeriodicItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CashShopPeriodicItemFindUniqueOrThrowArgs} args - Arguments to find a CashShopPeriodicItem
     * @example
     * // Get one CashShopPeriodicItem
     * const cashShopPeriodicItem = await prisma.cashShopPeriodicItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CashShopPeriodicItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopPeriodicItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CashShopPeriodicItemClient<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CashShopPeriodicItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopPeriodicItemFindFirstArgs} args - Arguments to find a CashShopPeriodicItem
     * @example
     * // Get one CashShopPeriodicItem
     * const cashShopPeriodicItem = await prisma.cashShopPeriodicItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CashShopPeriodicItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopPeriodicItemFindFirstArgs<ExtArgs>>
    ): Prisma__CashShopPeriodicItemClient<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CashShopPeriodicItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopPeriodicItemFindFirstOrThrowArgs} args - Arguments to find a CashShopPeriodicItem
     * @example
     * // Get one CashShopPeriodicItem
     * const cashShopPeriodicItem = await prisma.cashShopPeriodicItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CashShopPeriodicItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopPeriodicItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CashShopPeriodicItemClient<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CashShopPeriodicItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopPeriodicItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashShopPeriodicItems
     * const cashShopPeriodicItems = await prisma.cashShopPeriodicItem.findMany()
     * 
     * // Get first 10 CashShopPeriodicItems
     * const cashShopPeriodicItems = await prisma.cashShopPeriodicItem.findMany({ take: 10 })
     * 
     * // Only select the `ItemSerial`
     * const cashShopPeriodicItemWithItemSerialOnly = await prisma.cashShopPeriodicItem.findMany({ select: { ItemSerial: true } })
     * 
    **/
    findMany<T extends CashShopPeriodicItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopPeriodicItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CashShopPeriodicItem.
     * @param {CashShopPeriodicItemCreateArgs} args - Arguments to create a CashShopPeriodicItem.
     * @example
     * // Create one CashShopPeriodicItem
     * const CashShopPeriodicItem = await prisma.cashShopPeriodicItem.create({
     *   data: {
     *     // ... data to create a CashShopPeriodicItem
     *   }
     * })
     * 
    **/
    create<T extends CashShopPeriodicItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopPeriodicItemCreateArgs<ExtArgs>>
    ): Prisma__CashShopPeriodicItemClient<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CashShopPeriodicItems.
     *     @param {CashShopPeriodicItemCreateManyArgs} args - Arguments to create many CashShopPeriodicItems.
     *     @example
     *     // Create many CashShopPeriodicItems
     *     const cashShopPeriodicItem = await prisma.cashShopPeriodicItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CashShopPeriodicItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopPeriodicItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CashShopPeriodicItem.
     * @param {CashShopPeriodicItemDeleteArgs} args - Arguments to delete one CashShopPeriodicItem.
     * @example
     * // Delete one CashShopPeriodicItem
     * const CashShopPeriodicItem = await prisma.cashShopPeriodicItem.delete({
     *   where: {
     *     // ... filter to delete one CashShopPeriodicItem
     *   }
     * })
     * 
    **/
    delete<T extends CashShopPeriodicItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopPeriodicItemDeleteArgs<ExtArgs>>
    ): Prisma__CashShopPeriodicItemClient<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CashShopPeriodicItem.
     * @param {CashShopPeriodicItemUpdateArgs} args - Arguments to update one CashShopPeriodicItem.
     * @example
     * // Update one CashShopPeriodicItem
     * const cashShopPeriodicItem = await prisma.cashShopPeriodicItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CashShopPeriodicItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopPeriodicItemUpdateArgs<ExtArgs>>
    ): Prisma__CashShopPeriodicItemClient<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CashShopPeriodicItems.
     * @param {CashShopPeriodicItemDeleteManyArgs} args - Arguments to filter CashShopPeriodicItems to delete.
     * @example
     * // Delete a few CashShopPeriodicItems
     * const { count } = await prisma.cashShopPeriodicItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CashShopPeriodicItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CashShopPeriodicItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashShopPeriodicItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopPeriodicItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashShopPeriodicItems
     * const cashShopPeriodicItem = await prisma.cashShopPeriodicItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CashShopPeriodicItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopPeriodicItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashShopPeriodicItem.
     * @param {CashShopPeriodicItemUpsertArgs} args - Arguments to update or create a CashShopPeriodicItem.
     * @example
     * // Update or create a CashShopPeriodicItem
     * const cashShopPeriodicItem = await prisma.cashShopPeriodicItem.upsert({
     *   create: {
     *     // ... data to create a CashShopPeriodicItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashShopPeriodicItem we want to update
     *   }
     * })
    **/
    upsert<T extends CashShopPeriodicItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CashShopPeriodicItemUpsertArgs<ExtArgs>>
    ): Prisma__CashShopPeriodicItemClient<$Result.GetResult<Prisma.$CashShopPeriodicItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CashShopPeriodicItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopPeriodicItemCountArgs} args - Arguments to filter CashShopPeriodicItems to count.
     * @example
     * // Count the number of CashShopPeriodicItems
     * const count = await prisma.cashShopPeriodicItem.count({
     *   where: {
     *     // ... the filter for the CashShopPeriodicItems we want to count
     *   }
     * })
    **/
    count<T extends CashShopPeriodicItemCountArgs>(
      args?: Subset<T, CashShopPeriodicItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashShopPeriodicItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashShopPeriodicItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopPeriodicItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashShopPeriodicItemAggregateArgs>(args: Subset<T, CashShopPeriodicItemAggregateArgs>): Prisma.PrismaPromise<GetCashShopPeriodicItemAggregateType<T>>

    /**
     * Group by CashShopPeriodicItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashShopPeriodicItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashShopPeriodicItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashShopPeriodicItemGroupByArgs['orderBy'] }
        : { orderBy?: CashShopPeriodicItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashShopPeriodicItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashShopPeriodicItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashShopPeriodicItem model
   */
  readonly fields: CashShopPeriodicItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashShopPeriodicItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashShopPeriodicItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CashShopPeriodicItem model
   */ 
  interface CashShopPeriodicItemFieldRefs {
    readonly ItemSerial: FieldRef<"CashShopPeriodicItem", 'Int'>
    readonly Time: FieldRef<"CashShopPeriodicItem", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CashShopPeriodicItem findUnique
   */
  export type CashShopPeriodicItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * Filter, which CashShopPeriodicItem to fetch.
     */
    where: CashShopPeriodicItemWhereUniqueInput
  }


  /**
   * CashShopPeriodicItem findUniqueOrThrow
   */
  export type CashShopPeriodicItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * Filter, which CashShopPeriodicItem to fetch.
     */
    where: CashShopPeriodicItemWhereUniqueInput
  }


  /**
   * CashShopPeriodicItem findFirst
   */
  export type CashShopPeriodicItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * Filter, which CashShopPeriodicItem to fetch.
     */
    where?: CashShopPeriodicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopPeriodicItems to fetch.
     */
    orderBy?: CashShopPeriodicItemOrderByWithRelationInput | CashShopPeriodicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashShopPeriodicItems.
     */
    cursor?: CashShopPeriodicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopPeriodicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopPeriodicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashShopPeriodicItems.
     */
    distinct?: CashShopPeriodicItemScalarFieldEnum | CashShopPeriodicItemScalarFieldEnum[]
  }


  /**
   * CashShopPeriodicItem findFirstOrThrow
   */
  export type CashShopPeriodicItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * Filter, which CashShopPeriodicItem to fetch.
     */
    where?: CashShopPeriodicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopPeriodicItems to fetch.
     */
    orderBy?: CashShopPeriodicItemOrderByWithRelationInput | CashShopPeriodicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashShopPeriodicItems.
     */
    cursor?: CashShopPeriodicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopPeriodicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopPeriodicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashShopPeriodicItems.
     */
    distinct?: CashShopPeriodicItemScalarFieldEnum | CashShopPeriodicItemScalarFieldEnum[]
  }


  /**
   * CashShopPeriodicItem findMany
   */
  export type CashShopPeriodicItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * Filter, which CashShopPeriodicItems to fetch.
     */
    where?: CashShopPeriodicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashShopPeriodicItems to fetch.
     */
    orderBy?: CashShopPeriodicItemOrderByWithRelationInput | CashShopPeriodicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashShopPeriodicItems.
     */
    cursor?: CashShopPeriodicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashShopPeriodicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashShopPeriodicItems.
     */
    skip?: number
    distinct?: CashShopPeriodicItemScalarFieldEnum | CashShopPeriodicItemScalarFieldEnum[]
  }


  /**
   * CashShopPeriodicItem create
   */
  export type CashShopPeriodicItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * The data needed to create a CashShopPeriodicItem.
     */
    data: XOR<CashShopPeriodicItemCreateInput, CashShopPeriodicItemUncheckedCreateInput>
  }


  /**
   * CashShopPeriodicItem createMany
   */
  export type CashShopPeriodicItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashShopPeriodicItems.
     */
    data: CashShopPeriodicItemCreateManyInput | CashShopPeriodicItemCreateManyInput[]
  }


  /**
   * CashShopPeriodicItem update
   */
  export type CashShopPeriodicItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * The data needed to update a CashShopPeriodicItem.
     */
    data: XOR<CashShopPeriodicItemUpdateInput, CashShopPeriodicItemUncheckedUpdateInput>
    /**
     * Choose, which CashShopPeriodicItem to update.
     */
    where: CashShopPeriodicItemWhereUniqueInput
  }


  /**
   * CashShopPeriodicItem updateMany
   */
  export type CashShopPeriodicItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashShopPeriodicItems.
     */
    data: XOR<CashShopPeriodicItemUpdateManyMutationInput, CashShopPeriodicItemUncheckedUpdateManyInput>
    /**
     * Filter which CashShopPeriodicItems to update
     */
    where?: CashShopPeriodicItemWhereInput
  }


  /**
   * CashShopPeriodicItem upsert
   */
  export type CashShopPeriodicItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * The filter to search for the CashShopPeriodicItem to update in case it exists.
     */
    where: CashShopPeriodicItemWhereUniqueInput
    /**
     * In case the CashShopPeriodicItem found by the `where` argument doesn't exist, create a new CashShopPeriodicItem with this data.
     */
    create: XOR<CashShopPeriodicItemCreateInput, CashShopPeriodicItemUncheckedCreateInput>
    /**
     * In case the CashShopPeriodicItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashShopPeriodicItemUpdateInput, CashShopPeriodicItemUncheckedUpdateInput>
  }


  /**
   * CashShopPeriodicItem delete
   */
  export type CashShopPeriodicItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
    /**
     * Filter which CashShopPeriodicItem to delete.
     */
    where: CashShopPeriodicItemWhereUniqueInput
  }


  /**
   * CashShopPeriodicItem deleteMany
   */
  export type CashShopPeriodicItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashShopPeriodicItems to delete
     */
    where?: CashShopPeriodicItemWhereInput
  }


  /**
   * CashShopPeriodicItem without action
   */
  export type CashShopPeriodicItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashShopPeriodicItem
     */
    select?: CashShopPeriodicItemSelect<ExtArgs> | null
  }



  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    cLevel: number | null
    LevelUpPoint: number | null
    Class: number | null
    Experience: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Money: number | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    BP: number | null
    MaxBP: number | null
    Shield: number | null
    MaxShield: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    MapDir: number | null
    PkCount: number | null
    PkLevel: number | null
    PkTime: number | null
    CtlCode: number | null
    DbVersion: number | null
    ChatLimitTime: number | null
    FruitPoint: number | null
    FruitAddPoint: number | null
    FruitSubPoint: number | null
    ResetCount: number | null
    MasterResetCount: number | null
    ExtInventory: number | null
    Resets: number | null
    ResetsDay: number | null
    ResetsWeek: number | null
    ResetsMonth: number | null
    MResets: number | null
    MResetsDay: number | null
    MResetsWeek: number | null
    MResetsMonth: number | null
    PKTotal: number | null
    PKDay: number | null
    PKWeek: number | null
    PKMonth: number | null
    HeroTotal: number | null
    HeroDay: number | null
    HeroWeek: number | null
    HeroMonth: number | null
    tradewins: number | null
    matamata: number | null
    duel_total: number | null
    duel_semanal: number | null
    duel_mensal: number | null
  }

  export type CharacterSumAggregateOutputType = {
    cLevel: number | null
    LevelUpPoint: number | null
    Class: number | null
    Experience: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Money: number | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    BP: number | null
    MaxBP: number | null
    Shield: number | null
    MaxShield: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    MapDir: number | null
    PkCount: number | null
    PkLevel: number | null
    PkTime: number | null
    CtlCode: number | null
    DbVersion: number | null
    ChatLimitTime: number | null
    FruitPoint: number | null
    FruitAddPoint: number | null
    FruitSubPoint: number | null
    ResetCount: number | null
    MasterResetCount: number | null
    ExtInventory: number | null
    Resets: number | null
    ResetsDay: number | null
    ResetsWeek: number | null
    ResetsMonth: number | null
    MResets: number | null
    MResetsDay: number | null
    MResetsWeek: number | null
    MResetsMonth: number | null
    PKTotal: number | null
    PKDay: number | null
    PKWeek: number | null
    PKMonth: number | null
    HeroTotal: number | null
    HeroDay: number | null
    HeroWeek: number | null
    HeroMonth: number | null
    tradewins: number | null
    matamata: number | null
    duel_total: number | null
    duel_semanal: number | null
    duel_mensal: number | null
  }

  export type CharacterMinAggregateOutputType = {
    AccountID: string | null
    Name: string | null
    cLevel: number | null
    LevelUpPoint: number | null
    Class: number | null
    Experience: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Inventory: Buffer | null
    MagicList: Buffer | null
    Money: number | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    BP: number | null
    MaxBP: number | null
    Shield: number | null
    MaxShield: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    MapDir: number | null
    PkCount: number | null
    PkLevel: number | null
    PkTime: number | null
    MDate: Date | null
    LDate: Date | null
    CtlCode: number | null
    DbVersion: number | null
    Quest: Buffer | null
    ChatLimitTime: number | null
    FruitPoint: number | null
    EffectList: Buffer | null
    FruitAddPoint: number | null
    FruitSubPoint: number | null
    ResetCount: number | null
    MasterResetCount: number | null
    ExtInventory: number | null
    Resets: number | null
    ResetsDay: number | null
    ResetsWeek: number | null
    ResetsMonth: number | null
    MResets: number | null
    MResetsDay: number | null
    MResetsWeek: number | null
    MResetsMonth: number | null
    PKTotal: number | null
    PKDay: number | null
    PKWeek: number | null
    PKMonth: number | null
    HeroTotal: number | null
    HeroDay: number | null
    HeroWeek: number | null
    HeroMonth: number | null
    tradewins: number | null
    matamata: number | null
    duel_total: number | null
    duel_semanal: number | null
    duel_mensal: number | null
  }

  export type CharacterMaxAggregateOutputType = {
    AccountID: string | null
    Name: string | null
    cLevel: number | null
    LevelUpPoint: number | null
    Class: number | null
    Experience: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Inventory: Buffer | null
    MagicList: Buffer | null
    Money: number | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    BP: number | null
    MaxBP: number | null
    Shield: number | null
    MaxShield: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    MapDir: number | null
    PkCount: number | null
    PkLevel: number | null
    PkTime: number | null
    MDate: Date | null
    LDate: Date | null
    CtlCode: number | null
    DbVersion: number | null
    Quest: Buffer | null
    ChatLimitTime: number | null
    FruitPoint: number | null
    EffectList: Buffer | null
    FruitAddPoint: number | null
    FruitSubPoint: number | null
    ResetCount: number | null
    MasterResetCount: number | null
    ExtInventory: number | null
    Resets: number | null
    ResetsDay: number | null
    ResetsWeek: number | null
    ResetsMonth: number | null
    MResets: number | null
    MResetsDay: number | null
    MResetsWeek: number | null
    MResetsMonth: number | null
    PKTotal: number | null
    PKDay: number | null
    PKWeek: number | null
    PKMonth: number | null
    HeroTotal: number | null
    HeroDay: number | null
    HeroWeek: number | null
    HeroMonth: number | null
    tradewins: number | null
    matamata: number | null
    duel_total: number | null
    duel_semanal: number | null
    duel_mensal: number | null
  }

  export type CharacterCountAggregateOutputType = {
    AccountID: number
    Name: number
    cLevel: number
    LevelUpPoint: number
    Class: number
    Experience: number
    Strength: number
    Dexterity: number
    Vitality: number
    Energy: number
    Leadership: number
    Inventory: number
    MagicList: number
    Money: number
    Life: number
    MaxLife: number
    Mana: number
    MaxMana: number
    BP: number
    MaxBP: number
    Shield: number
    MaxShield: number
    MapNumber: number
    MapPosX: number
    MapPosY: number
    MapDir: number
    PkCount: number
    PkLevel: number
    PkTime: number
    MDate: number
    LDate: number
    CtlCode: number
    DbVersion: number
    Quest: number
    ChatLimitTime: number
    FruitPoint: number
    EffectList: number
    FruitAddPoint: number
    FruitSubPoint: number
    ResetCount: number
    MasterResetCount: number
    ExtInventory: number
    Resets: number
    ResetsDay: number
    ResetsWeek: number
    ResetsMonth: number
    MResets: number
    MResetsDay: number
    MResetsWeek: number
    MResetsMonth: number
    PKTotal: number
    PKDay: number
    PKWeek: number
    PKMonth: number
    HeroTotal: number
    HeroDay: number
    HeroWeek: number
    HeroMonth: number
    tradewins: number
    matamata: number
    duel_total: number
    duel_semanal: number
    duel_mensal: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    cLevel?: true
    LevelUpPoint?: true
    Class?: true
    Experience?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Money?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    BP?: true
    MaxBP?: true
    Shield?: true
    MaxShield?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    MapDir?: true
    PkCount?: true
    PkLevel?: true
    PkTime?: true
    CtlCode?: true
    DbVersion?: true
    ChatLimitTime?: true
    FruitPoint?: true
    FruitAddPoint?: true
    FruitSubPoint?: true
    ResetCount?: true
    MasterResetCount?: true
    ExtInventory?: true
    Resets?: true
    ResetsDay?: true
    ResetsWeek?: true
    ResetsMonth?: true
    MResets?: true
    MResetsDay?: true
    MResetsWeek?: true
    MResetsMonth?: true
    PKTotal?: true
    PKDay?: true
    PKWeek?: true
    PKMonth?: true
    HeroTotal?: true
    HeroDay?: true
    HeroWeek?: true
    HeroMonth?: true
    tradewins?: true
    matamata?: true
    duel_total?: true
    duel_semanal?: true
    duel_mensal?: true
  }

  export type CharacterSumAggregateInputType = {
    cLevel?: true
    LevelUpPoint?: true
    Class?: true
    Experience?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Money?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    BP?: true
    MaxBP?: true
    Shield?: true
    MaxShield?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    MapDir?: true
    PkCount?: true
    PkLevel?: true
    PkTime?: true
    CtlCode?: true
    DbVersion?: true
    ChatLimitTime?: true
    FruitPoint?: true
    FruitAddPoint?: true
    FruitSubPoint?: true
    ResetCount?: true
    MasterResetCount?: true
    ExtInventory?: true
    Resets?: true
    ResetsDay?: true
    ResetsWeek?: true
    ResetsMonth?: true
    MResets?: true
    MResetsDay?: true
    MResetsWeek?: true
    MResetsMonth?: true
    PKTotal?: true
    PKDay?: true
    PKWeek?: true
    PKMonth?: true
    HeroTotal?: true
    HeroDay?: true
    HeroWeek?: true
    HeroMonth?: true
    tradewins?: true
    matamata?: true
    duel_total?: true
    duel_semanal?: true
    duel_mensal?: true
  }

  export type CharacterMinAggregateInputType = {
    AccountID?: true
    Name?: true
    cLevel?: true
    LevelUpPoint?: true
    Class?: true
    Experience?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Inventory?: true
    MagicList?: true
    Money?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    BP?: true
    MaxBP?: true
    Shield?: true
    MaxShield?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    MapDir?: true
    PkCount?: true
    PkLevel?: true
    PkTime?: true
    MDate?: true
    LDate?: true
    CtlCode?: true
    DbVersion?: true
    Quest?: true
    ChatLimitTime?: true
    FruitPoint?: true
    EffectList?: true
    FruitAddPoint?: true
    FruitSubPoint?: true
    ResetCount?: true
    MasterResetCount?: true
    ExtInventory?: true
    Resets?: true
    ResetsDay?: true
    ResetsWeek?: true
    ResetsMonth?: true
    MResets?: true
    MResetsDay?: true
    MResetsWeek?: true
    MResetsMonth?: true
    PKTotal?: true
    PKDay?: true
    PKWeek?: true
    PKMonth?: true
    HeroTotal?: true
    HeroDay?: true
    HeroWeek?: true
    HeroMonth?: true
    tradewins?: true
    matamata?: true
    duel_total?: true
    duel_semanal?: true
    duel_mensal?: true
  }

  export type CharacterMaxAggregateInputType = {
    AccountID?: true
    Name?: true
    cLevel?: true
    LevelUpPoint?: true
    Class?: true
    Experience?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Inventory?: true
    MagicList?: true
    Money?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    BP?: true
    MaxBP?: true
    Shield?: true
    MaxShield?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    MapDir?: true
    PkCount?: true
    PkLevel?: true
    PkTime?: true
    MDate?: true
    LDate?: true
    CtlCode?: true
    DbVersion?: true
    Quest?: true
    ChatLimitTime?: true
    FruitPoint?: true
    EffectList?: true
    FruitAddPoint?: true
    FruitSubPoint?: true
    ResetCount?: true
    MasterResetCount?: true
    ExtInventory?: true
    Resets?: true
    ResetsDay?: true
    ResetsWeek?: true
    ResetsMonth?: true
    MResets?: true
    MResetsDay?: true
    MResetsWeek?: true
    MResetsMonth?: true
    PKTotal?: true
    PKDay?: true
    PKWeek?: true
    PKMonth?: true
    HeroTotal?: true
    HeroDay?: true
    HeroWeek?: true
    HeroMonth?: true
    tradewins?: true
    matamata?: true
    duel_total?: true
    duel_semanal?: true
    duel_mensal?: true
  }

  export type CharacterCountAggregateInputType = {
    AccountID?: true
    Name?: true
    cLevel?: true
    LevelUpPoint?: true
    Class?: true
    Experience?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Inventory?: true
    MagicList?: true
    Money?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    BP?: true
    MaxBP?: true
    Shield?: true
    MaxShield?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    MapDir?: true
    PkCount?: true
    PkLevel?: true
    PkTime?: true
    MDate?: true
    LDate?: true
    CtlCode?: true
    DbVersion?: true
    Quest?: true
    ChatLimitTime?: true
    FruitPoint?: true
    EffectList?: true
    FruitAddPoint?: true
    FruitSubPoint?: true
    ResetCount?: true
    MasterResetCount?: true
    ExtInventory?: true
    Resets?: true
    ResetsDay?: true
    ResetsWeek?: true
    ResetsMonth?: true
    MResets?: true
    MResetsDay?: true
    MResetsWeek?: true
    MResetsMonth?: true
    PKTotal?: true
    PKDay?: true
    PKWeek?: true
    PKMonth?: true
    HeroTotal?: true
    HeroDay?: true
    HeroWeek?: true
    HeroMonth?: true
    tradewins?: true
    matamata?: true
    duel_total?: true
    duel_semanal?: true
    duel_mensal?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    AccountID: string
    Name: string
    cLevel: number | null
    LevelUpPoint: number | null
    Class: number | null
    Experience: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Inventory: Buffer | null
    MagicList: Buffer | null
    Money: number | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    BP: number | null
    MaxBP: number | null
    Shield: number | null
    MaxShield: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    MapDir: number | null
    PkCount: number | null
    PkLevel: number | null
    PkTime: number | null
    MDate: Date | null
    LDate: Date | null
    CtlCode: number | null
    DbVersion: number | null
    Quest: Buffer | null
    ChatLimitTime: number | null
    FruitPoint: number | null
    EffectList: Buffer | null
    FruitAddPoint: number
    FruitSubPoint: number
    ResetCount: number
    MasterResetCount: number
    ExtInventory: number
    Resets: number
    ResetsDay: number
    ResetsWeek: number
    ResetsMonth: number
    MResets: number
    MResetsDay: number
    MResetsWeek: number
    MResetsMonth: number
    PKTotal: number
    PKDay: number
    PKWeek: number
    PKMonth: number
    HeroTotal: number
    HeroDay: number
    HeroWeek: number
    HeroMonth: number
    tradewins: number
    matamata: number
    duel_total: number
    duel_semanal: number
    duel_mensal: number
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AccountID?: boolean
    Name?: boolean
    cLevel?: boolean
    LevelUpPoint?: boolean
    Class?: boolean
    Experience?: boolean
    Strength?: boolean
    Dexterity?: boolean
    Vitality?: boolean
    Energy?: boolean
    Leadership?: boolean
    Inventory?: boolean
    MagicList?: boolean
    Money?: boolean
    Life?: boolean
    MaxLife?: boolean
    Mana?: boolean
    MaxMana?: boolean
    BP?: boolean
    MaxBP?: boolean
    Shield?: boolean
    MaxShield?: boolean
    MapNumber?: boolean
    MapPosX?: boolean
    MapPosY?: boolean
    MapDir?: boolean
    PkCount?: boolean
    PkLevel?: boolean
    PkTime?: boolean
    MDate?: boolean
    LDate?: boolean
    CtlCode?: boolean
    DbVersion?: boolean
    Quest?: boolean
    ChatLimitTime?: boolean
    FruitPoint?: boolean
    EffectList?: boolean
    FruitAddPoint?: boolean
    FruitSubPoint?: boolean
    ResetCount?: boolean
    MasterResetCount?: boolean
    ExtInventory?: boolean
    Resets?: boolean
    ResetsDay?: boolean
    ResetsWeek?: boolean
    ResetsMonth?: boolean
    MResets?: boolean
    MResetsDay?: boolean
    MResetsWeek?: boolean
    MResetsMonth?: boolean
    PKTotal?: boolean
    PKDay?: boolean
    PKWeek?: boolean
    PKMonth?: boolean
    HeroTotal?: boolean
    HeroDay?: boolean
    HeroWeek?: boolean
    HeroMonth?: boolean
    tradewins?: boolean
    matamata?: boolean
    duel_total?: boolean
    duel_semanal?: boolean
    duel_mensal?: boolean
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    AccountID?: boolean
    Name?: boolean
    cLevel?: boolean
    LevelUpPoint?: boolean
    Class?: boolean
    Experience?: boolean
    Strength?: boolean
    Dexterity?: boolean
    Vitality?: boolean
    Energy?: boolean
    Leadership?: boolean
    Inventory?: boolean
    MagicList?: boolean
    Money?: boolean
    Life?: boolean
    MaxLife?: boolean
    Mana?: boolean
    MaxMana?: boolean
    BP?: boolean
    MaxBP?: boolean
    Shield?: boolean
    MaxShield?: boolean
    MapNumber?: boolean
    MapPosX?: boolean
    MapPosY?: boolean
    MapDir?: boolean
    PkCount?: boolean
    PkLevel?: boolean
    PkTime?: boolean
    MDate?: boolean
    LDate?: boolean
    CtlCode?: boolean
    DbVersion?: boolean
    Quest?: boolean
    ChatLimitTime?: boolean
    FruitPoint?: boolean
    EffectList?: boolean
    FruitAddPoint?: boolean
    FruitSubPoint?: boolean
    ResetCount?: boolean
    MasterResetCount?: boolean
    ExtInventory?: boolean
    Resets?: boolean
    ResetsDay?: boolean
    ResetsWeek?: boolean
    ResetsMonth?: boolean
    MResets?: boolean
    MResetsDay?: boolean
    MResetsWeek?: boolean
    MResetsMonth?: boolean
    PKTotal?: boolean
    PKDay?: boolean
    PKWeek?: boolean
    PKMonth?: boolean
    HeroTotal?: boolean
    HeroDay?: boolean
    HeroWeek?: boolean
    HeroMonth?: boolean
    tradewins?: boolean
    matamata?: boolean
    duel_total?: boolean
    duel_semanal?: boolean
    duel_mensal?: boolean
  }


  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AccountID: string
      Name: string
      cLevel: number | null
      LevelUpPoint: number | null
      Class: number | null
      Experience: number | null
      Strength: number | null
      Dexterity: number | null
      Vitality: number | null
      Energy: number | null
      Leadership: number | null
      Inventory: Buffer | null
      MagicList: Buffer | null
      Money: number | null
      Life: number | null
      MaxLife: number | null
      Mana: number | null
      MaxMana: number | null
      BP: number | null
      MaxBP: number | null
      Shield: number | null
      MaxShield: number | null
      MapNumber: number | null
      MapPosX: number | null
      MapPosY: number | null
      MapDir: number | null
      PkCount: number | null
      PkLevel: number | null
      PkTime: number | null
      MDate: Date | null
      LDate: Date | null
      CtlCode: number | null
      DbVersion: number | null
      Quest: Buffer | null
      ChatLimitTime: number | null
      FruitPoint: number | null
      EffectList: Buffer | null
      FruitAddPoint: number
      FruitSubPoint: number
      ResetCount: number
      MasterResetCount: number
      ExtInventory: number
      Resets: number
      ResetsDay: number
      ResetsWeek: number
      ResetsMonth: number
      MResets: number
      MResetsDay: number
      MResetsWeek: number
      MResetsMonth: number
      PKTotal: number
      PKDay: number
      PKWeek: number
      PKMonth: number
      HeroTotal: number
      HeroDay: number
      HeroWeek: number
      HeroMonth: number
      tradewins: number
      matamata: number
      duel_total: number
      duel_semanal: number
      duel_mensal: number
    }, ExtArgs["result"]["character"]>
    composites: {}
  }


  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CharacterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Character that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CharacterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `AccountID`
     * const characterWithAccountIDOnly = await prisma.character.findMany({ select: { AccountID: true } })
     * 
    **/
    findMany<T extends CharacterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
    **/
    create<T extends CharacterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Characters.
     *     @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     *     @example
     *     // Create many Characters
     *     const character = await prisma.character.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CharacterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
    **/
    delete<T extends CharacterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CharacterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CharacterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CharacterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
    **/
    upsert<T extends CharacterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>
    ): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Character model
   */ 
  interface CharacterFieldRefs {
    readonly AccountID: FieldRef<"Character", 'String'>
    readonly Name: FieldRef<"Character", 'String'>
    readonly cLevel: FieldRef<"Character", 'Int'>
    readonly LevelUpPoint: FieldRef<"Character", 'Int'>
    readonly Class: FieldRef<"Character", 'Int'>
    readonly Experience: FieldRef<"Character", 'Int'>
    readonly Strength: FieldRef<"Character", 'Int'>
    readonly Dexterity: FieldRef<"Character", 'Int'>
    readonly Vitality: FieldRef<"Character", 'Int'>
    readonly Energy: FieldRef<"Character", 'Int'>
    readonly Leadership: FieldRef<"Character", 'Int'>
    readonly Inventory: FieldRef<"Character", 'Bytes'>
    readonly MagicList: FieldRef<"Character", 'Bytes'>
    readonly Money: FieldRef<"Character", 'Int'>
    readonly Life: FieldRef<"Character", 'Float'>
    readonly MaxLife: FieldRef<"Character", 'Float'>
    readonly Mana: FieldRef<"Character", 'Float'>
    readonly MaxMana: FieldRef<"Character", 'Float'>
    readonly BP: FieldRef<"Character", 'Float'>
    readonly MaxBP: FieldRef<"Character", 'Float'>
    readonly Shield: FieldRef<"Character", 'Float'>
    readonly MaxShield: FieldRef<"Character", 'Float'>
    readonly MapNumber: FieldRef<"Character", 'Int'>
    readonly MapPosX: FieldRef<"Character", 'Int'>
    readonly MapPosY: FieldRef<"Character", 'Int'>
    readonly MapDir: FieldRef<"Character", 'Int'>
    readonly PkCount: FieldRef<"Character", 'Int'>
    readonly PkLevel: FieldRef<"Character", 'Int'>
    readonly PkTime: FieldRef<"Character", 'Int'>
    readonly MDate: FieldRef<"Character", 'DateTime'>
    readonly LDate: FieldRef<"Character", 'DateTime'>
    readonly CtlCode: FieldRef<"Character", 'Int'>
    readonly DbVersion: FieldRef<"Character", 'Int'>
    readonly Quest: FieldRef<"Character", 'Bytes'>
    readonly ChatLimitTime: FieldRef<"Character", 'Int'>
    readonly FruitPoint: FieldRef<"Character", 'Int'>
    readonly EffectList: FieldRef<"Character", 'Bytes'>
    readonly FruitAddPoint: FieldRef<"Character", 'Int'>
    readonly FruitSubPoint: FieldRef<"Character", 'Int'>
    readonly ResetCount: FieldRef<"Character", 'Int'>
    readonly MasterResetCount: FieldRef<"Character", 'Int'>
    readonly ExtInventory: FieldRef<"Character", 'Int'>
    readonly Resets: FieldRef<"Character", 'Int'>
    readonly ResetsDay: FieldRef<"Character", 'Int'>
    readonly ResetsWeek: FieldRef<"Character", 'Int'>
    readonly ResetsMonth: FieldRef<"Character", 'Int'>
    readonly MResets: FieldRef<"Character", 'Int'>
    readonly MResetsDay: FieldRef<"Character", 'Int'>
    readonly MResetsWeek: FieldRef<"Character", 'Int'>
    readonly MResetsMonth: FieldRef<"Character", 'Int'>
    readonly PKTotal: FieldRef<"Character", 'Int'>
    readonly PKDay: FieldRef<"Character", 'Int'>
    readonly PKWeek: FieldRef<"Character", 'Int'>
    readonly PKMonth: FieldRef<"Character", 'Int'>
    readonly HeroTotal: FieldRef<"Character", 'Int'>
    readonly HeroDay: FieldRef<"Character", 'Int'>
    readonly HeroWeek: FieldRef<"Character", 'Int'>
    readonly HeroMonth: FieldRef<"Character", 'Int'>
    readonly tradewins: FieldRef<"Character", 'Int'>
    readonly matamata: FieldRef<"Character", 'Int'>
    readonly duel_total: FieldRef<"Character", 'Int'>
    readonly duel_semanal: FieldRef<"Character", 'Int'>
    readonly duel_mensal: FieldRef<"Character", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }


  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }


  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
  }


  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
  }


  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }


  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }


  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
  }


  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
  }



  /**
   * Model DefaultClassType
   */

  export type AggregateDefaultClassType = {
    _count: DefaultClassTypeCountAggregateOutputType | null
    _avg: DefaultClassTypeAvgAggregateOutputType | null
    _sum: DefaultClassTypeSumAggregateOutputType | null
    _min: DefaultClassTypeMinAggregateOutputType | null
    _max: DefaultClassTypeMaxAggregateOutputType | null
  }

  export type DefaultClassTypeAvgAggregateOutputType = {
    Class: number | null
    Level: number | null
    LevelUpPoint: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    DbVersion: number | null
  }

  export type DefaultClassTypeSumAggregateOutputType = {
    Class: number | null
    Level: number | null
    LevelUpPoint: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    DbVersion: number | null
  }

  export type DefaultClassTypeMinAggregateOutputType = {
    Class: number | null
    Level: number | null
    LevelUpPoint: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Inventory: Buffer | null
    MagicList: Buffer | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    Quest: Buffer | null
    DbVersion: number | null
    EffectList: Buffer | null
  }

  export type DefaultClassTypeMaxAggregateOutputType = {
    Class: number | null
    Level: number | null
    LevelUpPoint: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Inventory: Buffer | null
    MagicList: Buffer | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    Quest: Buffer | null
    DbVersion: number | null
    EffectList: Buffer | null
  }

  export type DefaultClassTypeCountAggregateOutputType = {
    Class: number
    Level: number
    LevelUpPoint: number
    Strength: number
    Dexterity: number
    Vitality: number
    Energy: number
    Leadership: number
    Inventory: number
    MagicList: number
    Life: number
    MaxLife: number
    Mana: number
    MaxMana: number
    MapNumber: number
    MapPosX: number
    MapPosY: number
    Quest: number
    DbVersion: number
    EffectList: number
    _all: number
  }


  export type DefaultClassTypeAvgAggregateInputType = {
    Class?: true
    Level?: true
    LevelUpPoint?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    DbVersion?: true
  }

  export type DefaultClassTypeSumAggregateInputType = {
    Class?: true
    Level?: true
    LevelUpPoint?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    DbVersion?: true
  }

  export type DefaultClassTypeMinAggregateInputType = {
    Class?: true
    Level?: true
    LevelUpPoint?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Inventory?: true
    MagicList?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    Quest?: true
    DbVersion?: true
    EffectList?: true
  }

  export type DefaultClassTypeMaxAggregateInputType = {
    Class?: true
    Level?: true
    LevelUpPoint?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Inventory?: true
    MagicList?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    Quest?: true
    DbVersion?: true
    EffectList?: true
  }

  export type DefaultClassTypeCountAggregateInputType = {
    Class?: true
    Level?: true
    LevelUpPoint?: true
    Strength?: true
    Dexterity?: true
    Vitality?: true
    Energy?: true
    Leadership?: true
    Inventory?: true
    MagicList?: true
    Life?: true
    MaxLife?: true
    Mana?: true
    MaxMana?: true
    MapNumber?: true
    MapPosX?: true
    MapPosY?: true
    Quest?: true
    DbVersion?: true
    EffectList?: true
    _all?: true
  }

  export type DefaultClassTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultClassType to aggregate.
     */
    where?: DefaultClassTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultClassTypes to fetch.
     */
    orderBy?: DefaultClassTypeOrderByWithRelationInput | DefaultClassTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DefaultClassTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultClassTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultClassTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DefaultClassTypes
    **/
    _count?: true | DefaultClassTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefaultClassTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefaultClassTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefaultClassTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefaultClassTypeMaxAggregateInputType
  }

  export type GetDefaultClassTypeAggregateType<T extends DefaultClassTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDefaultClassType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefaultClassType[P]>
      : GetScalarType<T[P], AggregateDefaultClassType[P]>
  }




  export type DefaultClassTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DefaultClassTypeWhereInput
    orderBy?: DefaultClassTypeOrderByWithAggregationInput | DefaultClassTypeOrderByWithAggregationInput[]
    by: DefaultClassTypeScalarFieldEnum[] | DefaultClassTypeScalarFieldEnum
    having?: DefaultClassTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefaultClassTypeCountAggregateInputType | true
    _avg?: DefaultClassTypeAvgAggregateInputType
    _sum?: DefaultClassTypeSumAggregateInputType
    _min?: DefaultClassTypeMinAggregateInputType
    _max?: DefaultClassTypeMaxAggregateInputType
  }

  export type DefaultClassTypeGroupByOutputType = {
    Class: number
    Level: number | null
    LevelUpPoint: number | null
    Strength: number | null
    Dexterity: number | null
    Vitality: number | null
    Energy: number | null
    Leadership: number | null
    Inventory: Buffer | null
    MagicList: Buffer | null
    Life: number | null
    MaxLife: number | null
    Mana: number | null
    MaxMana: number | null
    MapNumber: number | null
    MapPosX: number | null
    MapPosY: number | null
    Quest: Buffer | null
    DbVersion: number | null
    EffectList: Buffer | null
    _count: DefaultClassTypeCountAggregateOutputType | null
    _avg: DefaultClassTypeAvgAggregateOutputType | null
    _sum: DefaultClassTypeSumAggregateOutputType | null
    _min: DefaultClassTypeMinAggregateOutputType | null
    _max: DefaultClassTypeMaxAggregateOutputType | null
  }

  type GetDefaultClassTypeGroupByPayload<T extends DefaultClassTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DefaultClassTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefaultClassTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefaultClassTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DefaultClassTypeGroupByOutputType[P]>
        }
      >
    >


  export type DefaultClassTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Class?: boolean
    Level?: boolean
    LevelUpPoint?: boolean
    Strength?: boolean
    Dexterity?: boolean
    Vitality?: boolean
    Energy?: boolean
    Leadership?: boolean
    Inventory?: boolean
    MagicList?: boolean
    Life?: boolean
    MaxLife?: boolean
    Mana?: boolean
    MaxMana?: boolean
    MapNumber?: boolean
    MapPosX?: boolean
    MapPosY?: boolean
    Quest?: boolean
    DbVersion?: boolean
    EffectList?: boolean
  }, ExtArgs["result"]["defaultClassType"]>

  export type DefaultClassTypeSelectScalar = {
    Class?: boolean
    Level?: boolean
    LevelUpPoint?: boolean
    Strength?: boolean
    Dexterity?: boolean
    Vitality?: boolean
    Energy?: boolean
    Leadership?: boolean
    Inventory?: boolean
    MagicList?: boolean
    Life?: boolean
    MaxLife?: boolean
    Mana?: boolean
    MaxMana?: boolean
    MapNumber?: boolean
    MapPosX?: boolean
    MapPosY?: boolean
    Quest?: boolean
    DbVersion?: boolean
    EffectList?: boolean
  }


  export type $DefaultClassTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DefaultClassType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Class: number
      Level: number | null
      LevelUpPoint: number | null
      Strength: number | null
      Dexterity: number | null
      Vitality: number | null
      Energy: number | null
      Leadership: number | null
      Inventory: Buffer | null
      MagicList: Buffer | null
      Life: number | null
      MaxLife: number | null
      Mana: number | null
      MaxMana: number | null
      MapNumber: number | null
      MapPosX: number | null
      MapPosY: number | null
      Quest: Buffer | null
      DbVersion: number | null
      EffectList: Buffer | null
    }, ExtArgs["result"]["defaultClassType"]>
    composites: {}
  }


  type DefaultClassTypeGetPayload<S extends boolean | null | undefined | DefaultClassTypeDefaultArgs> = $Result.GetResult<Prisma.$DefaultClassTypePayload, S>

  type DefaultClassTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DefaultClassTypeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DefaultClassTypeCountAggregateInputType | true
    }

  export interface DefaultClassTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DefaultClassType'], meta: { name: 'DefaultClassType' } }
    /**
     * Find zero or one DefaultClassType that matches the filter.
     * @param {DefaultClassTypeFindUniqueArgs} args - Arguments to find a DefaultClassType
     * @example
     * // Get one DefaultClassType
     * const defaultClassType = await prisma.defaultClassType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DefaultClassTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DefaultClassTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__DefaultClassTypeClient<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DefaultClassType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DefaultClassTypeFindUniqueOrThrowArgs} args - Arguments to find a DefaultClassType
     * @example
     * // Get one DefaultClassType
     * const defaultClassType = await prisma.defaultClassType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DefaultClassTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DefaultClassTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DefaultClassTypeClient<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DefaultClassType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultClassTypeFindFirstArgs} args - Arguments to find a DefaultClassType
     * @example
     * // Get one DefaultClassType
     * const defaultClassType = await prisma.defaultClassType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DefaultClassTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DefaultClassTypeFindFirstArgs<ExtArgs>>
    ): Prisma__DefaultClassTypeClient<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DefaultClassType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultClassTypeFindFirstOrThrowArgs} args - Arguments to find a DefaultClassType
     * @example
     * // Get one DefaultClassType
     * const defaultClassType = await prisma.defaultClassType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DefaultClassTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DefaultClassTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DefaultClassTypeClient<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DefaultClassTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultClassTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DefaultClassTypes
     * const defaultClassTypes = await prisma.defaultClassType.findMany()
     * 
     * // Get first 10 DefaultClassTypes
     * const defaultClassTypes = await prisma.defaultClassType.findMany({ take: 10 })
     * 
     * // Only select the `Class`
     * const defaultClassTypeWithClassOnly = await prisma.defaultClassType.findMany({ select: { Class: true } })
     * 
    **/
    findMany<T extends DefaultClassTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DefaultClassTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DefaultClassType.
     * @param {DefaultClassTypeCreateArgs} args - Arguments to create a DefaultClassType.
     * @example
     * // Create one DefaultClassType
     * const DefaultClassType = await prisma.defaultClassType.create({
     *   data: {
     *     // ... data to create a DefaultClassType
     *   }
     * })
     * 
    **/
    create<T extends DefaultClassTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DefaultClassTypeCreateArgs<ExtArgs>>
    ): Prisma__DefaultClassTypeClient<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DefaultClassTypes.
     *     @param {DefaultClassTypeCreateManyArgs} args - Arguments to create many DefaultClassTypes.
     *     @example
     *     // Create many DefaultClassTypes
     *     const defaultClassType = await prisma.defaultClassType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DefaultClassTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DefaultClassTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DefaultClassType.
     * @param {DefaultClassTypeDeleteArgs} args - Arguments to delete one DefaultClassType.
     * @example
     * // Delete one DefaultClassType
     * const DefaultClassType = await prisma.defaultClassType.delete({
     *   where: {
     *     // ... filter to delete one DefaultClassType
     *   }
     * })
     * 
    **/
    delete<T extends DefaultClassTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DefaultClassTypeDeleteArgs<ExtArgs>>
    ): Prisma__DefaultClassTypeClient<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DefaultClassType.
     * @param {DefaultClassTypeUpdateArgs} args - Arguments to update one DefaultClassType.
     * @example
     * // Update one DefaultClassType
     * const defaultClassType = await prisma.defaultClassType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DefaultClassTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DefaultClassTypeUpdateArgs<ExtArgs>>
    ): Prisma__DefaultClassTypeClient<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DefaultClassTypes.
     * @param {DefaultClassTypeDeleteManyArgs} args - Arguments to filter DefaultClassTypes to delete.
     * @example
     * // Delete a few DefaultClassTypes
     * const { count } = await prisma.defaultClassType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DefaultClassTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DefaultClassTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DefaultClassTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultClassTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DefaultClassTypes
     * const defaultClassType = await prisma.defaultClassType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DefaultClassTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DefaultClassTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DefaultClassType.
     * @param {DefaultClassTypeUpsertArgs} args - Arguments to update or create a DefaultClassType.
     * @example
     * // Update or create a DefaultClassType
     * const defaultClassType = await prisma.defaultClassType.upsert({
     *   create: {
     *     // ... data to create a DefaultClassType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DefaultClassType we want to update
     *   }
     * })
    **/
    upsert<T extends DefaultClassTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DefaultClassTypeUpsertArgs<ExtArgs>>
    ): Prisma__DefaultClassTypeClient<$Result.GetResult<Prisma.$DefaultClassTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DefaultClassTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultClassTypeCountArgs} args - Arguments to filter DefaultClassTypes to count.
     * @example
     * // Count the number of DefaultClassTypes
     * const count = await prisma.defaultClassType.count({
     *   where: {
     *     // ... the filter for the DefaultClassTypes we want to count
     *   }
     * })
    **/
    count<T extends DefaultClassTypeCountArgs>(
      args?: Subset<T, DefaultClassTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefaultClassTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DefaultClassType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultClassTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefaultClassTypeAggregateArgs>(args: Subset<T, DefaultClassTypeAggregateArgs>): Prisma.PrismaPromise<GetDefaultClassTypeAggregateType<T>>

    /**
     * Group by DefaultClassType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefaultClassTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefaultClassTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefaultClassTypeGroupByArgs['orderBy'] }
        : { orderBy?: DefaultClassTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefaultClassTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefaultClassTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DefaultClassType model
   */
  readonly fields: DefaultClassTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DefaultClassType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DefaultClassTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DefaultClassType model
   */ 
  interface DefaultClassTypeFieldRefs {
    readonly Class: FieldRef<"DefaultClassType", 'Int'>
    readonly Level: FieldRef<"DefaultClassType", 'Int'>
    readonly LevelUpPoint: FieldRef<"DefaultClassType", 'Int'>
    readonly Strength: FieldRef<"DefaultClassType", 'Int'>
    readonly Dexterity: FieldRef<"DefaultClassType", 'Int'>
    readonly Vitality: FieldRef<"DefaultClassType", 'Int'>
    readonly Energy: FieldRef<"DefaultClassType", 'Int'>
    readonly Leadership: FieldRef<"DefaultClassType", 'Int'>
    readonly Inventory: FieldRef<"DefaultClassType", 'Bytes'>
    readonly MagicList: FieldRef<"DefaultClassType", 'Bytes'>
    readonly Life: FieldRef<"DefaultClassType", 'Float'>
    readonly MaxLife: FieldRef<"DefaultClassType", 'Float'>
    readonly Mana: FieldRef<"DefaultClassType", 'Float'>
    readonly MaxMana: FieldRef<"DefaultClassType", 'Float'>
    readonly MapNumber: FieldRef<"DefaultClassType", 'Int'>
    readonly MapPosX: FieldRef<"DefaultClassType", 'Int'>
    readonly MapPosY: FieldRef<"DefaultClassType", 'Int'>
    readonly Quest: FieldRef<"DefaultClassType", 'Bytes'>
    readonly DbVersion: FieldRef<"DefaultClassType", 'Int'>
    readonly EffectList: FieldRef<"DefaultClassType", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * DefaultClassType findUnique
   */
  export type DefaultClassTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * Filter, which DefaultClassType to fetch.
     */
    where: DefaultClassTypeWhereUniqueInput
  }


  /**
   * DefaultClassType findUniqueOrThrow
   */
  export type DefaultClassTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * Filter, which DefaultClassType to fetch.
     */
    where: DefaultClassTypeWhereUniqueInput
  }


  /**
   * DefaultClassType findFirst
   */
  export type DefaultClassTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * Filter, which DefaultClassType to fetch.
     */
    where?: DefaultClassTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultClassTypes to fetch.
     */
    orderBy?: DefaultClassTypeOrderByWithRelationInput | DefaultClassTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultClassTypes.
     */
    cursor?: DefaultClassTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultClassTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultClassTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultClassTypes.
     */
    distinct?: DefaultClassTypeScalarFieldEnum | DefaultClassTypeScalarFieldEnum[]
  }


  /**
   * DefaultClassType findFirstOrThrow
   */
  export type DefaultClassTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * Filter, which DefaultClassType to fetch.
     */
    where?: DefaultClassTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultClassTypes to fetch.
     */
    orderBy?: DefaultClassTypeOrderByWithRelationInput | DefaultClassTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DefaultClassTypes.
     */
    cursor?: DefaultClassTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultClassTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultClassTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DefaultClassTypes.
     */
    distinct?: DefaultClassTypeScalarFieldEnum | DefaultClassTypeScalarFieldEnum[]
  }


  /**
   * DefaultClassType findMany
   */
  export type DefaultClassTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * Filter, which DefaultClassTypes to fetch.
     */
    where?: DefaultClassTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DefaultClassTypes to fetch.
     */
    orderBy?: DefaultClassTypeOrderByWithRelationInput | DefaultClassTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DefaultClassTypes.
     */
    cursor?: DefaultClassTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DefaultClassTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DefaultClassTypes.
     */
    skip?: number
    distinct?: DefaultClassTypeScalarFieldEnum | DefaultClassTypeScalarFieldEnum[]
  }


  /**
   * DefaultClassType create
   */
  export type DefaultClassTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a DefaultClassType.
     */
    data: XOR<DefaultClassTypeCreateInput, DefaultClassTypeUncheckedCreateInput>
  }


  /**
   * DefaultClassType createMany
   */
  export type DefaultClassTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DefaultClassTypes.
     */
    data: DefaultClassTypeCreateManyInput | DefaultClassTypeCreateManyInput[]
  }


  /**
   * DefaultClassType update
   */
  export type DefaultClassTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a DefaultClassType.
     */
    data: XOR<DefaultClassTypeUpdateInput, DefaultClassTypeUncheckedUpdateInput>
    /**
     * Choose, which DefaultClassType to update.
     */
    where: DefaultClassTypeWhereUniqueInput
  }


  /**
   * DefaultClassType updateMany
   */
  export type DefaultClassTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DefaultClassTypes.
     */
    data: XOR<DefaultClassTypeUpdateManyMutationInput, DefaultClassTypeUncheckedUpdateManyInput>
    /**
     * Filter which DefaultClassTypes to update
     */
    where?: DefaultClassTypeWhereInput
  }


  /**
   * DefaultClassType upsert
   */
  export type DefaultClassTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the DefaultClassType to update in case it exists.
     */
    where: DefaultClassTypeWhereUniqueInput
    /**
     * In case the DefaultClassType found by the `where` argument doesn't exist, create a new DefaultClassType with this data.
     */
    create: XOR<DefaultClassTypeCreateInput, DefaultClassTypeUncheckedCreateInput>
    /**
     * In case the DefaultClassType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DefaultClassTypeUpdateInput, DefaultClassTypeUncheckedUpdateInput>
  }


  /**
   * DefaultClassType delete
   */
  export type DefaultClassTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
    /**
     * Filter which DefaultClassType to delete.
     */
    where: DefaultClassTypeWhereUniqueInput
  }


  /**
   * DefaultClassType deleteMany
   */
  export type DefaultClassTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DefaultClassTypes to delete
     */
    where?: DefaultClassTypeWhereInput
  }


  /**
   * DefaultClassType without action
   */
  export type DefaultClassTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DefaultClassType
     */
    select?: DefaultClassTypeSelect<ExtArgs> | null
  }



  /**
   * Model EventLeoTheHelper
   */

  export type AggregateEventLeoTheHelper = {
    _count: EventLeoTheHelperCountAggregateOutputType | null
    _avg: EventLeoTheHelperAvgAggregateOutputType | null
    _sum: EventLeoTheHelperSumAggregateOutputType | null
    _min: EventLeoTheHelperMinAggregateOutputType | null
    _max: EventLeoTheHelperMaxAggregateOutputType | null
  }

  export type EventLeoTheHelperAvgAggregateOutputType = {
    Status: number | null
  }

  export type EventLeoTheHelperSumAggregateOutputType = {
    Status: number | null
  }

  export type EventLeoTheHelperMinAggregateOutputType = {
    Name: string | null
    Status: number | null
  }

  export type EventLeoTheHelperMaxAggregateOutputType = {
    Name: string | null
    Status: number | null
  }

  export type EventLeoTheHelperCountAggregateOutputType = {
    Name: number
    Status: number
    _all: number
  }


  export type EventLeoTheHelperAvgAggregateInputType = {
    Status?: true
  }

  export type EventLeoTheHelperSumAggregateInputType = {
    Status?: true
  }

  export type EventLeoTheHelperMinAggregateInputType = {
    Name?: true
    Status?: true
  }

  export type EventLeoTheHelperMaxAggregateInputType = {
    Name?: true
    Status?: true
  }

  export type EventLeoTheHelperCountAggregateInputType = {
    Name?: true
    Status?: true
    _all?: true
  }

  export type EventLeoTheHelperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventLeoTheHelper to aggregate.
     */
    where?: EventLeoTheHelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLeoTheHelpers to fetch.
     */
    orderBy?: EventLeoTheHelperOrderByWithRelationInput | EventLeoTheHelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventLeoTheHelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLeoTheHelpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLeoTheHelpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventLeoTheHelpers
    **/
    _count?: true | EventLeoTheHelperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventLeoTheHelperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventLeoTheHelperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventLeoTheHelperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventLeoTheHelperMaxAggregateInputType
  }

  export type GetEventLeoTheHelperAggregateType<T extends EventLeoTheHelperAggregateArgs> = {
        [P in keyof T & keyof AggregateEventLeoTheHelper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventLeoTheHelper[P]>
      : GetScalarType<T[P], AggregateEventLeoTheHelper[P]>
  }




  export type EventLeoTheHelperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventLeoTheHelperWhereInput
    orderBy?: EventLeoTheHelperOrderByWithAggregationInput | EventLeoTheHelperOrderByWithAggregationInput[]
    by: EventLeoTheHelperScalarFieldEnum[] | EventLeoTheHelperScalarFieldEnum
    having?: EventLeoTheHelperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventLeoTheHelperCountAggregateInputType | true
    _avg?: EventLeoTheHelperAvgAggregateInputType
    _sum?: EventLeoTheHelperSumAggregateInputType
    _min?: EventLeoTheHelperMinAggregateInputType
    _max?: EventLeoTheHelperMaxAggregateInputType
  }

  export type EventLeoTheHelperGroupByOutputType = {
    Name: string
    Status: number | null
    _count: EventLeoTheHelperCountAggregateOutputType | null
    _avg: EventLeoTheHelperAvgAggregateOutputType | null
    _sum: EventLeoTheHelperSumAggregateOutputType | null
    _min: EventLeoTheHelperMinAggregateOutputType | null
    _max: EventLeoTheHelperMaxAggregateOutputType | null
  }

  type GetEventLeoTheHelperGroupByPayload<T extends EventLeoTheHelperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventLeoTheHelperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventLeoTheHelperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventLeoTheHelperGroupByOutputType[P]>
            : GetScalarType<T[P], EventLeoTheHelperGroupByOutputType[P]>
        }
      >
    >


  export type EventLeoTheHelperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Status?: boolean
  }, ExtArgs["result"]["eventLeoTheHelper"]>

  export type EventLeoTheHelperSelectScalar = {
    Name?: boolean
    Status?: boolean
  }


  export type $EventLeoTheHelperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventLeoTheHelper"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Status: number | null
    }, ExtArgs["result"]["eventLeoTheHelper"]>
    composites: {}
  }


  type EventLeoTheHelperGetPayload<S extends boolean | null | undefined | EventLeoTheHelperDefaultArgs> = $Result.GetResult<Prisma.$EventLeoTheHelperPayload, S>

  type EventLeoTheHelperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventLeoTheHelperFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EventLeoTheHelperCountAggregateInputType | true
    }

  export interface EventLeoTheHelperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventLeoTheHelper'], meta: { name: 'EventLeoTheHelper' } }
    /**
     * Find zero or one EventLeoTheHelper that matches the filter.
     * @param {EventLeoTheHelperFindUniqueArgs} args - Arguments to find a EventLeoTheHelper
     * @example
     * // Get one EventLeoTheHelper
     * const eventLeoTheHelper = await prisma.eventLeoTheHelper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventLeoTheHelperFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EventLeoTheHelperFindUniqueArgs<ExtArgs>>
    ): Prisma__EventLeoTheHelperClient<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EventLeoTheHelper that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EventLeoTheHelperFindUniqueOrThrowArgs} args - Arguments to find a EventLeoTheHelper
     * @example
     * // Get one EventLeoTheHelper
     * const eventLeoTheHelper = await prisma.eventLeoTheHelper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EventLeoTheHelperFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventLeoTheHelperFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EventLeoTheHelperClient<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EventLeoTheHelper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLeoTheHelperFindFirstArgs} args - Arguments to find a EventLeoTheHelper
     * @example
     * // Get one EventLeoTheHelper
     * const eventLeoTheHelper = await prisma.eventLeoTheHelper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventLeoTheHelperFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EventLeoTheHelperFindFirstArgs<ExtArgs>>
    ): Prisma__EventLeoTheHelperClient<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EventLeoTheHelper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLeoTheHelperFindFirstOrThrowArgs} args - Arguments to find a EventLeoTheHelper
     * @example
     * // Get one EventLeoTheHelper
     * const eventLeoTheHelper = await prisma.eventLeoTheHelper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EventLeoTheHelperFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventLeoTheHelperFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EventLeoTheHelperClient<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EventLeoTheHelpers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLeoTheHelperFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventLeoTheHelpers
     * const eventLeoTheHelpers = await prisma.eventLeoTheHelper.findMany()
     * 
     * // Get first 10 EventLeoTheHelpers
     * const eventLeoTheHelpers = await prisma.eventLeoTheHelper.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const eventLeoTheHelperWithNameOnly = await prisma.eventLeoTheHelper.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends EventLeoTheHelperFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventLeoTheHelperFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EventLeoTheHelper.
     * @param {EventLeoTheHelperCreateArgs} args - Arguments to create a EventLeoTheHelper.
     * @example
     * // Create one EventLeoTheHelper
     * const EventLeoTheHelper = await prisma.eventLeoTheHelper.create({
     *   data: {
     *     // ... data to create a EventLeoTheHelper
     *   }
     * })
     * 
    **/
    create<T extends EventLeoTheHelperCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EventLeoTheHelperCreateArgs<ExtArgs>>
    ): Prisma__EventLeoTheHelperClient<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EventLeoTheHelpers.
     *     @param {EventLeoTheHelperCreateManyArgs} args - Arguments to create many EventLeoTheHelpers.
     *     @example
     *     // Create many EventLeoTheHelpers
     *     const eventLeoTheHelper = await prisma.eventLeoTheHelper.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventLeoTheHelperCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventLeoTheHelperCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventLeoTheHelper.
     * @param {EventLeoTheHelperDeleteArgs} args - Arguments to delete one EventLeoTheHelper.
     * @example
     * // Delete one EventLeoTheHelper
     * const EventLeoTheHelper = await prisma.eventLeoTheHelper.delete({
     *   where: {
     *     // ... filter to delete one EventLeoTheHelper
     *   }
     * })
     * 
    **/
    delete<T extends EventLeoTheHelperDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EventLeoTheHelperDeleteArgs<ExtArgs>>
    ): Prisma__EventLeoTheHelperClient<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EventLeoTheHelper.
     * @param {EventLeoTheHelperUpdateArgs} args - Arguments to update one EventLeoTheHelper.
     * @example
     * // Update one EventLeoTheHelper
     * const eventLeoTheHelper = await prisma.eventLeoTheHelper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventLeoTheHelperUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EventLeoTheHelperUpdateArgs<ExtArgs>>
    ): Prisma__EventLeoTheHelperClient<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EventLeoTheHelpers.
     * @param {EventLeoTheHelperDeleteManyArgs} args - Arguments to filter EventLeoTheHelpers to delete.
     * @example
     * // Delete a few EventLeoTheHelpers
     * const { count } = await prisma.eventLeoTheHelper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventLeoTheHelperDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventLeoTheHelperDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventLeoTheHelpers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLeoTheHelperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventLeoTheHelpers
     * const eventLeoTheHelper = await prisma.eventLeoTheHelper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventLeoTheHelperUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EventLeoTheHelperUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventLeoTheHelper.
     * @param {EventLeoTheHelperUpsertArgs} args - Arguments to update or create a EventLeoTheHelper.
     * @example
     * // Update or create a EventLeoTheHelper
     * const eventLeoTheHelper = await prisma.eventLeoTheHelper.upsert({
     *   create: {
     *     // ... data to create a EventLeoTheHelper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventLeoTheHelper we want to update
     *   }
     * })
    **/
    upsert<T extends EventLeoTheHelperUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EventLeoTheHelperUpsertArgs<ExtArgs>>
    ): Prisma__EventLeoTheHelperClient<$Result.GetResult<Prisma.$EventLeoTheHelperPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EventLeoTheHelpers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLeoTheHelperCountArgs} args - Arguments to filter EventLeoTheHelpers to count.
     * @example
     * // Count the number of EventLeoTheHelpers
     * const count = await prisma.eventLeoTheHelper.count({
     *   where: {
     *     // ... the filter for the EventLeoTheHelpers we want to count
     *   }
     * })
    **/
    count<T extends EventLeoTheHelperCountArgs>(
      args?: Subset<T, EventLeoTheHelperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventLeoTheHelperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventLeoTheHelper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLeoTheHelperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventLeoTheHelperAggregateArgs>(args: Subset<T, EventLeoTheHelperAggregateArgs>): Prisma.PrismaPromise<GetEventLeoTheHelperAggregateType<T>>

    /**
     * Group by EventLeoTheHelper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventLeoTheHelperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventLeoTheHelperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventLeoTheHelperGroupByArgs['orderBy'] }
        : { orderBy?: EventLeoTheHelperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventLeoTheHelperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventLeoTheHelperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventLeoTheHelper model
   */
  readonly fields: EventLeoTheHelperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventLeoTheHelper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventLeoTheHelperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EventLeoTheHelper model
   */ 
  interface EventLeoTheHelperFieldRefs {
    readonly Name: FieldRef<"EventLeoTheHelper", 'String'>
    readonly Status: FieldRef<"EventLeoTheHelper", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EventLeoTheHelper findUnique
   */
  export type EventLeoTheHelperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * Filter, which EventLeoTheHelper to fetch.
     */
    where: EventLeoTheHelperWhereUniqueInput
  }


  /**
   * EventLeoTheHelper findUniqueOrThrow
   */
  export type EventLeoTheHelperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * Filter, which EventLeoTheHelper to fetch.
     */
    where: EventLeoTheHelperWhereUniqueInput
  }


  /**
   * EventLeoTheHelper findFirst
   */
  export type EventLeoTheHelperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * Filter, which EventLeoTheHelper to fetch.
     */
    where?: EventLeoTheHelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLeoTheHelpers to fetch.
     */
    orderBy?: EventLeoTheHelperOrderByWithRelationInput | EventLeoTheHelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventLeoTheHelpers.
     */
    cursor?: EventLeoTheHelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLeoTheHelpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLeoTheHelpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventLeoTheHelpers.
     */
    distinct?: EventLeoTheHelperScalarFieldEnum | EventLeoTheHelperScalarFieldEnum[]
  }


  /**
   * EventLeoTheHelper findFirstOrThrow
   */
  export type EventLeoTheHelperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * Filter, which EventLeoTheHelper to fetch.
     */
    where?: EventLeoTheHelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLeoTheHelpers to fetch.
     */
    orderBy?: EventLeoTheHelperOrderByWithRelationInput | EventLeoTheHelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventLeoTheHelpers.
     */
    cursor?: EventLeoTheHelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLeoTheHelpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLeoTheHelpers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventLeoTheHelpers.
     */
    distinct?: EventLeoTheHelperScalarFieldEnum | EventLeoTheHelperScalarFieldEnum[]
  }


  /**
   * EventLeoTheHelper findMany
   */
  export type EventLeoTheHelperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * Filter, which EventLeoTheHelpers to fetch.
     */
    where?: EventLeoTheHelperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventLeoTheHelpers to fetch.
     */
    orderBy?: EventLeoTheHelperOrderByWithRelationInput | EventLeoTheHelperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventLeoTheHelpers.
     */
    cursor?: EventLeoTheHelperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventLeoTheHelpers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventLeoTheHelpers.
     */
    skip?: number
    distinct?: EventLeoTheHelperScalarFieldEnum | EventLeoTheHelperScalarFieldEnum[]
  }


  /**
   * EventLeoTheHelper create
   */
  export type EventLeoTheHelperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * The data needed to create a EventLeoTheHelper.
     */
    data: XOR<EventLeoTheHelperCreateInput, EventLeoTheHelperUncheckedCreateInput>
  }


  /**
   * EventLeoTheHelper createMany
   */
  export type EventLeoTheHelperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventLeoTheHelpers.
     */
    data: EventLeoTheHelperCreateManyInput | EventLeoTheHelperCreateManyInput[]
  }


  /**
   * EventLeoTheHelper update
   */
  export type EventLeoTheHelperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * The data needed to update a EventLeoTheHelper.
     */
    data: XOR<EventLeoTheHelperUpdateInput, EventLeoTheHelperUncheckedUpdateInput>
    /**
     * Choose, which EventLeoTheHelper to update.
     */
    where: EventLeoTheHelperWhereUniqueInput
  }


  /**
   * EventLeoTheHelper updateMany
   */
  export type EventLeoTheHelperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventLeoTheHelpers.
     */
    data: XOR<EventLeoTheHelperUpdateManyMutationInput, EventLeoTheHelperUncheckedUpdateManyInput>
    /**
     * Filter which EventLeoTheHelpers to update
     */
    where?: EventLeoTheHelperWhereInput
  }


  /**
   * EventLeoTheHelper upsert
   */
  export type EventLeoTheHelperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * The filter to search for the EventLeoTheHelper to update in case it exists.
     */
    where: EventLeoTheHelperWhereUniqueInput
    /**
     * In case the EventLeoTheHelper found by the `where` argument doesn't exist, create a new EventLeoTheHelper with this data.
     */
    create: XOR<EventLeoTheHelperCreateInput, EventLeoTheHelperUncheckedCreateInput>
    /**
     * In case the EventLeoTheHelper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventLeoTheHelperUpdateInput, EventLeoTheHelperUncheckedUpdateInput>
  }


  /**
   * EventLeoTheHelper delete
   */
  export type EventLeoTheHelperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
    /**
     * Filter which EventLeoTheHelper to delete.
     */
    where: EventLeoTheHelperWhereUniqueInput
  }


  /**
   * EventLeoTheHelper deleteMany
   */
  export type EventLeoTheHelperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventLeoTheHelpers to delete
     */
    where?: EventLeoTheHelperWhereInput
  }


  /**
   * EventLeoTheHelper without action
   */
  export type EventLeoTheHelperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventLeoTheHelper
     */
    select?: EventLeoTheHelperSelect<ExtArgs> | null
  }



  /**
   * Model EventSantaClaus
   */

  export type AggregateEventSantaClaus = {
    _count: EventSantaClausCountAggregateOutputType | null
    _avg: EventSantaClausAvgAggregateOutputType | null
    _sum: EventSantaClausSumAggregateOutputType | null
    _min: EventSantaClausMinAggregateOutputType | null
    _max: EventSantaClausMaxAggregateOutputType | null
  }

  export type EventSantaClausAvgAggregateOutputType = {
    Status: number | null
  }

  export type EventSantaClausSumAggregateOutputType = {
    Status: number | null
  }

  export type EventSantaClausMinAggregateOutputType = {
    Name: string | null
    Status: number | null
  }

  export type EventSantaClausMaxAggregateOutputType = {
    Name: string | null
    Status: number | null
  }

  export type EventSantaClausCountAggregateOutputType = {
    Name: number
    Status: number
    _all: number
  }


  export type EventSantaClausAvgAggregateInputType = {
    Status?: true
  }

  export type EventSantaClausSumAggregateInputType = {
    Status?: true
  }

  export type EventSantaClausMinAggregateInputType = {
    Name?: true
    Status?: true
  }

  export type EventSantaClausMaxAggregateInputType = {
    Name?: true
    Status?: true
  }

  export type EventSantaClausCountAggregateInputType = {
    Name?: true
    Status?: true
    _all?: true
  }

  export type EventSantaClausAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventSantaClaus to aggregate.
     */
    where?: EventSantaClausWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSantaClaus to fetch.
     */
    orderBy?: EventSantaClausOrderByWithRelationInput | EventSantaClausOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventSantaClausWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSantaClaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSantaClaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventSantaClaus
    **/
    _count?: true | EventSantaClausCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventSantaClausAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSantaClausSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventSantaClausMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventSantaClausMaxAggregateInputType
  }

  export type GetEventSantaClausAggregateType<T extends EventSantaClausAggregateArgs> = {
        [P in keyof T & keyof AggregateEventSantaClaus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventSantaClaus[P]>
      : GetScalarType<T[P], AggregateEventSantaClaus[P]>
  }




  export type EventSantaClausGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventSantaClausWhereInput
    orderBy?: EventSantaClausOrderByWithAggregationInput | EventSantaClausOrderByWithAggregationInput[]
    by: EventSantaClausScalarFieldEnum[] | EventSantaClausScalarFieldEnum
    having?: EventSantaClausScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventSantaClausCountAggregateInputType | true
    _avg?: EventSantaClausAvgAggregateInputType
    _sum?: EventSantaClausSumAggregateInputType
    _min?: EventSantaClausMinAggregateInputType
    _max?: EventSantaClausMaxAggregateInputType
  }

  export type EventSantaClausGroupByOutputType = {
    Name: string
    Status: number | null
    _count: EventSantaClausCountAggregateOutputType | null
    _avg: EventSantaClausAvgAggregateOutputType | null
    _sum: EventSantaClausSumAggregateOutputType | null
    _min: EventSantaClausMinAggregateOutputType | null
    _max: EventSantaClausMaxAggregateOutputType | null
  }

  type GetEventSantaClausGroupByPayload<T extends EventSantaClausGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventSantaClausGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventSantaClausGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventSantaClausGroupByOutputType[P]>
            : GetScalarType<T[P], EventSantaClausGroupByOutputType[P]>
        }
      >
    >


  export type EventSantaClausSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Status?: boolean
  }, ExtArgs["result"]["eventSantaClaus"]>

  export type EventSantaClausSelectScalar = {
    Name?: boolean
    Status?: boolean
  }


  export type $EventSantaClausPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventSantaClaus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Status: number | null
    }, ExtArgs["result"]["eventSantaClaus"]>
    composites: {}
  }


  type EventSantaClausGetPayload<S extends boolean | null | undefined | EventSantaClausDefaultArgs> = $Result.GetResult<Prisma.$EventSantaClausPayload, S>

  type EventSantaClausCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventSantaClausFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EventSantaClausCountAggregateInputType | true
    }

  export interface EventSantaClausDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventSantaClaus'], meta: { name: 'EventSantaClaus' } }
    /**
     * Find zero or one EventSantaClaus that matches the filter.
     * @param {EventSantaClausFindUniqueArgs} args - Arguments to find a EventSantaClaus
     * @example
     * // Get one EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventSantaClausFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EventSantaClausFindUniqueArgs<ExtArgs>>
    ): Prisma__EventSantaClausClient<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EventSantaClaus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EventSantaClausFindUniqueOrThrowArgs} args - Arguments to find a EventSantaClaus
     * @example
     * // Get one EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EventSantaClausFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventSantaClausFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EventSantaClausClient<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EventSantaClaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSantaClausFindFirstArgs} args - Arguments to find a EventSantaClaus
     * @example
     * // Get one EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventSantaClausFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EventSantaClausFindFirstArgs<ExtArgs>>
    ): Prisma__EventSantaClausClient<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EventSantaClaus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSantaClausFindFirstOrThrowArgs} args - Arguments to find a EventSantaClaus
     * @example
     * // Get one EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EventSantaClausFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EventSantaClausFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EventSantaClausClient<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EventSantaClaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSantaClausFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.findMany()
     * 
     * // Get first 10 EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const eventSantaClausWithNameOnly = await prisma.eventSantaClaus.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends EventSantaClausFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventSantaClausFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EventSantaClaus.
     * @param {EventSantaClausCreateArgs} args - Arguments to create a EventSantaClaus.
     * @example
     * // Create one EventSantaClaus
     * const EventSantaClaus = await prisma.eventSantaClaus.create({
     *   data: {
     *     // ... data to create a EventSantaClaus
     *   }
     * })
     * 
    **/
    create<T extends EventSantaClausCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EventSantaClausCreateArgs<ExtArgs>>
    ): Prisma__EventSantaClausClient<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EventSantaClaus.
     *     @param {EventSantaClausCreateManyArgs} args - Arguments to create many EventSantaClaus.
     *     @example
     *     // Create many EventSantaClaus
     *     const eventSantaClaus = await prisma.eventSantaClaus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventSantaClausCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventSantaClausCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventSantaClaus.
     * @param {EventSantaClausDeleteArgs} args - Arguments to delete one EventSantaClaus.
     * @example
     * // Delete one EventSantaClaus
     * const EventSantaClaus = await prisma.eventSantaClaus.delete({
     *   where: {
     *     // ... filter to delete one EventSantaClaus
     *   }
     * })
     * 
    **/
    delete<T extends EventSantaClausDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EventSantaClausDeleteArgs<ExtArgs>>
    ): Prisma__EventSantaClausClient<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EventSantaClaus.
     * @param {EventSantaClausUpdateArgs} args - Arguments to update one EventSantaClaus.
     * @example
     * // Update one EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventSantaClausUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EventSantaClausUpdateArgs<ExtArgs>>
    ): Prisma__EventSantaClausClient<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EventSantaClaus.
     * @param {EventSantaClausDeleteManyArgs} args - Arguments to filter EventSantaClaus to delete.
     * @example
     * // Delete a few EventSantaClaus
     * const { count } = await prisma.eventSantaClaus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventSantaClausDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EventSantaClausDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventSantaClaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSantaClausUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventSantaClausUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EventSantaClausUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventSantaClaus.
     * @param {EventSantaClausUpsertArgs} args - Arguments to update or create a EventSantaClaus.
     * @example
     * // Update or create a EventSantaClaus
     * const eventSantaClaus = await prisma.eventSantaClaus.upsert({
     *   create: {
     *     // ... data to create a EventSantaClaus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventSantaClaus we want to update
     *   }
     * })
    **/
    upsert<T extends EventSantaClausUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EventSantaClausUpsertArgs<ExtArgs>>
    ): Prisma__EventSantaClausClient<$Result.GetResult<Prisma.$EventSantaClausPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EventSantaClaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSantaClausCountArgs} args - Arguments to filter EventSantaClaus to count.
     * @example
     * // Count the number of EventSantaClaus
     * const count = await prisma.eventSantaClaus.count({
     *   where: {
     *     // ... the filter for the EventSantaClaus we want to count
     *   }
     * })
    **/
    count<T extends EventSantaClausCountArgs>(
      args?: Subset<T, EventSantaClausCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventSantaClausCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventSantaClaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSantaClausAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventSantaClausAggregateArgs>(args: Subset<T, EventSantaClausAggregateArgs>): Prisma.PrismaPromise<GetEventSantaClausAggregateType<T>>

    /**
     * Group by EventSantaClaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSantaClausGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventSantaClausGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventSantaClausGroupByArgs['orderBy'] }
        : { orderBy?: EventSantaClausGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventSantaClausGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventSantaClausGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventSantaClaus model
   */
  readonly fields: EventSantaClausFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventSantaClaus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventSantaClausClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EventSantaClaus model
   */ 
  interface EventSantaClausFieldRefs {
    readonly Name: FieldRef<"EventSantaClaus", 'String'>
    readonly Status: FieldRef<"EventSantaClaus", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * EventSantaClaus findUnique
   */
  export type EventSantaClausFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * Filter, which EventSantaClaus to fetch.
     */
    where: EventSantaClausWhereUniqueInput
  }


  /**
   * EventSantaClaus findUniqueOrThrow
   */
  export type EventSantaClausFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * Filter, which EventSantaClaus to fetch.
     */
    where: EventSantaClausWhereUniqueInput
  }


  /**
   * EventSantaClaus findFirst
   */
  export type EventSantaClausFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * Filter, which EventSantaClaus to fetch.
     */
    where?: EventSantaClausWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSantaClaus to fetch.
     */
    orderBy?: EventSantaClausOrderByWithRelationInput | EventSantaClausOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventSantaClaus.
     */
    cursor?: EventSantaClausWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSantaClaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSantaClaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventSantaClaus.
     */
    distinct?: EventSantaClausScalarFieldEnum | EventSantaClausScalarFieldEnum[]
  }


  /**
   * EventSantaClaus findFirstOrThrow
   */
  export type EventSantaClausFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * Filter, which EventSantaClaus to fetch.
     */
    where?: EventSantaClausWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSantaClaus to fetch.
     */
    orderBy?: EventSantaClausOrderByWithRelationInput | EventSantaClausOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventSantaClaus.
     */
    cursor?: EventSantaClausWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSantaClaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSantaClaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventSantaClaus.
     */
    distinct?: EventSantaClausScalarFieldEnum | EventSantaClausScalarFieldEnum[]
  }


  /**
   * EventSantaClaus findMany
   */
  export type EventSantaClausFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * Filter, which EventSantaClaus to fetch.
     */
    where?: EventSantaClausWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSantaClaus to fetch.
     */
    orderBy?: EventSantaClausOrderByWithRelationInput | EventSantaClausOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventSantaClaus.
     */
    cursor?: EventSantaClausWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSantaClaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSantaClaus.
     */
    skip?: number
    distinct?: EventSantaClausScalarFieldEnum | EventSantaClausScalarFieldEnum[]
  }


  /**
   * EventSantaClaus create
   */
  export type EventSantaClausCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * The data needed to create a EventSantaClaus.
     */
    data: XOR<EventSantaClausCreateInput, EventSantaClausUncheckedCreateInput>
  }


  /**
   * EventSantaClaus createMany
   */
  export type EventSantaClausCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventSantaClaus.
     */
    data: EventSantaClausCreateManyInput | EventSantaClausCreateManyInput[]
  }


  /**
   * EventSantaClaus update
   */
  export type EventSantaClausUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * The data needed to update a EventSantaClaus.
     */
    data: XOR<EventSantaClausUpdateInput, EventSantaClausUncheckedUpdateInput>
    /**
     * Choose, which EventSantaClaus to update.
     */
    where: EventSantaClausWhereUniqueInput
  }


  /**
   * EventSantaClaus updateMany
   */
  export type EventSantaClausUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventSantaClaus.
     */
    data: XOR<EventSantaClausUpdateManyMutationInput, EventSantaClausUncheckedUpdateManyInput>
    /**
     * Filter which EventSantaClaus to update
     */
    where?: EventSantaClausWhereInput
  }


  /**
   * EventSantaClaus upsert
   */
  export type EventSantaClausUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * The filter to search for the EventSantaClaus to update in case it exists.
     */
    where: EventSantaClausWhereUniqueInput
    /**
     * In case the EventSantaClaus found by the `where` argument doesn't exist, create a new EventSantaClaus with this data.
     */
    create: XOR<EventSantaClausCreateInput, EventSantaClausUncheckedCreateInput>
    /**
     * In case the EventSantaClaus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventSantaClausUpdateInput, EventSantaClausUncheckedUpdateInput>
  }


  /**
   * EventSantaClaus delete
   */
  export type EventSantaClausDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
    /**
     * Filter which EventSantaClaus to delete.
     */
    where: EventSantaClausWhereUniqueInput
  }


  /**
   * EventSantaClaus deleteMany
   */
  export type EventSantaClausDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventSantaClaus to delete
     */
    where?: EventSantaClausWhereInput
  }


  /**
   * EventSantaClaus without action
   */
  export type EventSantaClausDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSantaClaus
     */
    select?: EventSantaClausSelect<ExtArgs> | null
  }



  /**
   * Model GameServerInfo
   */

  export type AggregateGameServerInfo = {
    _count: GameServerInfoCountAggregateOutputType | null
    _avg: GameServerInfoAvgAggregateOutputType | null
    _sum: GameServerInfoSumAggregateOutputType | null
    _min: GameServerInfoMinAggregateOutputType | null
    _max: GameServerInfoMaxAggregateOutputType | null
  }

  export type GameServerInfoAvgAggregateOutputType = {
    Number: number | null
    ItemCount: number | null
    ZenCount: number | null
    AceItemCount: number | null
  }

  export type GameServerInfoSumAggregateOutputType = {
    Number: number | null
    ItemCount: number | null
    ZenCount: number | null
    AceItemCount: number | null
  }

  export type GameServerInfoMinAggregateOutputType = {
    Number: number | null
    ItemCount: number | null
    ZenCount: number | null
    AceItemCount: number | null
  }

  export type GameServerInfoMaxAggregateOutputType = {
    Number: number | null
    ItemCount: number | null
    ZenCount: number | null
    AceItemCount: number | null
  }

  export type GameServerInfoCountAggregateOutputType = {
    Number: number
    ItemCount: number
    ZenCount: number
    AceItemCount: number
    _all: number
  }


  export type GameServerInfoAvgAggregateInputType = {
    Number?: true
    ItemCount?: true
    ZenCount?: true
    AceItemCount?: true
  }

  export type GameServerInfoSumAggregateInputType = {
    Number?: true
    ItemCount?: true
    ZenCount?: true
    AceItemCount?: true
  }

  export type GameServerInfoMinAggregateInputType = {
    Number?: true
    ItemCount?: true
    ZenCount?: true
    AceItemCount?: true
  }

  export type GameServerInfoMaxAggregateInputType = {
    Number?: true
    ItemCount?: true
    ZenCount?: true
    AceItemCount?: true
  }

  export type GameServerInfoCountAggregateInputType = {
    Number?: true
    ItemCount?: true
    ZenCount?: true
    AceItemCount?: true
    _all?: true
  }

  export type GameServerInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameServerInfo to aggregate.
     */
    where?: GameServerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameServerInfos to fetch.
     */
    orderBy?: GameServerInfoOrderByWithRelationInput | GameServerInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameServerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameServerInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameServerInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameServerInfos
    **/
    _count?: true | GameServerInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameServerInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameServerInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameServerInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameServerInfoMaxAggregateInputType
  }

  export type GetGameServerInfoAggregateType<T extends GameServerInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateGameServerInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameServerInfo[P]>
      : GetScalarType<T[P], AggregateGameServerInfo[P]>
  }




  export type GameServerInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameServerInfoWhereInput
    orderBy?: GameServerInfoOrderByWithAggregationInput | GameServerInfoOrderByWithAggregationInput[]
    by: GameServerInfoScalarFieldEnum[] | GameServerInfoScalarFieldEnum
    having?: GameServerInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameServerInfoCountAggregateInputType | true
    _avg?: GameServerInfoAvgAggregateInputType
    _sum?: GameServerInfoSumAggregateInputType
    _min?: GameServerInfoMinAggregateInputType
    _max?: GameServerInfoMaxAggregateInputType
  }

  export type GameServerInfoGroupByOutputType = {
    Number: number
    ItemCount: number
    ZenCount: number | null
    AceItemCount: number | null
    _count: GameServerInfoCountAggregateOutputType | null
    _avg: GameServerInfoAvgAggregateOutputType | null
    _sum: GameServerInfoSumAggregateOutputType | null
    _min: GameServerInfoMinAggregateOutputType | null
    _max: GameServerInfoMaxAggregateOutputType | null
  }

  type GetGameServerInfoGroupByPayload<T extends GameServerInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameServerInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameServerInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameServerInfoGroupByOutputType[P]>
            : GetScalarType<T[P], GameServerInfoGroupByOutputType[P]>
        }
      >
    >


  export type GameServerInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Number?: boolean
    ItemCount?: boolean
    ZenCount?: boolean
    AceItemCount?: boolean
  }, ExtArgs["result"]["gameServerInfo"]>

  export type GameServerInfoSelectScalar = {
    Number?: boolean
    ItemCount?: boolean
    ZenCount?: boolean
    AceItemCount?: boolean
  }


  export type $GameServerInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameServerInfo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Number: number
      ItemCount: number
      ZenCount: number | null
      AceItemCount: number | null
    }, ExtArgs["result"]["gameServerInfo"]>
    composites: {}
  }


  type GameServerInfoGetPayload<S extends boolean | null | undefined | GameServerInfoDefaultArgs> = $Result.GetResult<Prisma.$GameServerInfoPayload, S>

  type GameServerInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameServerInfoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GameServerInfoCountAggregateInputType | true
    }

  export interface GameServerInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameServerInfo'], meta: { name: 'GameServerInfo' } }
    /**
     * Find zero or one GameServerInfo that matches the filter.
     * @param {GameServerInfoFindUniqueArgs} args - Arguments to find a GameServerInfo
     * @example
     * // Get one GameServerInfo
     * const gameServerInfo = await prisma.gameServerInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GameServerInfoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GameServerInfoFindUniqueArgs<ExtArgs>>
    ): Prisma__GameServerInfoClient<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GameServerInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GameServerInfoFindUniqueOrThrowArgs} args - Arguments to find a GameServerInfo
     * @example
     * // Get one GameServerInfo
     * const gameServerInfo = await prisma.gameServerInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GameServerInfoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GameServerInfoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GameServerInfoClient<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GameServerInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerInfoFindFirstArgs} args - Arguments to find a GameServerInfo
     * @example
     * // Get one GameServerInfo
     * const gameServerInfo = await prisma.gameServerInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GameServerInfoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GameServerInfoFindFirstArgs<ExtArgs>>
    ): Prisma__GameServerInfoClient<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GameServerInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerInfoFindFirstOrThrowArgs} args - Arguments to find a GameServerInfo
     * @example
     * // Get one GameServerInfo
     * const gameServerInfo = await prisma.gameServerInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GameServerInfoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GameServerInfoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GameServerInfoClient<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GameServerInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameServerInfos
     * const gameServerInfos = await prisma.gameServerInfo.findMany()
     * 
     * // Get first 10 GameServerInfos
     * const gameServerInfos = await prisma.gameServerInfo.findMany({ take: 10 })
     * 
     * // Only select the `Number`
     * const gameServerInfoWithNumberOnly = await prisma.gameServerInfo.findMany({ select: { Number: true } })
     * 
    **/
    findMany<T extends GameServerInfoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameServerInfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GameServerInfo.
     * @param {GameServerInfoCreateArgs} args - Arguments to create a GameServerInfo.
     * @example
     * // Create one GameServerInfo
     * const GameServerInfo = await prisma.gameServerInfo.create({
     *   data: {
     *     // ... data to create a GameServerInfo
     *   }
     * })
     * 
    **/
    create<T extends GameServerInfoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GameServerInfoCreateArgs<ExtArgs>>
    ): Prisma__GameServerInfoClient<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GameServerInfos.
     *     @param {GameServerInfoCreateManyArgs} args - Arguments to create many GameServerInfos.
     *     @example
     *     // Create many GameServerInfos
     *     const gameServerInfo = await prisma.gameServerInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GameServerInfoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameServerInfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GameServerInfo.
     * @param {GameServerInfoDeleteArgs} args - Arguments to delete one GameServerInfo.
     * @example
     * // Delete one GameServerInfo
     * const GameServerInfo = await prisma.gameServerInfo.delete({
     *   where: {
     *     // ... filter to delete one GameServerInfo
     *   }
     * })
     * 
    **/
    delete<T extends GameServerInfoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GameServerInfoDeleteArgs<ExtArgs>>
    ): Prisma__GameServerInfoClient<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GameServerInfo.
     * @param {GameServerInfoUpdateArgs} args - Arguments to update one GameServerInfo.
     * @example
     * // Update one GameServerInfo
     * const gameServerInfo = await prisma.gameServerInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GameServerInfoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GameServerInfoUpdateArgs<ExtArgs>>
    ): Prisma__GameServerInfoClient<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GameServerInfos.
     * @param {GameServerInfoDeleteManyArgs} args - Arguments to filter GameServerInfos to delete.
     * @example
     * // Delete a few GameServerInfos
     * const { count } = await prisma.gameServerInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GameServerInfoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GameServerInfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameServerInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameServerInfos
     * const gameServerInfo = await prisma.gameServerInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GameServerInfoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GameServerInfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameServerInfo.
     * @param {GameServerInfoUpsertArgs} args - Arguments to update or create a GameServerInfo.
     * @example
     * // Update or create a GameServerInfo
     * const gameServerInfo = await prisma.gameServerInfo.upsert({
     *   create: {
     *     // ... data to create a GameServerInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameServerInfo we want to update
     *   }
     * })
    **/
    upsert<T extends GameServerInfoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GameServerInfoUpsertArgs<ExtArgs>>
    ): Prisma__GameServerInfoClient<$Result.GetResult<Prisma.$GameServerInfoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GameServerInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerInfoCountArgs} args - Arguments to filter GameServerInfos to count.
     * @example
     * // Count the number of GameServerInfos
     * const count = await prisma.gameServerInfo.count({
     *   where: {
     *     // ... the filter for the GameServerInfos we want to count
     *   }
     * })
    **/
    count<T extends GameServerInfoCountArgs>(
      args?: Subset<T, GameServerInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameServerInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameServerInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameServerInfoAggregateArgs>(args: Subset<T, GameServerInfoAggregateArgs>): Prisma.PrismaPromise<GetGameServerInfoAggregateType<T>>

    /**
     * Group by GameServerInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameServerInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameServerInfoGroupByArgs['orderBy'] }
        : { orderBy?: GameServerInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameServerInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameServerInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameServerInfo model
   */
  readonly fields: GameServerInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameServerInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameServerInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GameServerInfo model
   */ 
  interface GameServerInfoFieldRefs {
    readonly Number: FieldRef<"GameServerInfo", 'Int'>
    readonly ItemCount: FieldRef<"GameServerInfo", 'Int'>
    readonly ZenCount: FieldRef<"GameServerInfo", 'Int'>
    readonly AceItemCount: FieldRef<"GameServerInfo", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * GameServerInfo findUnique
   */
  export type GameServerInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * Filter, which GameServerInfo to fetch.
     */
    where: GameServerInfoWhereUniqueInput
  }


  /**
   * GameServerInfo findUniqueOrThrow
   */
  export type GameServerInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * Filter, which GameServerInfo to fetch.
     */
    where: GameServerInfoWhereUniqueInput
  }


  /**
   * GameServerInfo findFirst
   */
  export type GameServerInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * Filter, which GameServerInfo to fetch.
     */
    where?: GameServerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameServerInfos to fetch.
     */
    orderBy?: GameServerInfoOrderByWithRelationInput | GameServerInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameServerInfos.
     */
    cursor?: GameServerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameServerInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameServerInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameServerInfos.
     */
    distinct?: GameServerInfoScalarFieldEnum | GameServerInfoScalarFieldEnum[]
  }


  /**
   * GameServerInfo findFirstOrThrow
   */
  export type GameServerInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * Filter, which GameServerInfo to fetch.
     */
    where?: GameServerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameServerInfos to fetch.
     */
    orderBy?: GameServerInfoOrderByWithRelationInput | GameServerInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameServerInfos.
     */
    cursor?: GameServerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameServerInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameServerInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameServerInfos.
     */
    distinct?: GameServerInfoScalarFieldEnum | GameServerInfoScalarFieldEnum[]
  }


  /**
   * GameServerInfo findMany
   */
  export type GameServerInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * Filter, which GameServerInfos to fetch.
     */
    where?: GameServerInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameServerInfos to fetch.
     */
    orderBy?: GameServerInfoOrderByWithRelationInput | GameServerInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameServerInfos.
     */
    cursor?: GameServerInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameServerInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameServerInfos.
     */
    skip?: number
    distinct?: GameServerInfoScalarFieldEnum | GameServerInfoScalarFieldEnum[]
  }


  /**
   * GameServerInfo create
   */
  export type GameServerInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * The data needed to create a GameServerInfo.
     */
    data: XOR<GameServerInfoCreateInput, GameServerInfoUncheckedCreateInput>
  }


  /**
   * GameServerInfo createMany
   */
  export type GameServerInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameServerInfos.
     */
    data: GameServerInfoCreateManyInput | GameServerInfoCreateManyInput[]
  }


  /**
   * GameServerInfo update
   */
  export type GameServerInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * The data needed to update a GameServerInfo.
     */
    data: XOR<GameServerInfoUpdateInput, GameServerInfoUncheckedUpdateInput>
    /**
     * Choose, which GameServerInfo to update.
     */
    where: GameServerInfoWhereUniqueInput
  }


  /**
   * GameServerInfo updateMany
   */
  export type GameServerInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameServerInfos.
     */
    data: XOR<GameServerInfoUpdateManyMutationInput, GameServerInfoUncheckedUpdateManyInput>
    /**
     * Filter which GameServerInfos to update
     */
    where?: GameServerInfoWhereInput
  }


  /**
   * GameServerInfo upsert
   */
  export type GameServerInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * The filter to search for the GameServerInfo to update in case it exists.
     */
    where: GameServerInfoWhereUniqueInput
    /**
     * In case the GameServerInfo found by the `where` argument doesn't exist, create a new GameServerInfo with this data.
     */
    create: XOR<GameServerInfoCreateInput, GameServerInfoUncheckedCreateInput>
    /**
     * In case the GameServerInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameServerInfoUpdateInput, GameServerInfoUncheckedUpdateInput>
  }


  /**
   * GameServerInfo delete
   */
  export type GameServerInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
    /**
     * Filter which GameServerInfo to delete.
     */
    where: GameServerInfoWhereUniqueInput
  }


  /**
   * GameServerInfo deleteMany
   */
  export type GameServerInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameServerInfos to delete
     */
    where?: GameServerInfoWhereInput
  }


  /**
   * GameServerInfo without action
   */
  export type GameServerInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerInfo
     */
    select?: GameServerInfoSelect<ExtArgs> | null
  }



  /**
   * Model Gens_Rank
   */

  export type AggregateGens_Rank = {
    _count: Gens_RankCountAggregateOutputType | null
    _avg: Gens_RankAvgAggregateOutputType | null
    _sum: Gens_RankSumAggregateOutputType | null
    _min: Gens_RankMinAggregateOutputType | null
    _max: Gens_RankMaxAggregateOutputType | null
  }

  export type Gens_RankAvgAggregateOutputType = {
    Family: number | null
    Contribution: number | null
  }

  export type Gens_RankSumAggregateOutputType = {
    Family: number | null
    Contribution: number | null
  }

  export type Gens_RankMinAggregateOutputType = {
    Name: string | null
    Family: number | null
    Contribution: number | null
  }

  export type Gens_RankMaxAggregateOutputType = {
    Name: string | null
    Family: number | null
    Contribution: number | null
  }

  export type Gens_RankCountAggregateOutputType = {
    Name: number
    Family: number
    Contribution: number
    _all: number
  }


  export type Gens_RankAvgAggregateInputType = {
    Family?: true
    Contribution?: true
  }

  export type Gens_RankSumAggregateInputType = {
    Family?: true
    Contribution?: true
  }

  export type Gens_RankMinAggregateInputType = {
    Name?: true
    Family?: true
    Contribution?: true
  }

  export type Gens_RankMaxAggregateInputType = {
    Name?: true
    Family?: true
    Contribution?: true
  }

  export type Gens_RankCountAggregateInputType = {
    Name?: true
    Family?: true
    Contribution?: true
    _all?: true
  }

  export type Gens_RankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gens_Rank to aggregate.
     */
    where?: Gens_RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gens_Ranks to fetch.
     */
    orderBy?: Gens_RankOrderByWithRelationInput | Gens_RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gens_RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gens_Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gens_Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gens_Ranks
    **/
    _count?: true | Gens_RankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gens_RankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gens_RankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gens_RankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gens_RankMaxAggregateInputType
  }

  export type GetGens_RankAggregateType<T extends Gens_RankAggregateArgs> = {
        [P in keyof T & keyof AggregateGens_Rank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGens_Rank[P]>
      : GetScalarType<T[P], AggregateGens_Rank[P]>
  }




  export type Gens_RankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Gens_RankWhereInput
    orderBy?: Gens_RankOrderByWithAggregationInput | Gens_RankOrderByWithAggregationInput[]
    by: Gens_RankScalarFieldEnum[] | Gens_RankScalarFieldEnum
    having?: Gens_RankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gens_RankCountAggregateInputType | true
    _avg?: Gens_RankAvgAggregateInputType
    _sum?: Gens_RankSumAggregateInputType
    _min?: Gens_RankMinAggregateInputType
    _max?: Gens_RankMaxAggregateInputType
  }

  export type Gens_RankGroupByOutputType = {
    Name: string
    Family: number | null
    Contribution: number | null
    _count: Gens_RankCountAggregateOutputType | null
    _avg: Gens_RankAvgAggregateOutputType | null
    _sum: Gens_RankSumAggregateOutputType | null
    _min: Gens_RankMinAggregateOutputType | null
    _max: Gens_RankMaxAggregateOutputType | null
  }

  type GetGens_RankGroupByPayload<T extends Gens_RankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gens_RankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gens_RankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gens_RankGroupByOutputType[P]>
            : GetScalarType<T[P], Gens_RankGroupByOutputType[P]>
        }
      >
    >


  export type Gens_RankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Family?: boolean
    Contribution?: boolean
  }, ExtArgs["result"]["gens_Rank"]>

  export type Gens_RankSelectScalar = {
    Name?: boolean
    Family?: boolean
    Contribution?: boolean
  }


  export type $Gens_RankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gens_Rank"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Family: number | null
      Contribution: number | null
    }, ExtArgs["result"]["gens_Rank"]>
    composites: {}
  }


  type Gens_RankGetPayload<S extends boolean | null | undefined | Gens_RankDefaultArgs> = $Result.GetResult<Prisma.$Gens_RankPayload, S>

  type Gens_RankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Gens_RankFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Gens_RankCountAggregateInputType | true
    }

  export interface Gens_RankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gens_Rank'], meta: { name: 'Gens_Rank' } }
    /**
     * Find zero or one Gens_Rank that matches the filter.
     * @param {Gens_RankFindUniqueArgs} args - Arguments to find a Gens_Rank
     * @example
     * // Get one Gens_Rank
     * const gens_Rank = await prisma.gens_Rank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Gens_RankFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RankFindUniqueArgs<ExtArgs>>
    ): Prisma__Gens_RankClient<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Gens_Rank that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Gens_RankFindUniqueOrThrowArgs} args - Arguments to find a Gens_Rank
     * @example
     * // Get one Gens_Rank
     * const gens_Rank = await prisma.gens_Rank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Gens_RankFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RankFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Gens_RankClient<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Gens_Rank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RankFindFirstArgs} args - Arguments to find a Gens_Rank
     * @example
     * // Get one Gens_Rank
     * const gens_Rank = await prisma.gens_Rank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Gens_RankFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RankFindFirstArgs<ExtArgs>>
    ): Prisma__Gens_RankClient<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Gens_Rank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RankFindFirstOrThrowArgs} args - Arguments to find a Gens_Rank
     * @example
     * // Get one Gens_Rank
     * const gens_Rank = await prisma.gens_Rank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Gens_RankFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RankFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Gens_RankClient<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Gens_Ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RankFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gens_Ranks
     * const gens_Ranks = await prisma.gens_Rank.findMany()
     * 
     * // Get first 10 Gens_Ranks
     * const gens_Ranks = await prisma.gens_Rank.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const gens_RankWithNameOnly = await prisma.gens_Rank.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends Gens_RankFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RankFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Gens_Rank.
     * @param {Gens_RankCreateArgs} args - Arguments to create a Gens_Rank.
     * @example
     * // Create one Gens_Rank
     * const Gens_Rank = await prisma.gens_Rank.create({
     *   data: {
     *     // ... data to create a Gens_Rank
     *   }
     * })
     * 
    **/
    create<T extends Gens_RankCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RankCreateArgs<ExtArgs>>
    ): Prisma__Gens_RankClient<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Gens_Ranks.
     *     @param {Gens_RankCreateManyArgs} args - Arguments to create many Gens_Ranks.
     *     @example
     *     // Create many Gens_Ranks
     *     const gens_Rank = await prisma.gens_Rank.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Gens_RankCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RankCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gens_Rank.
     * @param {Gens_RankDeleteArgs} args - Arguments to delete one Gens_Rank.
     * @example
     * // Delete one Gens_Rank
     * const Gens_Rank = await prisma.gens_Rank.delete({
     *   where: {
     *     // ... filter to delete one Gens_Rank
     *   }
     * })
     * 
    **/
    delete<T extends Gens_RankDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RankDeleteArgs<ExtArgs>>
    ): Prisma__Gens_RankClient<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Gens_Rank.
     * @param {Gens_RankUpdateArgs} args - Arguments to update one Gens_Rank.
     * @example
     * // Update one Gens_Rank
     * const gens_Rank = await prisma.gens_Rank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Gens_RankUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RankUpdateArgs<ExtArgs>>
    ): Prisma__Gens_RankClient<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Gens_Ranks.
     * @param {Gens_RankDeleteManyArgs} args - Arguments to filter Gens_Ranks to delete.
     * @example
     * // Delete a few Gens_Ranks
     * const { count } = await prisma.gens_Rank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Gens_RankDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RankDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gens_Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gens_Ranks
     * const gens_Rank = await prisma.gens_Rank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Gens_RankUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RankUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gens_Rank.
     * @param {Gens_RankUpsertArgs} args - Arguments to update or create a Gens_Rank.
     * @example
     * // Update or create a Gens_Rank
     * const gens_Rank = await prisma.gens_Rank.upsert({
     *   create: {
     *     // ... data to create a Gens_Rank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gens_Rank we want to update
     *   }
     * })
    **/
    upsert<T extends Gens_RankUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RankUpsertArgs<ExtArgs>>
    ): Prisma__Gens_RankClient<$Result.GetResult<Prisma.$Gens_RankPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Gens_Ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RankCountArgs} args - Arguments to filter Gens_Ranks to count.
     * @example
     * // Count the number of Gens_Ranks
     * const count = await prisma.gens_Rank.count({
     *   where: {
     *     // ... the filter for the Gens_Ranks we want to count
     *   }
     * })
    **/
    count<T extends Gens_RankCountArgs>(
      args?: Subset<T, Gens_RankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gens_RankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gens_Rank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gens_RankAggregateArgs>(args: Subset<T, Gens_RankAggregateArgs>): Prisma.PrismaPromise<GetGens_RankAggregateType<T>>

    /**
     * Group by Gens_Rank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gens_RankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gens_RankGroupByArgs['orderBy'] }
        : { orderBy?: Gens_RankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gens_RankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGens_RankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gens_Rank model
   */
  readonly fields: Gens_RankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gens_Rank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Gens_RankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Gens_Rank model
   */ 
  interface Gens_RankFieldRefs {
    readonly Name: FieldRef<"Gens_Rank", 'String'>
    readonly Family: FieldRef<"Gens_Rank", 'Int'>
    readonly Contribution: FieldRef<"Gens_Rank", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Gens_Rank findUnique
   */
  export type Gens_RankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Rank to fetch.
     */
    where: Gens_RankWhereUniqueInput
  }


  /**
   * Gens_Rank findUniqueOrThrow
   */
  export type Gens_RankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Rank to fetch.
     */
    where: Gens_RankWhereUniqueInput
  }


  /**
   * Gens_Rank findFirst
   */
  export type Gens_RankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Rank to fetch.
     */
    where?: Gens_RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gens_Ranks to fetch.
     */
    orderBy?: Gens_RankOrderByWithRelationInput | Gens_RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gens_Ranks.
     */
    cursor?: Gens_RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gens_Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gens_Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gens_Ranks.
     */
    distinct?: Gens_RankScalarFieldEnum | Gens_RankScalarFieldEnum[]
  }


  /**
   * Gens_Rank findFirstOrThrow
   */
  export type Gens_RankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Rank to fetch.
     */
    where?: Gens_RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gens_Ranks to fetch.
     */
    orderBy?: Gens_RankOrderByWithRelationInput | Gens_RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gens_Ranks.
     */
    cursor?: Gens_RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gens_Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gens_Ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gens_Ranks.
     */
    distinct?: Gens_RankScalarFieldEnum | Gens_RankScalarFieldEnum[]
  }


  /**
   * Gens_Rank findMany
   */
  export type Gens_RankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Ranks to fetch.
     */
    where?: Gens_RankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gens_Ranks to fetch.
     */
    orderBy?: Gens_RankOrderByWithRelationInput | Gens_RankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gens_Ranks.
     */
    cursor?: Gens_RankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gens_Ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gens_Ranks.
     */
    skip?: number
    distinct?: Gens_RankScalarFieldEnum | Gens_RankScalarFieldEnum[]
  }


  /**
   * Gens_Rank create
   */
  export type Gens_RankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * The data needed to create a Gens_Rank.
     */
    data: XOR<Gens_RankCreateInput, Gens_RankUncheckedCreateInput>
  }


  /**
   * Gens_Rank createMany
   */
  export type Gens_RankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gens_Ranks.
     */
    data: Gens_RankCreateManyInput | Gens_RankCreateManyInput[]
  }


  /**
   * Gens_Rank update
   */
  export type Gens_RankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * The data needed to update a Gens_Rank.
     */
    data: XOR<Gens_RankUpdateInput, Gens_RankUncheckedUpdateInput>
    /**
     * Choose, which Gens_Rank to update.
     */
    where: Gens_RankWhereUniqueInput
  }


  /**
   * Gens_Rank updateMany
   */
  export type Gens_RankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gens_Ranks.
     */
    data: XOR<Gens_RankUpdateManyMutationInput, Gens_RankUncheckedUpdateManyInput>
    /**
     * Filter which Gens_Ranks to update
     */
    where?: Gens_RankWhereInput
  }


  /**
   * Gens_Rank upsert
   */
  export type Gens_RankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * The filter to search for the Gens_Rank to update in case it exists.
     */
    where: Gens_RankWhereUniqueInput
    /**
     * In case the Gens_Rank found by the `where` argument doesn't exist, create a new Gens_Rank with this data.
     */
    create: XOR<Gens_RankCreateInput, Gens_RankUncheckedCreateInput>
    /**
     * In case the Gens_Rank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gens_RankUpdateInput, Gens_RankUncheckedUpdateInput>
  }


  /**
   * Gens_Rank delete
   */
  export type Gens_RankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
    /**
     * Filter which Gens_Rank to delete.
     */
    where: Gens_RankWhereUniqueInput
  }


  /**
   * Gens_Rank deleteMany
   */
  export type Gens_RankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gens_Ranks to delete
     */
    where?: Gens_RankWhereInput
  }


  /**
   * Gens_Rank without action
   */
  export type Gens_RankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Rank
     */
    select?: Gens_RankSelect<ExtArgs> | null
  }



  /**
   * Model Gens_Reward
   */

  export type AggregateGens_Reward = {
    _count: Gens_RewardCountAggregateOutputType | null
    _avg: Gens_RewardAvgAggregateOutputType | null
    _sum: Gens_RewardSumAggregateOutputType | null
    _min: Gens_RewardMinAggregateOutputType | null
    _max: Gens_RewardMaxAggregateOutputType | null
  }

  export type Gens_RewardAvgAggregateOutputType = {
    Rank: number | null
    Status: number | null
  }

  export type Gens_RewardSumAggregateOutputType = {
    Rank: number | null
    Status: number | null
  }

  export type Gens_RewardMinAggregateOutputType = {
    Name: string | null
    Rank: number | null
    Status: number | null
  }

  export type Gens_RewardMaxAggregateOutputType = {
    Name: string | null
    Rank: number | null
    Status: number | null
  }

  export type Gens_RewardCountAggregateOutputType = {
    Name: number
    Rank: number
    Status: number
    _all: number
  }


  export type Gens_RewardAvgAggregateInputType = {
    Rank?: true
    Status?: true
  }

  export type Gens_RewardSumAggregateInputType = {
    Rank?: true
    Status?: true
  }

  export type Gens_RewardMinAggregateInputType = {
    Name?: true
    Rank?: true
    Status?: true
  }

  export type Gens_RewardMaxAggregateInputType = {
    Name?: true
    Rank?: true
    Status?: true
  }

  export type Gens_RewardCountAggregateInputType = {
    Name?: true
    Rank?: true
    Status?: true
    _all?: true
  }

  export type Gens_RewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gens_Reward to aggregate.
     */
    where?: Gens_RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gens_Rewards to fetch.
     */
    orderBy?: Gens_RewardOrderByWithRelationInput | Gens_RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Gens_RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gens_Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gens_Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gens_Rewards
    **/
    _count?: true | Gens_RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gens_RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gens_RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gens_RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gens_RewardMaxAggregateInputType
  }

  export type GetGens_RewardAggregateType<T extends Gens_RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateGens_Reward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGens_Reward[P]>
      : GetScalarType<T[P], AggregateGens_Reward[P]>
  }




  export type Gens_RewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Gens_RewardWhereInput
    orderBy?: Gens_RewardOrderByWithAggregationInput | Gens_RewardOrderByWithAggregationInput[]
    by: Gens_RewardScalarFieldEnum[] | Gens_RewardScalarFieldEnum
    having?: Gens_RewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gens_RewardCountAggregateInputType | true
    _avg?: Gens_RewardAvgAggregateInputType
    _sum?: Gens_RewardSumAggregateInputType
    _min?: Gens_RewardMinAggregateInputType
    _max?: Gens_RewardMaxAggregateInputType
  }

  export type Gens_RewardGroupByOutputType = {
    Name: string
    Rank: number | null
    Status: number | null
    _count: Gens_RewardCountAggregateOutputType | null
    _avg: Gens_RewardAvgAggregateOutputType | null
    _sum: Gens_RewardSumAggregateOutputType | null
    _min: Gens_RewardMinAggregateOutputType | null
    _max: Gens_RewardMaxAggregateOutputType | null
  }

  type GetGens_RewardGroupByPayload<T extends Gens_RewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gens_RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gens_RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gens_RewardGroupByOutputType[P]>
            : GetScalarType<T[P], Gens_RewardGroupByOutputType[P]>
        }
      >
    >


  export type Gens_RewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Rank?: boolean
    Status?: boolean
  }, ExtArgs["result"]["gens_Reward"]>

  export type Gens_RewardSelectScalar = {
    Name?: boolean
    Rank?: boolean
    Status?: boolean
  }


  export type $Gens_RewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gens_Reward"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Rank: number | null
      Status: number | null
    }, ExtArgs["result"]["gens_Reward"]>
    composites: {}
  }


  type Gens_RewardGetPayload<S extends boolean | null | undefined | Gens_RewardDefaultArgs> = $Result.GetResult<Prisma.$Gens_RewardPayload, S>

  type Gens_RewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Gens_RewardFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Gens_RewardCountAggregateInputType | true
    }

  export interface Gens_RewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gens_Reward'], meta: { name: 'Gens_Reward' } }
    /**
     * Find zero or one Gens_Reward that matches the filter.
     * @param {Gens_RewardFindUniqueArgs} args - Arguments to find a Gens_Reward
     * @example
     * // Get one Gens_Reward
     * const gens_Reward = await prisma.gens_Reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Gens_RewardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RewardFindUniqueArgs<ExtArgs>>
    ): Prisma__Gens_RewardClient<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Gens_Reward that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Gens_RewardFindUniqueOrThrowArgs} args - Arguments to find a Gens_Reward
     * @example
     * // Get one Gens_Reward
     * const gens_Reward = await prisma.gens_Reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Gens_RewardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RewardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Gens_RewardClient<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Gens_Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RewardFindFirstArgs} args - Arguments to find a Gens_Reward
     * @example
     * // Get one Gens_Reward
     * const gens_Reward = await prisma.gens_Reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Gens_RewardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RewardFindFirstArgs<ExtArgs>>
    ): Prisma__Gens_RewardClient<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Gens_Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RewardFindFirstOrThrowArgs} args - Arguments to find a Gens_Reward
     * @example
     * // Get one Gens_Reward
     * const gens_Reward = await prisma.gens_Reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Gens_RewardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RewardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Gens_RewardClient<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Gens_Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RewardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gens_Rewards
     * const gens_Rewards = await prisma.gens_Reward.findMany()
     * 
     * // Get first 10 Gens_Rewards
     * const gens_Rewards = await prisma.gens_Reward.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const gens_RewardWithNameOnly = await prisma.gens_Reward.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends Gens_RewardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RewardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Gens_Reward.
     * @param {Gens_RewardCreateArgs} args - Arguments to create a Gens_Reward.
     * @example
     * // Create one Gens_Reward
     * const Gens_Reward = await prisma.gens_Reward.create({
     *   data: {
     *     // ... data to create a Gens_Reward
     *   }
     * })
     * 
    **/
    create<T extends Gens_RewardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RewardCreateArgs<ExtArgs>>
    ): Prisma__Gens_RewardClient<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Gens_Rewards.
     *     @param {Gens_RewardCreateManyArgs} args - Arguments to create many Gens_Rewards.
     *     @example
     *     // Create many Gens_Rewards
     *     const gens_Reward = await prisma.gens_Reward.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Gens_RewardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RewardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gens_Reward.
     * @param {Gens_RewardDeleteArgs} args - Arguments to delete one Gens_Reward.
     * @example
     * // Delete one Gens_Reward
     * const Gens_Reward = await prisma.gens_Reward.delete({
     *   where: {
     *     // ... filter to delete one Gens_Reward
     *   }
     * })
     * 
    **/
    delete<T extends Gens_RewardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RewardDeleteArgs<ExtArgs>>
    ): Prisma__Gens_RewardClient<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Gens_Reward.
     * @param {Gens_RewardUpdateArgs} args - Arguments to update one Gens_Reward.
     * @example
     * // Update one Gens_Reward
     * const gens_Reward = await prisma.gens_Reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Gens_RewardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RewardUpdateArgs<ExtArgs>>
    ): Prisma__Gens_RewardClient<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Gens_Rewards.
     * @param {Gens_RewardDeleteManyArgs} args - Arguments to filter Gens_Rewards to delete.
     * @example
     * // Delete a few Gens_Rewards
     * const { count } = await prisma.gens_Reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Gens_RewardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Gens_RewardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gens_Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gens_Rewards
     * const gens_Reward = await prisma.gens_Reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Gens_RewardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RewardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gens_Reward.
     * @param {Gens_RewardUpsertArgs} args - Arguments to update or create a Gens_Reward.
     * @example
     * // Update or create a Gens_Reward
     * const gens_Reward = await prisma.gens_Reward.upsert({
     *   create: {
     *     // ... data to create a Gens_Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gens_Reward we want to update
     *   }
     * })
    **/
    upsert<T extends Gens_RewardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Gens_RewardUpsertArgs<ExtArgs>>
    ): Prisma__Gens_RewardClient<$Result.GetResult<Prisma.$Gens_RewardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Gens_Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RewardCountArgs} args - Arguments to filter Gens_Rewards to count.
     * @example
     * // Count the number of Gens_Rewards
     * const count = await prisma.gens_Reward.count({
     *   where: {
     *     // ... the filter for the Gens_Rewards we want to count
     *   }
     * })
    **/
    count<T extends Gens_RewardCountArgs>(
      args?: Subset<T, Gens_RewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gens_RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gens_Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gens_RewardAggregateArgs>(args: Subset<T, Gens_RewardAggregateArgs>): Prisma.PrismaPromise<GetGens_RewardAggregateType<T>>

    /**
     * Group by Gens_Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gens_RewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Gens_RewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Gens_RewardGroupByArgs['orderBy'] }
        : { orderBy?: Gens_RewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Gens_RewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGens_RewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gens_Reward model
   */
  readonly fields: Gens_RewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gens_Reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Gens_RewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Gens_Reward model
   */ 
  interface Gens_RewardFieldRefs {
    readonly Name: FieldRef<"Gens_Reward", 'String'>
    readonly Rank: FieldRef<"Gens_Reward", 'Int'>
    readonly Status: FieldRef<"Gens_Reward", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Gens_Reward findUnique
   */
  export type Gens_RewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Reward to fetch.
     */
    where: Gens_RewardWhereUniqueInput
  }


  /**
   * Gens_Reward findUniqueOrThrow
   */
  export type Gens_RewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Reward to fetch.
     */
    where: Gens_RewardWhereUniqueInput
  }


  /**
   * Gens_Reward findFirst
   */
  export type Gens_RewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Reward to fetch.
     */
    where?: Gens_RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gens_Rewards to fetch.
     */
    orderBy?: Gens_RewardOrderByWithRelationInput | Gens_RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gens_Rewards.
     */
    cursor?: Gens_RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gens_Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gens_Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gens_Rewards.
     */
    distinct?: Gens_RewardScalarFieldEnum | Gens_RewardScalarFieldEnum[]
  }


  /**
   * Gens_Reward findFirstOrThrow
   */
  export type Gens_RewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Reward to fetch.
     */
    where?: Gens_RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gens_Rewards to fetch.
     */
    orderBy?: Gens_RewardOrderByWithRelationInput | Gens_RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gens_Rewards.
     */
    cursor?: Gens_RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gens_Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gens_Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gens_Rewards.
     */
    distinct?: Gens_RewardScalarFieldEnum | Gens_RewardScalarFieldEnum[]
  }


  /**
   * Gens_Reward findMany
   */
  export type Gens_RewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * Filter, which Gens_Rewards to fetch.
     */
    where?: Gens_RewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gens_Rewards to fetch.
     */
    orderBy?: Gens_RewardOrderByWithRelationInput | Gens_RewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gens_Rewards.
     */
    cursor?: Gens_RewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gens_Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gens_Rewards.
     */
    skip?: number
    distinct?: Gens_RewardScalarFieldEnum | Gens_RewardScalarFieldEnum[]
  }


  /**
   * Gens_Reward create
   */
  export type Gens_RewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * The data needed to create a Gens_Reward.
     */
    data: XOR<Gens_RewardCreateInput, Gens_RewardUncheckedCreateInput>
  }


  /**
   * Gens_Reward createMany
   */
  export type Gens_RewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gens_Rewards.
     */
    data: Gens_RewardCreateManyInput | Gens_RewardCreateManyInput[]
  }


  /**
   * Gens_Reward update
   */
  export type Gens_RewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * The data needed to update a Gens_Reward.
     */
    data: XOR<Gens_RewardUpdateInput, Gens_RewardUncheckedUpdateInput>
    /**
     * Choose, which Gens_Reward to update.
     */
    where: Gens_RewardWhereUniqueInput
  }


  /**
   * Gens_Reward updateMany
   */
  export type Gens_RewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gens_Rewards.
     */
    data: XOR<Gens_RewardUpdateManyMutationInput, Gens_RewardUncheckedUpdateManyInput>
    /**
     * Filter which Gens_Rewards to update
     */
    where?: Gens_RewardWhereInput
  }


  /**
   * Gens_Reward upsert
   */
  export type Gens_RewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * The filter to search for the Gens_Reward to update in case it exists.
     */
    where: Gens_RewardWhereUniqueInput
    /**
     * In case the Gens_Reward found by the `where` argument doesn't exist, create a new Gens_Reward with this data.
     */
    create: XOR<Gens_RewardCreateInput, Gens_RewardUncheckedCreateInput>
    /**
     * In case the Gens_Reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Gens_RewardUpdateInput, Gens_RewardUncheckedUpdateInput>
  }


  /**
   * Gens_Reward delete
   */
  export type Gens_RewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
    /**
     * Filter which Gens_Reward to delete.
     */
    where: Gens_RewardWhereUniqueInput
  }


  /**
   * Gens_Reward deleteMany
   */
  export type Gens_RewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gens_Rewards to delete
     */
    where?: Gens_RewardWhereInput
  }


  /**
   * Gens_Reward without action
   */
  export type Gens_RewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gens_Reward
     */
    select?: Gens_RewardSelect<ExtArgs> | null
  }



  /**
   * Model Guild
   */

  export type AggregateGuild = {
    _count: GuildCountAggregateOutputType | null
    _avg: GuildAvgAggregateOutputType | null
    _sum: GuildSumAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  export type GuildAvgAggregateOutputType = {
    G_Score: number | null
    G_Count: number | null
    Number: number | null
    G_Type: number | null
    G_Rival: number | null
    G_Union: number | null
    MemberCount: number | null
  }

  export type GuildSumAggregateOutputType = {
    G_Score: number | null
    G_Count: number | null
    Number: number | null
    G_Type: number | null
    G_Rival: number | null
    G_Union: number | null
    MemberCount: number | null
  }

  export type GuildMinAggregateOutputType = {
    G_Name: string | null
    G_Mark: Buffer | null
    G_Score: number | null
    G_Master: string | null
    G_Count: number | null
    G_Notice: string | null
    Number: number | null
    G_Type: number | null
    G_Rival: number | null
    G_Union: number | null
    MemberCount: number | null
  }

  export type GuildMaxAggregateOutputType = {
    G_Name: string | null
    G_Mark: Buffer | null
    G_Score: number | null
    G_Master: string | null
    G_Count: number | null
    G_Notice: string | null
    Number: number | null
    G_Type: number | null
    G_Rival: number | null
    G_Union: number | null
    MemberCount: number | null
  }

  export type GuildCountAggregateOutputType = {
    G_Name: number
    G_Mark: number
    G_Score: number
    G_Master: number
    G_Count: number
    G_Notice: number
    Number: number
    G_Type: number
    G_Rival: number
    G_Union: number
    MemberCount: number
    _all: number
  }


  export type GuildAvgAggregateInputType = {
    G_Score?: true
    G_Count?: true
    Number?: true
    G_Type?: true
    G_Rival?: true
    G_Union?: true
    MemberCount?: true
  }

  export type GuildSumAggregateInputType = {
    G_Score?: true
    G_Count?: true
    Number?: true
    G_Type?: true
    G_Rival?: true
    G_Union?: true
    MemberCount?: true
  }

  export type GuildMinAggregateInputType = {
    G_Name?: true
    G_Mark?: true
    G_Score?: true
    G_Master?: true
    G_Count?: true
    G_Notice?: true
    Number?: true
    G_Type?: true
    G_Rival?: true
    G_Union?: true
    MemberCount?: true
  }

  export type GuildMaxAggregateInputType = {
    G_Name?: true
    G_Mark?: true
    G_Score?: true
    G_Master?: true
    G_Count?: true
    G_Notice?: true
    Number?: true
    G_Type?: true
    G_Rival?: true
    G_Union?: true
    MemberCount?: true
  }

  export type GuildCountAggregateInputType = {
    G_Name?: true
    G_Mark?: true
    G_Score?: true
    G_Master?: true
    G_Count?: true
    G_Notice?: true
    Number?: true
    G_Type?: true
    G_Rival?: true
    G_Union?: true
    MemberCount?: true
    _all?: true
  }

  export type GuildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guild to aggregate.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guilds
    **/
    _count?: true | GuildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildMaxAggregateInputType
  }

  export type GetGuildAggregateType<T extends GuildAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild[P]>
      : GetScalarType<T[P], AggregateGuild[P]>
  }




  export type GuildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildWhereInput
    orderBy?: GuildOrderByWithAggregationInput | GuildOrderByWithAggregationInput[]
    by: GuildScalarFieldEnum[] | GuildScalarFieldEnum
    having?: GuildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildCountAggregateInputType | true
    _avg?: GuildAvgAggregateInputType
    _sum?: GuildSumAggregateInputType
    _min?: GuildMinAggregateInputType
    _max?: GuildMaxAggregateInputType
  }

  export type GuildGroupByOutputType = {
    G_Name: string
    G_Mark: Buffer | null
    G_Score: number | null
    G_Master: string | null
    G_Count: number | null
    G_Notice: string | null
    Number: number
    G_Type: number
    G_Rival: number
    G_Union: number
    MemberCount: number | null
    _count: GuildCountAggregateOutputType | null
    _avg: GuildAvgAggregateOutputType | null
    _sum: GuildSumAggregateOutputType | null
    _min: GuildMinAggregateOutputType | null
    _max: GuildMaxAggregateOutputType | null
  }

  type GetGuildGroupByPayload<T extends GuildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildGroupByOutputType[P]>
            : GetScalarType<T[P], GuildGroupByOutputType[P]>
        }
      >
    >


  export type GuildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    G_Name?: boolean
    G_Mark?: boolean
    G_Score?: boolean
    G_Master?: boolean
    G_Count?: boolean
    G_Notice?: boolean
    Number?: boolean
    G_Type?: boolean
    G_Rival?: boolean
    G_Union?: boolean
    MemberCount?: boolean
  }, ExtArgs["result"]["guild"]>

  export type GuildSelectScalar = {
    G_Name?: boolean
    G_Mark?: boolean
    G_Score?: boolean
    G_Master?: boolean
    G_Count?: boolean
    G_Notice?: boolean
    Number?: boolean
    G_Type?: boolean
    G_Rival?: boolean
    G_Union?: boolean
    MemberCount?: boolean
  }


  export type $GuildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guild"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      G_Name: string
      G_Mark: Buffer | null
      G_Score: number | null
      G_Master: string | null
      G_Count: number | null
      G_Notice: string | null
      Number: number
      G_Type: number
      G_Rival: number
      G_Union: number
      MemberCount: number | null
    }, ExtArgs["result"]["guild"]>
    composites: {}
  }


  type GuildGetPayload<S extends boolean | null | undefined | GuildDefaultArgs> = $Result.GetResult<Prisma.$GuildPayload, S>

  type GuildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GuildCountAggregateInputType | true
    }

  export interface GuildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guild'], meta: { name: 'Guild' } }
    /**
     * Find zero or one Guild that matches the filter.
     * @param {GuildFindUniqueArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuildFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GuildFindUniqueArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Guild that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GuildFindUniqueOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GuildFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Guild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindFirstArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuildFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildFindFirstArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Guild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindFirstOrThrowArgs} args - Arguments to find a Guild
     * @example
     * // Get one Guild
     * const guild = await prisma.guild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GuildFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guild.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guild.findMany({ take: 10 })
     * 
     * // Only select the `G_Name`
     * const guildWithG_NameOnly = await prisma.guild.findMany({ select: { G_Name: true } })
     * 
    **/
    findMany<T extends GuildFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Guild.
     * @param {GuildCreateArgs} args - Arguments to create a Guild.
     * @example
     * // Create one Guild
     * const Guild = await prisma.guild.create({
     *   data: {
     *     // ... data to create a Guild
     *   }
     * })
     * 
    **/
    create<T extends GuildCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildCreateArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Guilds.
     *     @param {GuildCreateManyArgs} args - Arguments to create many Guilds.
     *     @example
     *     // Create many Guilds
     *     const guild = await prisma.guild.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuildCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guild.
     * @param {GuildDeleteArgs} args - Arguments to delete one Guild.
     * @example
     * // Delete one Guild
     * const Guild = await prisma.guild.delete({
     *   where: {
     *     // ... filter to delete one Guild
     *   }
     * })
     * 
    **/
    delete<T extends GuildDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GuildDeleteArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Guild.
     * @param {GuildUpdateArgs} args - Arguments to update one Guild.
     * @example
     * // Update one Guild
     * const guild = await prisma.guild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuildUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildUpdateArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Guilds.
     * @param {GuildDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuildDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guild = await prisma.guild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuildUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GuildUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild.
     * @param {GuildUpsertArgs} args - Arguments to update or create a Guild.
     * @example
     * // Update or create a Guild
     * const guild = await prisma.guild.upsert({
     *   create: {
     *     // ... data to create a Guild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild we want to update
     *   }
     * })
    **/
    upsert<T extends GuildUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GuildUpsertArgs<ExtArgs>>
    ): Prisma__GuildClient<$Result.GetResult<Prisma.$GuildPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guild.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends GuildCountArgs>(
      args?: Subset<T, GuildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildAggregateArgs>(args: Subset<T, GuildAggregateArgs>): Prisma.PrismaPromise<GetGuildAggregateType<T>>

    /**
     * Group by Guild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildGroupByArgs['orderBy'] }
        : { orderBy?: GuildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guild model
   */
  readonly fields: GuildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Guild model
   */ 
  interface GuildFieldRefs {
    readonly G_Name: FieldRef<"Guild", 'String'>
    readonly G_Mark: FieldRef<"Guild", 'Bytes'>
    readonly G_Score: FieldRef<"Guild", 'Int'>
    readonly G_Master: FieldRef<"Guild", 'String'>
    readonly G_Count: FieldRef<"Guild", 'Int'>
    readonly G_Notice: FieldRef<"Guild", 'String'>
    readonly Number: FieldRef<"Guild", 'Int'>
    readonly G_Type: FieldRef<"Guild", 'Int'>
    readonly G_Rival: FieldRef<"Guild", 'Int'>
    readonly G_Union: FieldRef<"Guild", 'Int'>
    readonly MemberCount: FieldRef<"Guild", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Guild findUnique
   */
  export type GuildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where: GuildWhereUniqueInput
  }


  /**
   * Guild findUniqueOrThrow
   */
  export type GuildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where: GuildWhereUniqueInput
  }


  /**
   * Guild findFirst
   */
  export type GuildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     */
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }


  /**
   * Guild findFirstOrThrow
   */
  export type GuildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guild to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guilds.
     */
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }


  /**
   * Guild findMany
   */
  export type GuildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter, which Guilds to fetch.
     */
    where?: GuildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guilds to fetch.
     */
    orderBy?: GuildOrderByWithRelationInput | GuildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guilds.
     */
    cursor?: GuildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guilds.
     */
    skip?: number
    distinct?: GuildScalarFieldEnum | GuildScalarFieldEnum[]
  }


  /**
   * Guild create
   */
  export type GuildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * The data needed to create a Guild.
     */
    data: XOR<GuildCreateInput, GuildUncheckedCreateInput>
  }


  /**
   * Guild createMany
   */
  export type GuildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guilds.
     */
    data: GuildCreateManyInput | GuildCreateManyInput[]
  }


  /**
   * Guild update
   */
  export type GuildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * The data needed to update a Guild.
     */
    data: XOR<GuildUpdateInput, GuildUncheckedUpdateInput>
    /**
     * Choose, which Guild to update.
     */
    where: GuildWhereUniqueInput
  }


  /**
   * Guild updateMany
   */
  export type GuildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guilds.
     */
    data: XOR<GuildUpdateManyMutationInput, GuildUncheckedUpdateManyInput>
    /**
     * Filter which Guilds to update
     */
    where?: GuildWhereInput
  }


  /**
   * Guild upsert
   */
  export type GuildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * The filter to search for the Guild to update in case it exists.
     */
    where: GuildWhereUniqueInput
    /**
     * In case the Guild found by the `where` argument doesn't exist, create a new Guild with this data.
     */
    create: XOR<GuildCreateInput, GuildUncheckedCreateInput>
    /**
     * In case the Guild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildUpdateInput, GuildUncheckedUpdateInput>
  }


  /**
   * Guild delete
   */
  export type GuildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
    /**
     * Filter which Guild to delete.
     */
    where: GuildWhereUniqueInput
  }


  /**
   * Guild deleteMany
   */
  export type GuildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guilds to delete
     */
    where?: GuildWhereInput
  }


  /**
   * Guild without action
   */
  export type GuildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild
     */
    select?: GuildSelect<ExtArgs> | null
  }



  /**
   * Model GuildMember
   */

  export type AggregateGuildMember = {
    _count: GuildMemberCountAggregateOutputType | null
    _avg: GuildMemberAvgAggregateOutputType | null
    _sum: GuildMemberSumAggregateOutputType | null
    _min: GuildMemberMinAggregateOutputType | null
    _max: GuildMemberMaxAggregateOutputType | null
  }

  export type GuildMemberAvgAggregateOutputType = {
    G_Level: number | null
    G_Status: number | null
  }

  export type GuildMemberSumAggregateOutputType = {
    G_Level: number | null
    G_Status: number | null
  }

  export type GuildMemberMinAggregateOutputType = {
    Name: string | null
    G_Name: string | null
    G_Level: number | null
    G_Status: number | null
  }

  export type GuildMemberMaxAggregateOutputType = {
    Name: string | null
    G_Name: string | null
    G_Level: number | null
    G_Status: number | null
  }

  export type GuildMemberCountAggregateOutputType = {
    Name: number
    G_Name: number
    G_Level: number
    G_Status: number
    _all: number
  }


  export type GuildMemberAvgAggregateInputType = {
    G_Level?: true
    G_Status?: true
  }

  export type GuildMemberSumAggregateInputType = {
    G_Level?: true
    G_Status?: true
  }

  export type GuildMemberMinAggregateInputType = {
    Name?: true
    G_Name?: true
    G_Level?: true
    G_Status?: true
  }

  export type GuildMemberMaxAggregateInputType = {
    Name?: true
    G_Name?: true
    G_Level?: true
    G_Status?: true
  }

  export type GuildMemberCountAggregateInputType = {
    Name?: true
    G_Name?: true
    G_Level?: true
    G_Status?: true
    _all?: true
  }

  export type GuildMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildMember to aggregate.
     */
    where?: GuildMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMembers to fetch.
     */
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuildMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuildMembers
    **/
    _count?: true | GuildMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildMemberMaxAggregateInputType
  }

  export type GetGuildMemberAggregateType<T extends GuildMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildMember[P]>
      : GetScalarType<T[P], AggregateGuildMember[P]>
  }




  export type GuildMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuildMemberWhereInput
    orderBy?: GuildMemberOrderByWithAggregationInput | GuildMemberOrderByWithAggregationInput[]
    by: GuildMemberScalarFieldEnum[] | GuildMemberScalarFieldEnum
    having?: GuildMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildMemberCountAggregateInputType | true
    _avg?: GuildMemberAvgAggregateInputType
    _sum?: GuildMemberSumAggregateInputType
    _min?: GuildMemberMinAggregateInputType
    _max?: GuildMemberMaxAggregateInputType
  }

  export type GuildMemberGroupByOutputType = {
    Name: string
    G_Name: string
    G_Level: number | null
    G_Status: number
    _count: GuildMemberCountAggregateOutputType | null
    _avg: GuildMemberAvgAggregateOutputType | null
    _sum: GuildMemberSumAggregateOutputType | null
    _min: GuildMemberMinAggregateOutputType | null
    _max: GuildMemberMaxAggregateOutputType | null
  }

  type GetGuildMemberGroupByPayload<T extends GuildMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuildMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildMemberGroupByOutputType[P]>
            : GetScalarType<T[P], GuildMemberGroupByOutputType[P]>
        }
      >
    >


  export type GuildMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    G_Name?: boolean
    G_Level?: boolean
    G_Status?: boolean
  }, ExtArgs["result"]["guildMember"]>

  export type GuildMemberSelectScalar = {
    Name?: boolean
    G_Name?: boolean
    G_Level?: boolean
    G_Status?: boolean
  }


  export type $GuildMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuildMember"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      G_Name: string
      G_Level: number | null
      G_Status: number
    }, ExtArgs["result"]["guildMember"]>
    composites: {}
  }


  type GuildMemberGetPayload<S extends boolean | null | undefined | GuildMemberDefaultArgs> = $Result.GetResult<Prisma.$GuildMemberPayload, S>

  type GuildMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GuildMemberFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GuildMemberCountAggregateInputType | true
    }

  export interface GuildMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuildMember'], meta: { name: 'GuildMember' } }
    /**
     * Find zero or one GuildMember that matches the filter.
     * @param {GuildMemberFindUniqueArgs} args - Arguments to find a GuildMember
     * @example
     * // Get one GuildMember
     * const guildMember = await prisma.guildMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuildMemberFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMemberFindUniqueArgs<ExtArgs>>
    ): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GuildMember that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GuildMemberFindUniqueOrThrowArgs} args - Arguments to find a GuildMember
     * @example
     * // Get one GuildMember
     * const guildMember = await prisma.guildMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GuildMemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GuildMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberFindFirstArgs} args - Arguments to find a GuildMember
     * @example
     * // Get one GuildMember
     * const guildMember = await prisma.guildMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuildMemberFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMemberFindFirstArgs<ExtArgs>>
    ): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GuildMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberFindFirstOrThrowArgs} args - Arguments to find a GuildMember
     * @example
     * // Get one GuildMember
     * const guildMember = await prisma.guildMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GuildMemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GuildMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuildMembers
     * const guildMembers = await prisma.guildMember.findMany()
     * 
     * // Get first 10 GuildMembers
     * const guildMembers = await prisma.guildMember.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const guildMemberWithNameOnly = await prisma.guildMember.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends GuildMemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GuildMember.
     * @param {GuildMemberCreateArgs} args - Arguments to create a GuildMember.
     * @example
     * // Create one GuildMember
     * const GuildMember = await prisma.guildMember.create({
     *   data: {
     *     // ... data to create a GuildMember
     *   }
     * })
     * 
    **/
    create<T extends GuildMemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMemberCreateArgs<ExtArgs>>
    ): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GuildMembers.
     *     @param {GuildMemberCreateManyArgs} args - Arguments to create many GuildMembers.
     *     @example
     *     // Create many GuildMembers
     *     const guildMember = await prisma.guildMember.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuildMemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuildMember.
     * @param {GuildMemberDeleteArgs} args - Arguments to delete one GuildMember.
     * @example
     * // Delete one GuildMember
     * const GuildMember = await prisma.guildMember.delete({
     *   where: {
     *     // ... filter to delete one GuildMember
     *   }
     * })
     * 
    **/
    delete<T extends GuildMemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMemberDeleteArgs<ExtArgs>>
    ): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GuildMember.
     * @param {GuildMemberUpdateArgs} args - Arguments to update one GuildMember.
     * @example
     * // Update one GuildMember
     * const guildMember = await prisma.guildMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuildMemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMemberUpdateArgs<ExtArgs>>
    ): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GuildMembers.
     * @param {GuildMemberDeleteManyArgs} args - Arguments to filter GuildMembers to delete.
     * @example
     * // Delete a few GuildMembers
     * const { count } = await prisma.guildMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuildMemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GuildMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuildMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuildMembers
     * const guildMember = await prisma.guildMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuildMemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuildMember.
     * @param {GuildMemberUpsertArgs} args - Arguments to update or create a GuildMember.
     * @example
     * // Update or create a GuildMember
     * const guildMember = await prisma.guildMember.upsert({
     *   create: {
     *     // ... data to create a GuildMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuildMember we want to update
     *   }
     * })
    **/
    upsert<T extends GuildMemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GuildMemberUpsertArgs<ExtArgs>>
    ): Prisma__GuildMemberClient<$Result.GetResult<Prisma.$GuildMemberPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of GuildMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberCountArgs} args - Arguments to filter GuildMembers to count.
     * @example
     * // Count the number of GuildMembers
     * const count = await prisma.guildMember.count({
     *   where: {
     *     // ... the filter for the GuildMembers we want to count
     *   }
     * })
    **/
    count<T extends GuildMemberCountArgs>(
      args?: Subset<T, GuildMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuildMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildMemberAggregateArgs>(args: Subset<T, GuildMemberAggregateArgs>): Prisma.PrismaPromise<GetGuildMemberAggregateType<T>>

    /**
     * Group by GuildMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildMemberGroupByArgs['orderBy'] }
        : { orderBy?: GuildMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuildMember model
   */
  readonly fields: GuildMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuildMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuildMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GuildMember model
   */ 
  interface GuildMemberFieldRefs {
    readonly Name: FieldRef<"GuildMember", 'String'>
    readonly G_Name: FieldRef<"GuildMember", 'String'>
    readonly G_Level: FieldRef<"GuildMember", 'Int'>
    readonly G_Status: FieldRef<"GuildMember", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * GuildMember findUnique
   */
  export type GuildMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Filter, which GuildMember to fetch.
     */
    where: GuildMemberWhereUniqueInput
  }


  /**
   * GuildMember findUniqueOrThrow
   */
  export type GuildMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Filter, which GuildMember to fetch.
     */
    where: GuildMemberWhereUniqueInput
  }


  /**
   * GuildMember findFirst
   */
  export type GuildMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Filter, which GuildMember to fetch.
     */
    where?: GuildMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMembers to fetch.
     */
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildMembers.
     */
    cursor?: GuildMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildMembers.
     */
    distinct?: GuildMemberScalarFieldEnum | GuildMemberScalarFieldEnum[]
  }


  /**
   * GuildMember findFirstOrThrow
   */
  export type GuildMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Filter, which GuildMember to fetch.
     */
    where?: GuildMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMembers to fetch.
     */
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuildMembers.
     */
    cursor?: GuildMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuildMembers.
     */
    distinct?: GuildMemberScalarFieldEnum | GuildMemberScalarFieldEnum[]
  }


  /**
   * GuildMember findMany
   */
  export type GuildMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Filter, which GuildMembers to fetch.
     */
    where?: GuildMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuildMembers to fetch.
     */
    orderBy?: GuildMemberOrderByWithRelationInput | GuildMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuildMembers.
     */
    cursor?: GuildMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuildMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuildMembers.
     */
    skip?: number
    distinct?: GuildMemberScalarFieldEnum | GuildMemberScalarFieldEnum[]
  }


  /**
   * GuildMember create
   */
  export type GuildMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * The data needed to create a GuildMember.
     */
    data: XOR<GuildMemberCreateInput, GuildMemberUncheckedCreateInput>
  }


  /**
   * GuildMember createMany
   */
  export type GuildMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuildMembers.
     */
    data: GuildMemberCreateManyInput | GuildMemberCreateManyInput[]
  }


  /**
   * GuildMember update
   */
  export type GuildMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * The data needed to update a GuildMember.
     */
    data: XOR<GuildMemberUpdateInput, GuildMemberUncheckedUpdateInput>
    /**
     * Choose, which GuildMember to update.
     */
    where: GuildMemberWhereUniqueInput
  }


  /**
   * GuildMember updateMany
   */
  export type GuildMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuildMembers.
     */
    data: XOR<GuildMemberUpdateManyMutationInput, GuildMemberUncheckedUpdateManyInput>
    /**
     * Filter which GuildMembers to update
     */
    where?: GuildMemberWhereInput
  }


  /**
   * GuildMember upsert
   */
  export type GuildMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * The filter to search for the GuildMember to update in case it exists.
     */
    where: GuildMemberWhereUniqueInput
    /**
     * In case the GuildMember found by the `where` argument doesn't exist, create a new GuildMember with this data.
     */
    create: XOR<GuildMemberCreateInput, GuildMemberUncheckedCreateInput>
    /**
     * In case the GuildMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuildMemberUpdateInput, GuildMemberUncheckedUpdateInput>
  }


  /**
   * GuildMember delete
   */
  export type GuildMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
    /**
     * Filter which GuildMember to delete.
     */
    where: GuildMemberWhereUniqueInput
  }


  /**
   * GuildMember deleteMany
   */
  export type GuildMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuildMembers to delete
     */
    where?: GuildMemberWhereInput
  }


  /**
   * GuildMember without action
   */
  export type GuildMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildMember
     */
    select?: GuildMemberSelect<ExtArgs> | null
  }



  /**
   * Model HelperData
   */

  export type AggregateHelperData = {
    _count: HelperDataCountAggregateOutputType | null
    _min: HelperDataMinAggregateOutputType | null
    _max: HelperDataMaxAggregateOutputType | null
  }

  export type HelperDataMinAggregateOutputType = {
    Name: string | null
    Data: Buffer | null
  }

  export type HelperDataMaxAggregateOutputType = {
    Name: string | null
    Data: Buffer | null
  }

  export type HelperDataCountAggregateOutputType = {
    Name: number
    Data: number
    _all: number
  }


  export type HelperDataMinAggregateInputType = {
    Name?: true
    Data?: true
  }

  export type HelperDataMaxAggregateInputType = {
    Name?: true
    Data?: true
  }

  export type HelperDataCountAggregateInputType = {
    Name?: true
    Data?: true
    _all?: true
  }

  export type HelperDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelperData to aggregate.
     */
    where?: HelperDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelperData to fetch.
     */
    orderBy?: HelperDataOrderByWithRelationInput | HelperDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelperDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelperData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelperData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelperData
    **/
    _count?: true | HelperDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelperDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelperDataMaxAggregateInputType
  }

  export type GetHelperDataAggregateType<T extends HelperDataAggregateArgs> = {
        [P in keyof T & keyof AggregateHelperData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelperData[P]>
      : GetScalarType<T[P], AggregateHelperData[P]>
  }




  export type HelperDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelperDataWhereInput
    orderBy?: HelperDataOrderByWithAggregationInput | HelperDataOrderByWithAggregationInput[]
    by: HelperDataScalarFieldEnum[] | HelperDataScalarFieldEnum
    having?: HelperDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelperDataCountAggregateInputType | true
    _min?: HelperDataMinAggregateInputType
    _max?: HelperDataMaxAggregateInputType
  }

  export type HelperDataGroupByOutputType = {
    Name: string
    Data: Buffer | null
    _count: HelperDataCountAggregateOutputType | null
    _min: HelperDataMinAggregateOutputType | null
    _max: HelperDataMaxAggregateOutputType | null
  }

  type GetHelperDataGroupByPayload<T extends HelperDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelperDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelperDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelperDataGroupByOutputType[P]>
            : GetScalarType<T[P], HelperDataGroupByOutputType[P]>
        }
      >
    >


  export type HelperDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Data?: boolean
  }, ExtArgs["result"]["helperData"]>

  export type HelperDataSelectScalar = {
    Name?: boolean
    Data?: boolean
  }


  export type $HelperDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelperData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Data: Buffer | null
    }, ExtArgs["result"]["helperData"]>
    composites: {}
  }


  type HelperDataGetPayload<S extends boolean | null | undefined | HelperDataDefaultArgs> = $Result.GetResult<Prisma.$HelperDataPayload, S>

  type HelperDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelperDataFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: HelperDataCountAggregateInputType | true
    }

  export interface HelperDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelperData'], meta: { name: 'HelperData' } }
    /**
     * Find zero or one HelperData that matches the filter.
     * @param {HelperDataFindUniqueArgs} args - Arguments to find a HelperData
     * @example
     * // Get one HelperData
     * const helperData = await prisma.helperData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HelperDataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HelperDataFindUniqueArgs<ExtArgs>>
    ): Prisma__HelperDataClient<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HelperData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HelperDataFindUniqueOrThrowArgs} args - Arguments to find a HelperData
     * @example
     * // Get one HelperData
     * const helperData = await prisma.helperData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HelperDataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HelperDataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HelperDataClient<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HelperData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperDataFindFirstArgs} args - Arguments to find a HelperData
     * @example
     * // Get one HelperData
     * const helperData = await prisma.helperData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HelperDataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HelperDataFindFirstArgs<ExtArgs>>
    ): Prisma__HelperDataClient<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HelperData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperDataFindFirstOrThrowArgs} args - Arguments to find a HelperData
     * @example
     * // Get one HelperData
     * const helperData = await prisma.helperData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HelperDataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HelperDataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HelperDataClient<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HelperData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelperData
     * const helperData = await prisma.helperData.findMany()
     * 
     * // Get first 10 HelperData
     * const helperData = await prisma.helperData.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const helperDataWithNameOnly = await prisma.helperData.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends HelperDataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HelperDataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HelperData.
     * @param {HelperDataCreateArgs} args - Arguments to create a HelperData.
     * @example
     * // Create one HelperData
     * const HelperData = await prisma.helperData.create({
     *   data: {
     *     // ... data to create a HelperData
     *   }
     * })
     * 
    **/
    create<T extends HelperDataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HelperDataCreateArgs<ExtArgs>>
    ): Prisma__HelperDataClient<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HelperData.
     *     @param {HelperDataCreateManyArgs} args - Arguments to create many HelperData.
     *     @example
     *     // Create many HelperData
     *     const helperData = await prisma.helperData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HelperDataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HelperDataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HelperData.
     * @param {HelperDataDeleteArgs} args - Arguments to delete one HelperData.
     * @example
     * // Delete one HelperData
     * const HelperData = await prisma.helperData.delete({
     *   where: {
     *     // ... filter to delete one HelperData
     *   }
     * })
     * 
    **/
    delete<T extends HelperDataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HelperDataDeleteArgs<ExtArgs>>
    ): Prisma__HelperDataClient<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HelperData.
     * @param {HelperDataUpdateArgs} args - Arguments to update one HelperData.
     * @example
     * // Update one HelperData
     * const helperData = await prisma.helperData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HelperDataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HelperDataUpdateArgs<ExtArgs>>
    ): Prisma__HelperDataClient<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HelperData.
     * @param {HelperDataDeleteManyArgs} args - Arguments to filter HelperData to delete.
     * @example
     * // Delete a few HelperData
     * const { count } = await prisma.helperData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HelperDataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HelperDataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelperData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelperData
     * const helperData = await prisma.helperData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HelperDataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HelperDataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelperData.
     * @param {HelperDataUpsertArgs} args - Arguments to update or create a HelperData.
     * @example
     * // Update or create a HelperData
     * const helperData = await prisma.helperData.upsert({
     *   create: {
     *     // ... data to create a HelperData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelperData we want to update
     *   }
     * })
    **/
    upsert<T extends HelperDataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HelperDataUpsertArgs<ExtArgs>>
    ): Prisma__HelperDataClient<$Result.GetResult<Prisma.$HelperDataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HelperData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperDataCountArgs} args - Arguments to filter HelperData to count.
     * @example
     * // Count the number of HelperData
     * const count = await prisma.helperData.count({
     *   where: {
     *     // ... the filter for the HelperData we want to count
     *   }
     * })
    **/
    count<T extends HelperDataCountArgs>(
      args?: Subset<T, HelperDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelperDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelperData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelperDataAggregateArgs>(args: Subset<T, HelperDataAggregateArgs>): Prisma.PrismaPromise<GetHelperDataAggregateType<T>>

    /**
     * Group by HelperData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelperDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelperDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelperDataGroupByArgs['orderBy'] }
        : { orderBy?: HelperDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelperDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelperDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelperData model
   */
  readonly fields: HelperDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelperData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelperDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HelperData model
   */ 
  interface HelperDataFieldRefs {
    readonly Name: FieldRef<"HelperData", 'String'>
    readonly Data: FieldRef<"HelperData", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * HelperData findUnique
   */
  export type HelperDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * Filter, which HelperData to fetch.
     */
    where: HelperDataWhereUniqueInput
  }


  /**
   * HelperData findUniqueOrThrow
   */
  export type HelperDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * Filter, which HelperData to fetch.
     */
    where: HelperDataWhereUniqueInput
  }


  /**
   * HelperData findFirst
   */
  export type HelperDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * Filter, which HelperData to fetch.
     */
    where?: HelperDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelperData to fetch.
     */
    orderBy?: HelperDataOrderByWithRelationInput | HelperDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelperData.
     */
    cursor?: HelperDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelperData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelperData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelperData.
     */
    distinct?: HelperDataScalarFieldEnum | HelperDataScalarFieldEnum[]
  }


  /**
   * HelperData findFirstOrThrow
   */
  export type HelperDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * Filter, which HelperData to fetch.
     */
    where?: HelperDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelperData to fetch.
     */
    orderBy?: HelperDataOrderByWithRelationInput | HelperDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelperData.
     */
    cursor?: HelperDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelperData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelperData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelperData.
     */
    distinct?: HelperDataScalarFieldEnum | HelperDataScalarFieldEnum[]
  }


  /**
   * HelperData findMany
   */
  export type HelperDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * Filter, which HelperData to fetch.
     */
    where?: HelperDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelperData to fetch.
     */
    orderBy?: HelperDataOrderByWithRelationInput | HelperDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelperData.
     */
    cursor?: HelperDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelperData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelperData.
     */
    skip?: number
    distinct?: HelperDataScalarFieldEnum | HelperDataScalarFieldEnum[]
  }


  /**
   * HelperData create
   */
  export type HelperDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * The data needed to create a HelperData.
     */
    data: XOR<HelperDataCreateInput, HelperDataUncheckedCreateInput>
  }


  /**
   * HelperData createMany
   */
  export type HelperDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelperData.
     */
    data: HelperDataCreateManyInput | HelperDataCreateManyInput[]
  }


  /**
   * HelperData update
   */
  export type HelperDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * The data needed to update a HelperData.
     */
    data: XOR<HelperDataUpdateInput, HelperDataUncheckedUpdateInput>
    /**
     * Choose, which HelperData to update.
     */
    where: HelperDataWhereUniqueInput
  }


  /**
   * HelperData updateMany
   */
  export type HelperDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelperData.
     */
    data: XOR<HelperDataUpdateManyMutationInput, HelperDataUncheckedUpdateManyInput>
    /**
     * Filter which HelperData to update
     */
    where?: HelperDataWhereInput
  }


  /**
   * HelperData upsert
   */
  export type HelperDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * The filter to search for the HelperData to update in case it exists.
     */
    where: HelperDataWhereUniqueInput
    /**
     * In case the HelperData found by the `where` argument doesn't exist, create a new HelperData with this data.
     */
    create: XOR<HelperDataCreateInput, HelperDataUncheckedCreateInput>
    /**
     * In case the HelperData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelperDataUpdateInput, HelperDataUncheckedUpdateInput>
  }


  /**
   * HelperData delete
   */
  export type HelperDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
    /**
     * Filter which HelperData to delete.
     */
    where: HelperDataWhereUniqueInput
  }


  /**
   * HelperData deleteMany
   */
  export type HelperDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelperData to delete
     */
    where?: HelperDataWhereInput
  }


  /**
   * HelperData without action
   */
  export type HelperDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelperData
     */
    select?: HelperDataSelect<ExtArgs> | null
  }



  /**
   * Model LuckyCoin
   */

  export type AggregateLuckyCoin = {
    _count: LuckyCoinCountAggregateOutputType | null
    _avg: LuckyCoinAvgAggregateOutputType | null
    _sum: LuckyCoinSumAggregateOutputType | null
    _min: LuckyCoinMinAggregateOutputType | null
    _max: LuckyCoinMaxAggregateOutputType | null
  }

  export type LuckyCoinAvgAggregateOutputType = {
    LuckyCoin: number | null
  }

  export type LuckyCoinSumAggregateOutputType = {
    LuckyCoin: number | null
  }

  export type LuckyCoinMinAggregateOutputType = {
    AccountID: string | null
    LuckyCoin: number | null
  }

  export type LuckyCoinMaxAggregateOutputType = {
    AccountID: string | null
    LuckyCoin: number | null
  }

  export type LuckyCoinCountAggregateOutputType = {
    AccountID: number
    LuckyCoin: number
    _all: number
  }


  export type LuckyCoinAvgAggregateInputType = {
    LuckyCoin?: true
  }

  export type LuckyCoinSumAggregateInputType = {
    LuckyCoin?: true
  }

  export type LuckyCoinMinAggregateInputType = {
    AccountID?: true
    LuckyCoin?: true
  }

  export type LuckyCoinMaxAggregateInputType = {
    AccountID?: true
    LuckyCoin?: true
  }

  export type LuckyCoinCountAggregateInputType = {
    AccountID?: true
    LuckyCoin?: true
    _all?: true
  }

  export type LuckyCoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LuckyCoin to aggregate.
     */
    where?: LuckyCoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LuckyCoins to fetch.
     */
    orderBy?: LuckyCoinOrderByWithRelationInput | LuckyCoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LuckyCoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LuckyCoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LuckyCoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LuckyCoins
    **/
    _count?: true | LuckyCoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LuckyCoinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LuckyCoinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LuckyCoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LuckyCoinMaxAggregateInputType
  }

  export type GetLuckyCoinAggregateType<T extends LuckyCoinAggregateArgs> = {
        [P in keyof T & keyof AggregateLuckyCoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLuckyCoin[P]>
      : GetScalarType<T[P], AggregateLuckyCoin[P]>
  }




  export type LuckyCoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LuckyCoinWhereInput
    orderBy?: LuckyCoinOrderByWithAggregationInput | LuckyCoinOrderByWithAggregationInput[]
    by: LuckyCoinScalarFieldEnum[] | LuckyCoinScalarFieldEnum
    having?: LuckyCoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LuckyCoinCountAggregateInputType | true
    _avg?: LuckyCoinAvgAggregateInputType
    _sum?: LuckyCoinSumAggregateInputType
    _min?: LuckyCoinMinAggregateInputType
    _max?: LuckyCoinMaxAggregateInputType
  }

  export type LuckyCoinGroupByOutputType = {
    AccountID: string
    LuckyCoin: number | null
    _count: LuckyCoinCountAggregateOutputType | null
    _avg: LuckyCoinAvgAggregateOutputType | null
    _sum: LuckyCoinSumAggregateOutputType | null
    _min: LuckyCoinMinAggregateOutputType | null
    _max: LuckyCoinMaxAggregateOutputType | null
  }

  type GetLuckyCoinGroupByPayload<T extends LuckyCoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LuckyCoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LuckyCoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LuckyCoinGroupByOutputType[P]>
            : GetScalarType<T[P], LuckyCoinGroupByOutputType[P]>
        }
      >
    >


  export type LuckyCoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AccountID?: boolean
    LuckyCoin?: boolean
  }, ExtArgs["result"]["luckyCoin"]>

  export type LuckyCoinSelectScalar = {
    AccountID?: boolean
    LuckyCoin?: boolean
  }


  export type $LuckyCoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LuckyCoin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AccountID: string
      LuckyCoin: number | null
    }, ExtArgs["result"]["luckyCoin"]>
    composites: {}
  }


  type LuckyCoinGetPayload<S extends boolean | null | undefined | LuckyCoinDefaultArgs> = $Result.GetResult<Prisma.$LuckyCoinPayload, S>

  type LuckyCoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LuckyCoinFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LuckyCoinCountAggregateInputType | true
    }

  export interface LuckyCoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LuckyCoin'], meta: { name: 'LuckyCoin' } }
    /**
     * Find zero or one LuckyCoin that matches the filter.
     * @param {LuckyCoinFindUniqueArgs} args - Arguments to find a LuckyCoin
     * @example
     * // Get one LuckyCoin
     * const luckyCoin = await prisma.luckyCoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LuckyCoinFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyCoinFindUniqueArgs<ExtArgs>>
    ): Prisma__LuckyCoinClient<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LuckyCoin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LuckyCoinFindUniqueOrThrowArgs} args - Arguments to find a LuckyCoin
     * @example
     * // Get one LuckyCoin
     * const luckyCoin = await prisma.luckyCoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LuckyCoinFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyCoinFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LuckyCoinClient<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LuckyCoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyCoinFindFirstArgs} args - Arguments to find a LuckyCoin
     * @example
     * // Get one LuckyCoin
     * const luckyCoin = await prisma.luckyCoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LuckyCoinFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyCoinFindFirstArgs<ExtArgs>>
    ): Prisma__LuckyCoinClient<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LuckyCoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyCoinFindFirstOrThrowArgs} args - Arguments to find a LuckyCoin
     * @example
     * // Get one LuckyCoin
     * const luckyCoin = await prisma.luckyCoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LuckyCoinFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyCoinFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LuckyCoinClient<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LuckyCoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyCoinFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LuckyCoins
     * const luckyCoins = await prisma.luckyCoin.findMany()
     * 
     * // Get first 10 LuckyCoins
     * const luckyCoins = await prisma.luckyCoin.findMany({ take: 10 })
     * 
     * // Only select the `AccountID`
     * const luckyCoinWithAccountIDOnly = await prisma.luckyCoin.findMany({ select: { AccountID: true } })
     * 
    **/
    findMany<T extends LuckyCoinFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyCoinFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LuckyCoin.
     * @param {LuckyCoinCreateArgs} args - Arguments to create a LuckyCoin.
     * @example
     * // Create one LuckyCoin
     * const LuckyCoin = await prisma.luckyCoin.create({
     *   data: {
     *     // ... data to create a LuckyCoin
     *   }
     * })
     * 
    **/
    create<T extends LuckyCoinCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyCoinCreateArgs<ExtArgs>>
    ): Prisma__LuckyCoinClient<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LuckyCoins.
     *     @param {LuckyCoinCreateManyArgs} args - Arguments to create many LuckyCoins.
     *     @example
     *     // Create many LuckyCoins
     *     const luckyCoin = await prisma.luckyCoin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LuckyCoinCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyCoinCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LuckyCoin.
     * @param {LuckyCoinDeleteArgs} args - Arguments to delete one LuckyCoin.
     * @example
     * // Delete one LuckyCoin
     * const LuckyCoin = await prisma.luckyCoin.delete({
     *   where: {
     *     // ... filter to delete one LuckyCoin
     *   }
     * })
     * 
    **/
    delete<T extends LuckyCoinDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyCoinDeleteArgs<ExtArgs>>
    ): Prisma__LuckyCoinClient<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LuckyCoin.
     * @param {LuckyCoinUpdateArgs} args - Arguments to update one LuckyCoin.
     * @example
     * // Update one LuckyCoin
     * const luckyCoin = await prisma.luckyCoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LuckyCoinUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyCoinUpdateArgs<ExtArgs>>
    ): Prisma__LuckyCoinClient<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LuckyCoins.
     * @param {LuckyCoinDeleteManyArgs} args - Arguments to filter LuckyCoins to delete.
     * @example
     * // Delete a few LuckyCoins
     * const { count } = await prisma.luckyCoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LuckyCoinDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyCoinDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LuckyCoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyCoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LuckyCoins
     * const luckyCoin = await prisma.luckyCoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LuckyCoinUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyCoinUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LuckyCoin.
     * @param {LuckyCoinUpsertArgs} args - Arguments to update or create a LuckyCoin.
     * @example
     * // Update or create a LuckyCoin
     * const luckyCoin = await prisma.luckyCoin.upsert({
     *   create: {
     *     // ... data to create a LuckyCoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LuckyCoin we want to update
     *   }
     * })
    **/
    upsert<T extends LuckyCoinUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyCoinUpsertArgs<ExtArgs>>
    ): Prisma__LuckyCoinClient<$Result.GetResult<Prisma.$LuckyCoinPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LuckyCoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyCoinCountArgs} args - Arguments to filter LuckyCoins to count.
     * @example
     * // Count the number of LuckyCoins
     * const count = await prisma.luckyCoin.count({
     *   where: {
     *     // ... the filter for the LuckyCoins we want to count
     *   }
     * })
    **/
    count<T extends LuckyCoinCountArgs>(
      args?: Subset<T, LuckyCoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LuckyCoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LuckyCoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyCoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LuckyCoinAggregateArgs>(args: Subset<T, LuckyCoinAggregateArgs>): Prisma.PrismaPromise<GetLuckyCoinAggregateType<T>>

    /**
     * Group by LuckyCoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyCoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LuckyCoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LuckyCoinGroupByArgs['orderBy'] }
        : { orderBy?: LuckyCoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LuckyCoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLuckyCoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LuckyCoin model
   */
  readonly fields: LuckyCoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LuckyCoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LuckyCoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LuckyCoin model
   */ 
  interface LuckyCoinFieldRefs {
    readonly AccountID: FieldRef<"LuckyCoin", 'String'>
    readonly LuckyCoin: FieldRef<"LuckyCoin", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LuckyCoin findUnique
   */
  export type LuckyCoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * Filter, which LuckyCoin to fetch.
     */
    where: LuckyCoinWhereUniqueInput
  }


  /**
   * LuckyCoin findUniqueOrThrow
   */
  export type LuckyCoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * Filter, which LuckyCoin to fetch.
     */
    where: LuckyCoinWhereUniqueInput
  }


  /**
   * LuckyCoin findFirst
   */
  export type LuckyCoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * Filter, which LuckyCoin to fetch.
     */
    where?: LuckyCoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LuckyCoins to fetch.
     */
    orderBy?: LuckyCoinOrderByWithRelationInput | LuckyCoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LuckyCoins.
     */
    cursor?: LuckyCoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LuckyCoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LuckyCoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LuckyCoins.
     */
    distinct?: LuckyCoinScalarFieldEnum | LuckyCoinScalarFieldEnum[]
  }


  /**
   * LuckyCoin findFirstOrThrow
   */
  export type LuckyCoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * Filter, which LuckyCoin to fetch.
     */
    where?: LuckyCoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LuckyCoins to fetch.
     */
    orderBy?: LuckyCoinOrderByWithRelationInput | LuckyCoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LuckyCoins.
     */
    cursor?: LuckyCoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LuckyCoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LuckyCoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LuckyCoins.
     */
    distinct?: LuckyCoinScalarFieldEnum | LuckyCoinScalarFieldEnum[]
  }


  /**
   * LuckyCoin findMany
   */
  export type LuckyCoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * Filter, which LuckyCoins to fetch.
     */
    where?: LuckyCoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LuckyCoins to fetch.
     */
    orderBy?: LuckyCoinOrderByWithRelationInput | LuckyCoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LuckyCoins.
     */
    cursor?: LuckyCoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LuckyCoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LuckyCoins.
     */
    skip?: number
    distinct?: LuckyCoinScalarFieldEnum | LuckyCoinScalarFieldEnum[]
  }


  /**
   * LuckyCoin create
   */
  export type LuckyCoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * The data needed to create a LuckyCoin.
     */
    data: XOR<LuckyCoinCreateInput, LuckyCoinUncheckedCreateInput>
  }


  /**
   * LuckyCoin createMany
   */
  export type LuckyCoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LuckyCoins.
     */
    data: LuckyCoinCreateManyInput | LuckyCoinCreateManyInput[]
  }


  /**
   * LuckyCoin update
   */
  export type LuckyCoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * The data needed to update a LuckyCoin.
     */
    data: XOR<LuckyCoinUpdateInput, LuckyCoinUncheckedUpdateInput>
    /**
     * Choose, which LuckyCoin to update.
     */
    where: LuckyCoinWhereUniqueInput
  }


  /**
   * LuckyCoin updateMany
   */
  export type LuckyCoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LuckyCoins.
     */
    data: XOR<LuckyCoinUpdateManyMutationInput, LuckyCoinUncheckedUpdateManyInput>
    /**
     * Filter which LuckyCoins to update
     */
    where?: LuckyCoinWhereInput
  }


  /**
   * LuckyCoin upsert
   */
  export type LuckyCoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * The filter to search for the LuckyCoin to update in case it exists.
     */
    where: LuckyCoinWhereUniqueInput
    /**
     * In case the LuckyCoin found by the `where` argument doesn't exist, create a new LuckyCoin with this data.
     */
    create: XOR<LuckyCoinCreateInput, LuckyCoinUncheckedCreateInput>
    /**
     * In case the LuckyCoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LuckyCoinUpdateInput, LuckyCoinUncheckedUpdateInput>
  }


  /**
   * LuckyCoin delete
   */
  export type LuckyCoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
    /**
     * Filter which LuckyCoin to delete.
     */
    where: LuckyCoinWhereUniqueInput
  }


  /**
   * LuckyCoin deleteMany
   */
  export type LuckyCoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LuckyCoins to delete
     */
    where?: LuckyCoinWhereInput
  }


  /**
   * LuckyCoin without action
   */
  export type LuckyCoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyCoin
     */
    select?: LuckyCoinSelect<ExtArgs> | null
  }



  /**
   * Model LuckyItem
   */

  export type AggregateLuckyItem = {
    _count: LuckyItemCountAggregateOutputType | null
    _avg: LuckyItemAvgAggregateOutputType | null
    _sum: LuckyItemSumAggregateOutputType | null
    _min: LuckyItemMinAggregateOutputType | null
    _max: LuckyItemMaxAggregateOutputType | null
  }

  export type LuckyItemAvgAggregateOutputType = {
    ItemSerial: number | null
    DurabilitySmall: number | null
  }

  export type LuckyItemSumAggregateOutputType = {
    ItemSerial: number | null
    DurabilitySmall: number | null
  }

  export type LuckyItemMinAggregateOutputType = {
    ItemSerial: number | null
    DurabilitySmall: number | null
  }

  export type LuckyItemMaxAggregateOutputType = {
    ItemSerial: number | null
    DurabilitySmall: number | null
  }

  export type LuckyItemCountAggregateOutputType = {
    ItemSerial: number
    DurabilitySmall: number
    _all: number
  }


  export type LuckyItemAvgAggregateInputType = {
    ItemSerial?: true
    DurabilitySmall?: true
  }

  export type LuckyItemSumAggregateInputType = {
    ItemSerial?: true
    DurabilitySmall?: true
  }

  export type LuckyItemMinAggregateInputType = {
    ItemSerial?: true
    DurabilitySmall?: true
  }

  export type LuckyItemMaxAggregateInputType = {
    ItemSerial?: true
    DurabilitySmall?: true
  }

  export type LuckyItemCountAggregateInputType = {
    ItemSerial?: true
    DurabilitySmall?: true
    _all?: true
  }

  export type LuckyItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LuckyItem to aggregate.
     */
    where?: LuckyItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LuckyItems to fetch.
     */
    orderBy?: LuckyItemOrderByWithRelationInput | LuckyItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LuckyItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LuckyItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LuckyItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LuckyItems
    **/
    _count?: true | LuckyItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LuckyItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LuckyItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LuckyItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LuckyItemMaxAggregateInputType
  }

  export type GetLuckyItemAggregateType<T extends LuckyItemAggregateArgs> = {
        [P in keyof T & keyof AggregateLuckyItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLuckyItem[P]>
      : GetScalarType<T[P], AggregateLuckyItem[P]>
  }




  export type LuckyItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LuckyItemWhereInput
    orderBy?: LuckyItemOrderByWithAggregationInput | LuckyItemOrderByWithAggregationInput[]
    by: LuckyItemScalarFieldEnum[] | LuckyItemScalarFieldEnum
    having?: LuckyItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LuckyItemCountAggregateInputType | true
    _avg?: LuckyItemAvgAggregateInputType
    _sum?: LuckyItemSumAggregateInputType
    _min?: LuckyItemMinAggregateInputType
    _max?: LuckyItemMaxAggregateInputType
  }

  export type LuckyItemGroupByOutputType = {
    ItemSerial: number
    DurabilitySmall: number | null
    _count: LuckyItemCountAggregateOutputType | null
    _avg: LuckyItemAvgAggregateOutputType | null
    _sum: LuckyItemSumAggregateOutputType | null
    _min: LuckyItemMinAggregateOutputType | null
    _max: LuckyItemMaxAggregateOutputType | null
  }

  type GetLuckyItemGroupByPayload<T extends LuckyItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LuckyItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LuckyItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LuckyItemGroupByOutputType[P]>
            : GetScalarType<T[P], LuckyItemGroupByOutputType[P]>
        }
      >
    >


  export type LuckyItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ItemSerial?: boolean
    DurabilitySmall?: boolean
  }, ExtArgs["result"]["luckyItem"]>

  export type LuckyItemSelectScalar = {
    ItemSerial?: boolean
    DurabilitySmall?: boolean
  }


  export type $LuckyItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LuckyItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ItemSerial: number
      DurabilitySmall: number | null
    }, ExtArgs["result"]["luckyItem"]>
    composites: {}
  }


  type LuckyItemGetPayload<S extends boolean | null | undefined | LuckyItemDefaultArgs> = $Result.GetResult<Prisma.$LuckyItemPayload, S>

  type LuckyItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LuckyItemFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LuckyItemCountAggregateInputType | true
    }

  export interface LuckyItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LuckyItem'], meta: { name: 'LuckyItem' } }
    /**
     * Find zero or one LuckyItem that matches the filter.
     * @param {LuckyItemFindUniqueArgs} args - Arguments to find a LuckyItem
     * @example
     * // Get one LuckyItem
     * const luckyItem = await prisma.luckyItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LuckyItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyItemFindUniqueArgs<ExtArgs>>
    ): Prisma__LuckyItemClient<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LuckyItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LuckyItemFindUniqueOrThrowArgs} args - Arguments to find a LuckyItem
     * @example
     * // Get one LuckyItem
     * const luckyItem = await prisma.luckyItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LuckyItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LuckyItemClient<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LuckyItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyItemFindFirstArgs} args - Arguments to find a LuckyItem
     * @example
     * // Get one LuckyItem
     * const luckyItem = await prisma.luckyItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LuckyItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyItemFindFirstArgs<ExtArgs>>
    ): Prisma__LuckyItemClient<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LuckyItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyItemFindFirstOrThrowArgs} args - Arguments to find a LuckyItem
     * @example
     * // Get one LuckyItem
     * const luckyItem = await prisma.luckyItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LuckyItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LuckyItemClient<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LuckyItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LuckyItems
     * const luckyItems = await prisma.luckyItem.findMany()
     * 
     * // Get first 10 LuckyItems
     * const luckyItems = await prisma.luckyItem.findMany({ take: 10 })
     * 
     * // Only select the `ItemSerial`
     * const luckyItemWithItemSerialOnly = await prisma.luckyItem.findMany({ select: { ItemSerial: true } })
     * 
    **/
    findMany<T extends LuckyItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LuckyItem.
     * @param {LuckyItemCreateArgs} args - Arguments to create a LuckyItem.
     * @example
     * // Create one LuckyItem
     * const LuckyItem = await prisma.luckyItem.create({
     *   data: {
     *     // ... data to create a LuckyItem
     *   }
     * })
     * 
    **/
    create<T extends LuckyItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyItemCreateArgs<ExtArgs>>
    ): Prisma__LuckyItemClient<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LuckyItems.
     *     @param {LuckyItemCreateManyArgs} args - Arguments to create many LuckyItems.
     *     @example
     *     // Create many LuckyItems
     *     const luckyItem = await prisma.luckyItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LuckyItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LuckyItem.
     * @param {LuckyItemDeleteArgs} args - Arguments to delete one LuckyItem.
     * @example
     * // Delete one LuckyItem
     * const LuckyItem = await prisma.luckyItem.delete({
     *   where: {
     *     // ... filter to delete one LuckyItem
     *   }
     * })
     * 
    **/
    delete<T extends LuckyItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyItemDeleteArgs<ExtArgs>>
    ): Prisma__LuckyItemClient<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LuckyItem.
     * @param {LuckyItemUpdateArgs} args - Arguments to update one LuckyItem.
     * @example
     * // Update one LuckyItem
     * const luckyItem = await prisma.luckyItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LuckyItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyItemUpdateArgs<ExtArgs>>
    ): Prisma__LuckyItemClient<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LuckyItems.
     * @param {LuckyItemDeleteManyArgs} args - Arguments to filter LuckyItems to delete.
     * @example
     * // Delete a few LuckyItems
     * const { count } = await prisma.luckyItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LuckyItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LuckyItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LuckyItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LuckyItems
     * const luckyItem = await prisma.luckyItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LuckyItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LuckyItem.
     * @param {LuckyItemUpsertArgs} args - Arguments to update or create a LuckyItem.
     * @example
     * // Update or create a LuckyItem
     * const luckyItem = await prisma.luckyItem.upsert({
     *   create: {
     *     // ... data to create a LuckyItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LuckyItem we want to update
     *   }
     * })
    **/
    upsert<T extends LuckyItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LuckyItemUpsertArgs<ExtArgs>>
    ): Prisma__LuckyItemClient<$Result.GetResult<Prisma.$LuckyItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LuckyItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyItemCountArgs} args - Arguments to filter LuckyItems to count.
     * @example
     * // Count the number of LuckyItems
     * const count = await prisma.luckyItem.count({
     *   where: {
     *     // ... the filter for the LuckyItems we want to count
     *   }
     * })
    **/
    count<T extends LuckyItemCountArgs>(
      args?: Subset<T, LuckyItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LuckyItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LuckyItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LuckyItemAggregateArgs>(args: Subset<T, LuckyItemAggregateArgs>): Prisma.PrismaPromise<GetLuckyItemAggregateType<T>>

    /**
     * Group by LuckyItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LuckyItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LuckyItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LuckyItemGroupByArgs['orderBy'] }
        : { orderBy?: LuckyItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LuckyItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLuckyItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LuckyItem model
   */
  readonly fields: LuckyItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LuckyItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LuckyItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the LuckyItem model
   */ 
  interface LuckyItemFieldRefs {
    readonly ItemSerial: FieldRef<"LuckyItem", 'Int'>
    readonly DurabilitySmall: FieldRef<"LuckyItem", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * LuckyItem findUnique
   */
  export type LuckyItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * Filter, which LuckyItem to fetch.
     */
    where: LuckyItemWhereUniqueInput
  }


  /**
   * LuckyItem findUniqueOrThrow
   */
  export type LuckyItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * Filter, which LuckyItem to fetch.
     */
    where: LuckyItemWhereUniqueInput
  }


  /**
   * LuckyItem findFirst
   */
  export type LuckyItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * Filter, which LuckyItem to fetch.
     */
    where?: LuckyItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LuckyItems to fetch.
     */
    orderBy?: LuckyItemOrderByWithRelationInput | LuckyItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LuckyItems.
     */
    cursor?: LuckyItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LuckyItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LuckyItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LuckyItems.
     */
    distinct?: LuckyItemScalarFieldEnum | LuckyItemScalarFieldEnum[]
  }


  /**
   * LuckyItem findFirstOrThrow
   */
  export type LuckyItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * Filter, which LuckyItem to fetch.
     */
    where?: LuckyItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LuckyItems to fetch.
     */
    orderBy?: LuckyItemOrderByWithRelationInput | LuckyItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LuckyItems.
     */
    cursor?: LuckyItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LuckyItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LuckyItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LuckyItems.
     */
    distinct?: LuckyItemScalarFieldEnum | LuckyItemScalarFieldEnum[]
  }


  /**
   * LuckyItem findMany
   */
  export type LuckyItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * Filter, which LuckyItems to fetch.
     */
    where?: LuckyItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LuckyItems to fetch.
     */
    orderBy?: LuckyItemOrderByWithRelationInput | LuckyItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LuckyItems.
     */
    cursor?: LuckyItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LuckyItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LuckyItems.
     */
    skip?: number
    distinct?: LuckyItemScalarFieldEnum | LuckyItemScalarFieldEnum[]
  }


  /**
   * LuckyItem create
   */
  export type LuckyItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * The data needed to create a LuckyItem.
     */
    data: XOR<LuckyItemCreateInput, LuckyItemUncheckedCreateInput>
  }


  /**
   * LuckyItem createMany
   */
  export type LuckyItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LuckyItems.
     */
    data: LuckyItemCreateManyInput | LuckyItemCreateManyInput[]
  }


  /**
   * LuckyItem update
   */
  export type LuckyItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * The data needed to update a LuckyItem.
     */
    data: XOR<LuckyItemUpdateInput, LuckyItemUncheckedUpdateInput>
    /**
     * Choose, which LuckyItem to update.
     */
    where: LuckyItemWhereUniqueInput
  }


  /**
   * LuckyItem updateMany
   */
  export type LuckyItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LuckyItems.
     */
    data: XOR<LuckyItemUpdateManyMutationInput, LuckyItemUncheckedUpdateManyInput>
    /**
     * Filter which LuckyItems to update
     */
    where?: LuckyItemWhereInput
  }


  /**
   * LuckyItem upsert
   */
  export type LuckyItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * The filter to search for the LuckyItem to update in case it exists.
     */
    where: LuckyItemWhereUniqueInput
    /**
     * In case the LuckyItem found by the `where` argument doesn't exist, create a new LuckyItem with this data.
     */
    create: XOR<LuckyItemCreateInput, LuckyItemUncheckedCreateInput>
    /**
     * In case the LuckyItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LuckyItemUpdateInput, LuckyItemUncheckedUpdateInput>
  }


  /**
   * LuckyItem delete
   */
  export type LuckyItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
    /**
     * Filter which LuckyItem to delete.
     */
    where: LuckyItemWhereUniqueInput
  }


  /**
   * LuckyItem deleteMany
   */
  export type LuckyItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LuckyItems to delete
     */
    where?: LuckyItemWhereInput
  }


  /**
   * LuckyItem without action
   */
  export type LuckyItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LuckyItem
     */
    select?: LuckyItemSelect<ExtArgs> | null
  }



  /**
   * Model MEMB_STAT
   */

  export type AggregateMEMB_STAT = {
    _count: MEMB_STATCountAggregateOutputType | null
    _avg: MEMB_STATAvgAggregateOutputType | null
    _sum: MEMB_STATSumAggregateOutputType | null
    _min: MEMB_STATMinAggregateOutputType | null
    _max: MEMB_STATMaxAggregateOutputType | null
  }

  export type MEMB_STATAvgAggregateOutputType = {
    ConnectStat: number | null
    OnlineHours: number | null
  }

  export type MEMB_STATSumAggregateOutputType = {
    ConnectStat: number | null
    OnlineHours: number | null
  }

  export type MEMB_STATMinAggregateOutputType = {
    memb___id: string | null
    ConnectStat: number | null
    ServerName: string | null
    IP: string | null
    ConnectTM: Date | null
    DisConnectTM: Date | null
    OnlineHours: number | null
    HWID: string | null
  }

  export type MEMB_STATMaxAggregateOutputType = {
    memb___id: string | null
    ConnectStat: number | null
    ServerName: string | null
    IP: string | null
    ConnectTM: Date | null
    DisConnectTM: Date | null
    OnlineHours: number | null
    HWID: string | null
  }

  export type MEMB_STATCountAggregateOutputType = {
    memb___id: number
    ConnectStat: number
    ServerName: number
    IP: number
    ConnectTM: number
    DisConnectTM: number
    OnlineHours: number
    HWID: number
    _all: number
  }


  export type MEMB_STATAvgAggregateInputType = {
    ConnectStat?: true
    OnlineHours?: true
  }

  export type MEMB_STATSumAggregateInputType = {
    ConnectStat?: true
    OnlineHours?: true
  }

  export type MEMB_STATMinAggregateInputType = {
    memb___id?: true
    ConnectStat?: true
    ServerName?: true
    IP?: true
    ConnectTM?: true
    DisConnectTM?: true
    OnlineHours?: true
    HWID?: true
  }

  export type MEMB_STATMaxAggregateInputType = {
    memb___id?: true
    ConnectStat?: true
    ServerName?: true
    IP?: true
    ConnectTM?: true
    DisConnectTM?: true
    OnlineHours?: true
    HWID?: true
  }

  export type MEMB_STATCountAggregateInputType = {
    memb___id?: true
    ConnectStat?: true
    ServerName?: true
    IP?: true
    ConnectTM?: true
    DisConnectTM?: true
    OnlineHours?: true
    HWID?: true
    _all?: true
  }

  export type MEMB_STATAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEMB_STAT to aggregate.
     */
    where?: MEMB_STATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEMB_STATS to fetch.
     */
    orderBy?: MEMB_STATOrderByWithRelationInput | MEMB_STATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MEMB_STATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEMB_STATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEMB_STATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MEMB_STATS
    **/
    _count?: true | MEMB_STATCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MEMB_STATAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MEMB_STATSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MEMB_STATMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MEMB_STATMaxAggregateInputType
  }

  export type GetMEMB_STATAggregateType<T extends MEMB_STATAggregateArgs> = {
        [P in keyof T & keyof AggregateMEMB_STAT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMEMB_STAT[P]>
      : GetScalarType<T[P], AggregateMEMB_STAT[P]>
  }




  export type MEMB_STATGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MEMB_STATWhereInput
    orderBy?: MEMB_STATOrderByWithAggregationInput | MEMB_STATOrderByWithAggregationInput[]
    by: MEMB_STATScalarFieldEnum[] | MEMB_STATScalarFieldEnum
    having?: MEMB_STATScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MEMB_STATCountAggregateInputType | true
    _avg?: MEMB_STATAvgAggregateInputType
    _sum?: MEMB_STATSumAggregateInputType
    _min?: MEMB_STATMinAggregateInputType
    _max?: MEMB_STATMaxAggregateInputType
  }

  export type MEMB_STATGroupByOutputType = {
    memb___id: string
    ConnectStat: number | null
    ServerName: string | null
    IP: string | null
    ConnectTM: Date | null
    DisConnectTM: Date | null
    OnlineHours: number | null
    HWID: string | null
    _count: MEMB_STATCountAggregateOutputType | null
    _avg: MEMB_STATAvgAggregateOutputType | null
    _sum: MEMB_STATSumAggregateOutputType | null
    _min: MEMB_STATMinAggregateOutputType | null
    _max: MEMB_STATMaxAggregateOutputType | null
  }

  type GetMEMB_STATGroupByPayload<T extends MEMB_STATGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MEMB_STATGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MEMB_STATGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MEMB_STATGroupByOutputType[P]>
            : GetScalarType<T[P], MEMB_STATGroupByOutputType[P]>
        }
      >
    >


  export type MEMB_STATSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    memb___id?: boolean
    ConnectStat?: boolean
    ServerName?: boolean
    IP?: boolean
    ConnectTM?: boolean
    DisConnectTM?: boolean
    OnlineHours?: boolean
    HWID?: boolean
  }, ExtArgs["result"]["mEMB_STAT"]>

  export type MEMB_STATSelectScalar = {
    memb___id?: boolean
    ConnectStat?: boolean
    ServerName?: boolean
    IP?: boolean
    ConnectTM?: boolean
    DisConnectTM?: boolean
    OnlineHours?: boolean
    HWID?: boolean
  }


  export type $MEMB_STATPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MEMB_STAT"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      memb___id: string
      ConnectStat: number | null
      ServerName: string | null
      IP: string | null
      ConnectTM: Date | null
      DisConnectTM: Date | null
      OnlineHours: number | null
      HWID: string | null
    }, ExtArgs["result"]["mEMB_STAT"]>
    composites: {}
  }


  type MEMB_STATGetPayload<S extends boolean | null | undefined | MEMB_STATDefaultArgs> = $Result.GetResult<Prisma.$MEMB_STATPayload, S>

  type MEMB_STATCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MEMB_STATFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MEMB_STATCountAggregateInputType | true
    }

  export interface MEMB_STATDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MEMB_STAT'], meta: { name: 'MEMB_STAT' } }
    /**
     * Find zero or one MEMB_STAT that matches the filter.
     * @param {MEMB_STATFindUniqueArgs} args - Arguments to find a MEMB_STAT
     * @example
     * // Get one MEMB_STAT
     * const mEMB_STAT = await prisma.mEMB_STAT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MEMB_STATFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_STATFindUniqueArgs<ExtArgs>>
    ): Prisma__MEMB_STATClient<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MEMB_STAT that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MEMB_STATFindUniqueOrThrowArgs} args - Arguments to find a MEMB_STAT
     * @example
     * // Get one MEMB_STAT
     * const mEMB_STAT = await prisma.mEMB_STAT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MEMB_STATFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_STATFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MEMB_STATClient<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MEMB_STAT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_STATFindFirstArgs} args - Arguments to find a MEMB_STAT
     * @example
     * // Get one MEMB_STAT
     * const mEMB_STAT = await prisma.mEMB_STAT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MEMB_STATFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_STATFindFirstArgs<ExtArgs>>
    ): Prisma__MEMB_STATClient<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MEMB_STAT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_STATFindFirstOrThrowArgs} args - Arguments to find a MEMB_STAT
     * @example
     * // Get one MEMB_STAT
     * const mEMB_STAT = await prisma.mEMB_STAT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MEMB_STATFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_STATFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MEMB_STATClient<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MEMB_STATS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_STATFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MEMB_STATS
     * const mEMB_STATS = await prisma.mEMB_STAT.findMany()
     * 
     * // Get first 10 MEMB_STATS
     * const mEMB_STATS = await prisma.mEMB_STAT.findMany({ take: 10 })
     * 
     * // Only select the `memb___id`
     * const mEMB_STATWithMemb___idOnly = await prisma.mEMB_STAT.findMany({ select: { memb___id: true } })
     * 
    **/
    findMany<T extends MEMB_STATFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_STATFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MEMB_STAT.
     * @param {MEMB_STATCreateArgs} args - Arguments to create a MEMB_STAT.
     * @example
     * // Create one MEMB_STAT
     * const MEMB_STAT = await prisma.mEMB_STAT.create({
     *   data: {
     *     // ... data to create a MEMB_STAT
     *   }
     * })
     * 
    **/
    create<T extends MEMB_STATCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_STATCreateArgs<ExtArgs>>
    ): Prisma__MEMB_STATClient<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MEMB_STATS.
     *     @param {MEMB_STATCreateManyArgs} args - Arguments to create many MEMB_STATS.
     *     @example
     *     // Create many MEMB_STATS
     *     const mEMB_STAT = await prisma.mEMB_STAT.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MEMB_STATCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_STATCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MEMB_STAT.
     * @param {MEMB_STATDeleteArgs} args - Arguments to delete one MEMB_STAT.
     * @example
     * // Delete one MEMB_STAT
     * const MEMB_STAT = await prisma.mEMB_STAT.delete({
     *   where: {
     *     // ... filter to delete one MEMB_STAT
     *   }
     * })
     * 
    **/
    delete<T extends MEMB_STATDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_STATDeleteArgs<ExtArgs>>
    ): Prisma__MEMB_STATClient<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MEMB_STAT.
     * @param {MEMB_STATUpdateArgs} args - Arguments to update one MEMB_STAT.
     * @example
     * // Update one MEMB_STAT
     * const mEMB_STAT = await prisma.mEMB_STAT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MEMB_STATUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_STATUpdateArgs<ExtArgs>>
    ): Prisma__MEMB_STATClient<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MEMB_STATS.
     * @param {MEMB_STATDeleteManyArgs} args - Arguments to filter MEMB_STATS to delete.
     * @example
     * // Delete a few MEMB_STATS
     * const { count } = await prisma.mEMB_STAT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MEMB_STATDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MEMB_STATDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MEMB_STATS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_STATUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MEMB_STATS
     * const mEMB_STAT = await prisma.mEMB_STAT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MEMB_STATUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_STATUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MEMB_STAT.
     * @param {MEMB_STATUpsertArgs} args - Arguments to update or create a MEMB_STAT.
     * @example
     * // Update or create a MEMB_STAT
     * const mEMB_STAT = await prisma.mEMB_STAT.upsert({
     *   create: {
     *     // ... data to create a MEMB_STAT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MEMB_STAT we want to update
     *   }
     * })
    **/
    upsert<T extends MEMB_STATUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MEMB_STATUpsertArgs<ExtArgs>>
    ): Prisma__MEMB_STATClient<$Result.GetResult<Prisma.$MEMB_STATPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MEMB_STATS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_STATCountArgs} args - Arguments to filter MEMB_STATS to count.
     * @example
     * // Count the number of MEMB_STATS
     * const count = await prisma.mEMB_STAT.count({
     *   where: {
     *     // ... the filter for the MEMB_STATS we want to count
     *   }
     * })
    **/
    count<T extends MEMB_STATCountArgs>(
      args?: Subset<T, MEMB_STATCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MEMB_STATCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MEMB_STAT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_STATAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MEMB_STATAggregateArgs>(args: Subset<T, MEMB_STATAggregateArgs>): Prisma.PrismaPromise<GetMEMB_STATAggregateType<T>>

    /**
     * Group by MEMB_STAT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MEMB_STATGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MEMB_STATGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MEMB_STATGroupByArgs['orderBy'] }
        : { orderBy?: MEMB_STATGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MEMB_STATGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMEMB_STATGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MEMB_STAT model
   */
  readonly fields: MEMB_STATFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MEMB_STAT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MEMB_STATClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MEMB_STAT model
   */ 
  interface MEMB_STATFieldRefs {
    readonly memb___id: FieldRef<"MEMB_STAT", 'String'>
    readonly ConnectStat: FieldRef<"MEMB_STAT", 'Int'>
    readonly ServerName: FieldRef<"MEMB_STAT", 'String'>
    readonly IP: FieldRef<"MEMB_STAT", 'String'>
    readonly ConnectTM: FieldRef<"MEMB_STAT", 'DateTime'>
    readonly DisConnectTM: FieldRef<"MEMB_STAT", 'DateTime'>
    readonly OnlineHours: FieldRef<"MEMB_STAT", 'Int'>
    readonly HWID: FieldRef<"MEMB_STAT", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MEMB_STAT findUnique
   */
  export type MEMB_STATFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_STAT to fetch.
     */
    where: MEMB_STATWhereUniqueInput
  }


  /**
   * MEMB_STAT findUniqueOrThrow
   */
  export type MEMB_STATFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_STAT to fetch.
     */
    where: MEMB_STATWhereUniqueInput
  }


  /**
   * MEMB_STAT findFirst
   */
  export type MEMB_STATFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_STAT to fetch.
     */
    where?: MEMB_STATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEMB_STATS to fetch.
     */
    orderBy?: MEMB_STATOrderByWithRelationInput | MEMB_STATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEMB_STATS.
     */
    cursor?: MEMB_STATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEMB_STATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEMB_STATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEMB_STATS.
     */
    distinct?: MEMB_STATScalarFieldEnum | MEMB_STATScalarFieldEnum[]
  }


  /**
   * MEMB_STAT findFirstOrThrow
   */
  export type MEMB_STATFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_STAT to fetch.
     */
    where?: MEMB_STATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEMB_STATS to fetch.
     */
    orderBy?: MEMB_STATOrderByWithRelationInput | MEMB_STATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MEMB_STATS.
     */
    cursor?: MEMB_STATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEMB_STATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEMB_STATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MEMB_STATS.
     */
    distinct?: MEMB_STATScalarFieldEnum | MEMB_STATScalarFieldEnum[]
  }


  /**
   * MEMB_STAT findMany
   */
  export type MEMB_STATFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * Filter, which MEMB_STATS to fetch.
     */
    where?: MEMB_STATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MEMB_STATS to fetch.
     */
    orderBy?: MEMB_STATOrderByWithRelationInput | MEMB_STATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MEMB_STATS.
     */
    cursor?: MEMB_STATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MEMB_STATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MEMB_STATS.
     */
    skip?: number
    distinct?: MEMB_STATScalarFieldEnum | MEMB_STATScalarFieldEnum[]
  }


  /**
   * MEMB_STAT create
   */
  export type MEMB_STATCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * The data needed to create a MEMB_STAT.
     */
    data: XOR<MEMB_STATCreateInput, MEMB_STATUncheckedCreateInput>
  }


  /**
   * MEMB_STAT createMany
   */
  export type MEMB_STATCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MEMB_STATS.
     */
    data: MEMB_STATCreateManyInput | MEMB_STATCreateManyInput[]
  }


  /**
   * MEMB_STAT update
   */
  export type MEMB_STATUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * The data needed to update a MEMB_STAT.
     */
    data: XOR<MEMB_STATUpdateInput, MEMB_STATUncheckedUpdateInput>
    /**
     * Choose, which MEMB_STAT to update.
     */
    where: MEMB_STATWhereUniqueInput
  }


  /**
   * MEMB_STAT updateMany
   */
  export type MEMB_STATUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MEMB_STATS.
     */
    data: XOR<MEMB_STATUpdateManyMutationInput, MEMB_STATUncheckedUpdateManyInput>
    /**
     * Filter which MEMB_STATS to update
     */
    where?: MEMB_STATWhereInput
  }


  /**
   * MEMB_STAT upsert
   */
  export type MEMB_STATUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * The filter to search for the MEMB_STAT to update in case it exists.
     */
    where: MEMB_STATWhereUniqueInput
    /**
     * In case the MEMB_STAT found by the `where` argument doesn't exist, create a new MEMB_STAT with this data.
     */
    create: XOR<MEMB_STATCreateInput, MEMB_STATUncheckedCreateInput>
    /**
     * In case the MEMB_STAT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MEMB_STATUpdateInput, MEMB_STATUncheckedUpdateInput>
  }


  /**
   * MEMB_STAT delete
   */
  export type MEMB_STATDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
    /**
     * Filter which MEMB_STAT to delete.
     */
    where: MEMB_STATWhereUniqueInput
  }


  /**
   * MEMB_STAT deleteMany
   */
  export type MEMB_STATDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MEMB_STATS to delete
     */
    where?: MEMB_STATWhereInput
  }


  /**
   * MEMB_STAT without action
   */
  export type MEMB_STATDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MEMB_STAT
     */
    select?: MEMB_STATSelect<ExtArgs> | null
  }



  /**
   * Model MasterSkillTree
   */

  export type AggregateMasterSkillTree = {
    _count: MasterSkillTreeCountAggregateOutputType | null
    _avg: MasterSkillTreeAvgAggregateOutputType | null
    _sum: MasterSkillTreeSumAggregateOutputType | null
    _min: MasterSkillTreeMinAggregateOutputType | null
    _max: MasterSkillTreeMaxAggregateOutputType | null
  }

  export type MasterSkillTreeAvgAggregateOutputType = {
    MasterLevel: number | null
    MasterPoint: number | null
    MasterExperience: number | null
  }

  export type MasterSkillTreeSumAggregateOutputType = {
    MasterLevel: number | null
    MasterPoint: number | null
    MasterExperience: bigint | null
  }

  export type MasterSkillTreeMinAggregateOutputType = {
    Name: string | null
    MasterLevel: number | null
    MasterPoint: number | null
    MasterExperience: bigint | null
    MasterSkill: Buffer | null
  }

  export type MasterSkillTreeMaxAggregateOutputType = {
    Name: string | null
    MasterLevel: number | null
    MasterPoint: number | null
    MasterExperience: bigint | null
    MasterSkill: Buffer | null
  }

  export type MasterSkillTreeCountAggregateOutputType = {
    Name: number
    MasterLevel: number
    MasterPoint: number
    MasterExperience: number
    MasterSkill: number
    _all: number
  }


  export type MasterSkillTreeAvgAggregateInputType = {
    MasterLevel?: true
    MasterPoint?: true
    MasterExperience?: true
  }

  export type MasterSkillTreeSumAggregateInputType = {
    MasterLevel?: true
    MasterPoint?: true
    MasterExperience?: true
  }

  export type MasterSkillTreeMinAggregateInputType = {
    Name?: true
    MasterLevel?: true
    MasterPoint?: true
    MasterExperience?: true
    MasterSkill?: true
  }

  export type MasterSkillTreeMaxAggregateInputType = {
    Name?: true
    MasterLevel?: true
    MasterPoint?: true
    MasterExperience?: true
    MasterSkill?: true
  }

  export type MasterSkillTreeCountAggregateInputType = {
    Name?: true
    MasterLevel?: true
    MasterPoint?: true
    MasterExperience?: true
    MasterSkill?: true
    _all?: true
  }

  export type MasterSkillTreeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterSkillTree to aggregate.
     */
    where?: MasterSkillTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterSkillTrees to fetch.
     */
    orderBy?: MasterSkillTreeOrderByWithRelationInput | MasterSkillTreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterSkillTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterSkillTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterSkillTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterSkillTrees
    **/
    _count?: true | MasterSkillTreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterSkillTreeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterSkillTreeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterSkillTreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterSkillTreeMaxAggregateInputType
  }

  export type GetMasterSkillTreeAggregateType<T extends MasterSkillTreeAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterSkillTree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterSkillTree[P]>
      : GetScalarType<T[P], AggregateMasterSkillTree[P]>
  }




  export type MasterSkillTreeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterSkillTreeWhereInput
    orderBy?: MasterSkillTreeOrderByWithAggregationInput | MasterSkillTreeOrderByWithAggregationInput[]
    by: MasterSkillTreeScalarFieldEnum[] | MasterSkillTreeScalarFieldEnum
    having?: MasterSkillTreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterSkillTreeCountAggregateInputType | true
    _avg?: MasterSkillTreeAvgAggregateInputType
    _sum?: MasterSkillTreeSumAggregateInputType
    _min?: MasterSkillTreeMinAggregateInputType
    _max?: MasterSkillTreeMaxAggregateInputType
  }

  export type MasterSkillTreeGroupByOutputType = {
    Name: string
    MasterLevel: number | null
    MasterPoint: number | null
    MasterExperience: bigint | null
    MasterSkill: Buffer | null
    _count: MasterSkillTreeCountAggregateOutputType | null
    _avg: MasterSkillTreeAvgAggregateOutputType | null
    _sum: MasterSkillTreeSumAggregateOutputType | null
    _min: MasterSkillTreeMinAggregateOutputType | null
    _max: MasterSkillTreeMaxAggregateOutputType | null
  }

  type GetMasterSkillTreeGroupByPayload<T extends MasterSkillTreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterSkillTreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterSkillTreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterSkillTreeGroupByOutputType[P]>
            : GetScalarType<T[P], MasterSkillTreeGroupByOutputType[P]>
        }
      >
    >


  export type MasterSkillTreeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    MasterLevel?: boolean
    MasterPoint?: boolean
    MasterExperience?: boolean
    MasterSkill?: boolean
  }, ExtArgs["result"]["masterSkillTree"]>

  export type MasterSkillTreeSelectScalar = {
    Name?: boolean
    MasterLevel?: boolean
    MasterPoint?: boolean
    MasterExperience?: boolean
    MasterSkill?: boolean
  }


  export type $MasterSkillTreePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterSkillTree"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      MasterLevel: number | null
      MasterPoint: number | null
      MasterExperience: bigint | null
      MasterSkill: Buffer | null
    }, ExtArgs["result"]["masterSkillTree"]>
    composites: {}
  }


  type MasterSkillTreeGetPayload<S extends boolean | null | undefined | MasterSkillTreeDefaultArgs> = $Result.GetResult<Prisma.$MasterSkillTreePayload, S>

  type MasterSkillTreeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MasterSkillTreeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MasterSkillTreeCountAggregateInputType | true
    }

  export interface MasterSkillTreeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterSkillTree'], meta: { name: 'MasterSkillTree' } }
    /**
     * Find zero or one MasterSkillTree that matches the filter.
     * @param {MasterSkillTreeFindUniqueArgs} args - Arguments to find a MasterSkillTree
     * @example
     * // Get one MasterSkillTree
     * const masterSkillTree = await prisma.masterSkillTree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MasterSkillTreeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MasterSkillTreeFindUniqueArgs<ExtArgs>>
    ): Prisma__MasterSkillTreeClient<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MasterSkillTree that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MasterSkillTreeFindUniqueOrThrowArgs} args - Arguments to find a MasterSkillTree
     * @example
     * // Get one MasterSkillTree
     * const masterSkillTree = await prisma.masterSkillTree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MasterSkillTreeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterSkillTreeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MasterSkillTreeClient<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MasterSkillTree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSkillTreeFindFirstArgs} args - Arguments to find a MasterSkillTree
     * @example
     * // Get one MasterSkillTree
     * const masterSkillTree = await prisma.masterSkillTree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MasterSkillTreeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterSkillTreeFindFirstArgs<ExtArgs>>
    ): Prisma__MasterSkillTreeClient<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MasterSkillTree that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSkillTreeFindFirstOrThrowArgs} args - Arguments to find a MasterSkillTree
     * @example
     * // Get one MasterSkillTree
     * const masterSkillTree = await prisma.masterSkillTree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MasterSkillTreeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterSkillTreeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MasterSkillTreeClient<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MasterSkillTrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSkillTreeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterSkillTrees
     * const masterSkillTrees = await prisma.masterSkillTree.findMany()
     * 
     * // Get first 10 MasterSkillTrees
     * const masterSkillTrees = await prisma.masterSkillTree.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const masterSkillTreeWithNameOnly = await prisma.masterSkillTree.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends MasterSkillTreeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterSkillTreeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MasterSkillTree.
     * @param {MasterSkillTreeCreateArgs} args - Arguments to create a MasterSkillTree.
     * @example
     * // Create one MasterSkillTree
     * const MasterSkillTree = await prisma.masterSkillTree.create({
     *   data: {
     *     // ... data to create a MasterSkillTree
     *   }
     * })
     * 
    **/
    create<T extends MasterSkillTreeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MasterSkillTreeCreateArgs<ExtArgs>>
    ): Prisma__MasterSkillTreeClient<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MasterSkillTrees.
     *     @param {MasterSkillTreeCreateManyArgs} args - Arguments to create many MasterSkillTrees.
     *     @example
     *     // Create many MasterSkillTrees
     *     const masterSkillTree = await prisma.masterSkillTree.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MasterSkillTreeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterSkillTreeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterSkillTree.
     * @param {MasterSkillTreeDeleteArgs} args - Arguments to delete one MasterSkillTree.
     * @example
     * // Delete one MasterSkillTree
     * const MasterSkillTree = await prisma.masterSkillTree.delete({
     *   where: {
     *     // ... filter to delete one MasterSkillTree
     *   }
     * })
     * 
    **/
    delete<T extends MasterSkillTreeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MasterSkillTreeDeleteArgs<ExtArgs>>
    ): Prisma__MasterSkillTreeClient<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MasterSkillTree.
     * @param {MasterSkillTreeUpdateArgs} args - Arguments to update one MasterSkillTree.
     * @example
     * // Update one MasterSkillTree
     * const masterSkillTree = await prisma.masterSkillTree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MasterSkillTreeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MasterSkillTreeUpdateArgs<ExtArgs>>
    ): Prisma__MasterSkillTreeClient<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MasterSkillTrees.
     * @param {MasterSkillTreeDeleteManyArgs} args - Arguments to filter MasterSkillTrees to delete.
     * @example
     * // Delete a few MasterSkillTrees
     * const { count } = await prisma.masterSkillTree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MasterSkillTreeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MasterSkillTreeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterSkillTrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSkillTreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterSkillTrees
     * const masterSkillTree = await prisma.masterSkillTree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MasterSkillTreeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MasterSkillTreeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterSkillTree.
     * @param {MasterSkillTreeUpsertArgs} args - Arguments to update or create a MasterSkillTree.
     * @example
     * // Update or create a MasterSkillTree
     * const masterSkillTree = await prisma.masterSkillTree.upsert({
     *   create: {
     *     // ... data to create a MasterSkillTree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterSkillTree we want to update
     *   }
     * })
    **/
    upsert<T extends MasterSkillTreeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MasterSkillTreeUpsertArgs<ExtArgs>>
    ): Prisma__MasterSkillTreeClient<$Result.GetResult<Prisma.$MasterSkillTreePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MasterSkillTrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSkillTreeCountArgs} args - Arguments to filter MasterSkillTrees to count.
     * @example
     * // Count the number of MasterSkillTrees
     * const count = await prisma.masterSkillTree.count({
     *   where: {
     *     // ... the filter for the MasterSkillTrees we want to count
     *   }
     * })
    **/
    count<T extends MasterSkillTreeCountArgs>(
      args?: Subset<T, MasterSkillTreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterSkillTreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterSkillTree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSkillTreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterSkillTreeAggregateArgs>(args: Subset<T, MasterSkillTreeAggregateArgs>): Prisma.PrismaPromise<GetMasterSkillTreeAggregateType<T>>

    /**
     * Group by MasterSkillTree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterSkillTreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterSkillTreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterSkillTreeGroupByArgs['orderBy'] }
        : { orderBy?: MasterSkillTreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterSkillTreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterSkillTreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterSkillTree model
   */
  readonly fields: MasterSkillTreeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterSkillTree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterSkillTreeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MasterSkillTree model
   */ 
  interface MasterSkillTreeFieldRefs {
    readonly Name: FieldRef<"MasterSkillTree", 'String'>
    readonly MasterLevel: FieldRef<"MasterSkillTree", 'Int'>
    readonly MasterPoint: FieldRef<"MasterSkillTree", 'Int'>
    readonly MasterExperience: FieldRef<"MasterSkillTree", 'BigInt'>
    readonly MasterSkill: FieldRef<"MasterSkillTree", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * MasterSkillTree findUnique
   */
  export type MasterSkillTreeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * Filter, which MasterSkillTree to fetch.
     */
    where: MasterSkillTreeWhereUniqueInput
  }


  /**
   * MasterSkillTree findUniqueOrThrow
   */
  export type MasterSkillTreeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * Filter, which MasterSkillTree to fetch.
     */
    where: MasterSkillTreeWhereUniqueInput
  }


  /**
   * MasterSkillTree findFirst
   */
  export type MasterSkillTreeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * Filter, which MasterSkillTree to fetch.
     */
    where?: MasterSkillTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterSkillTrees to fetch.
     */
    orderBy?: MasterSkillTreeOrderByWithRelationInput | MasterSkillTreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterSkillTrees.
     */
    cursor?: MasterSkillTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterSkillTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterSkillTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterSkillTrees.
     */
    distinct?: MasterSkillTreeScalarFieldEnum | MasterSkillTreeScalarFieldEnum[]
  }


  /**
   * MasterSkillTree findFirstOrThrow
   */
  export type MasterSkillTreeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * Filter, which MasterSkillTree to fetch.
     */
    where?: MasterSkillTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterSkillTrees to fetch.
     */
    orderBy?: MasterSkillTreeOrderByWithRelationInput | MasterSkillTreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterSkillTrees.
     */
    cursor?: MasterSkillTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterSkillTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterSkillTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterSkillTrees.
     */
    distinct?: MasterSkillTreeScalarFieldEnum | MasterSkillTreeScalarFieldEnum[]
  }


  /**
   * MasterSkillTree findMany
   */
  export type MasterSkillTreeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * Filter, which MasterSkillTrees to fetch.
     */
    where?: MasterSkillTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterSkillTrees to fetch.
     */
    orderBy?: MasterSkillTreeOrderByWithRelationInput | MasterSkillTreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterSkillTrees.
     */
    cursor?: MasterSkillTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterSkillTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterSkillTrees.
     */
    skip?: number
    distinct?: MasterSkillTreeScalarFieldEnum | MasterSkillTreeScalarFieldEnum[]
  }


  /**
   * MasterSkillTree create
   */
  export type MasterSkillTreeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * The data needed to create a MasterSkillTree.
     */
    data: XOR<MasterSkillTreeCreateInput, MasterSkillTreeUncheckedCreateInput>
  }


  /**
   * MasterSkillTree createMany
   */
  export type MasterSkillTreeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterSkillTrees.
     */
    data: MasterSkillTreeCreateManyInput | MasterSkillTreeCreateManyInput[]
  }


  /**
   * MasterSkillTree update
   */
  export type MasterSkillTreeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * The data needed to update a MasterSkillTree.
     */
    data: XOR<MasterSkillTreeUpdateInput, MasterSkillTreeUncheckedUpdateInput>
    /**
     * Choose, which MasterSkillTree to update.
     */
    where: MasterSkillTreeWhereUniqueInput
  }


  /**
   * MasterSkillTree updateMany
   */
  export type MasterSkillTreeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterSkillTrees.
     */
    data: XOR<MasterSkillTreeUpdateManyMutationInput, MasterSkillTreeUncheckedUpdateManyInput>
    /**
     * Filter which MasterSkillTrees to update
     */
    where?: MasterSkillTreeWhereInput
  }


  /**
   * MasterSkillTree upsert
   */
  export type MasterSkillTreeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * The filter to search for the MasterSkillTree to update in case it exists.
     */
    where: MasterSkillTreeWhereUniqueInput
    /**
     * In case the MasterSkillTree found by the `where` argument doesn't exist, create a new MasterSkillTree with this data.
     */
    create: XOR<MasterSkillTreeCreateInput, MasterSkillTreeUncheckedCreateInput>
    /**
     * In case the MasterSkillTree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterSkillTreeUpdateInput, MasterSkillTreeUncheckedUpdateInput>
  }


  /**
   * MasterSkillTree delete
   */
  export type MasterSkillTreeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
    /**
     * Filter which MasterSkillTree to delete.
     */
    where: MasterSkillTreeWhereUniqueInput
  }


  /**
   * MasterSkillTree deleteMany
   */
  export type MasterSkillTreeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterSkillTrees to delete
     */
    where?: MasterSkillTreeWhereInput
  }


  /**
   * MasterSkillTree without action
   */
  export type MasterSkillTreeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterSkillTree
     */
    select?: MasterSkillTreeSelect<ExtArgs> | null
  }



  /**
   * Model MuCastle_DATA
   */

  export type AggregateMuCastle_DATA = {
    _count: MuCastle_DATACountAggregateOutputType | null
    _avg: MuCastle_DATAAvgAggregateOutputType | null
    _sum: MuCastle_DATASumAggregateOutputType | null
    _min: MuCastle_DATAMinAggregateOutputType | null
    _max: MuCastle_DATAMaxAggregateOutputType | null
  }

  export type MuCastle_DATAAvgAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    MONEY: number | null
    TAX_RATE_CHAOS: number | null
    TAX_RATE_STORE: number | null
    TAX_HUNT_ZONE: number | null
  }

  export type MuCastle_DATASumAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    MONEY: number | null
    TAX_RATE_CHAOS: number | null
    TAX_RATE_STORE: number | null
    TAX_HUNT_ZONE: number | null
  }

  export type MuCastle_DATAMinAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    SIEGE_START_DATE: Date | null
    SIEGE_END_DATE: Date | null
    SIEGE_GUILDLIST_SETTED: boolean | null
    SIEGE_ENDED: boolean | null
    CASTLE_OCCUPY: boolean | null
    OWNER_GUILD: string | null
    MONEY: number | null
    TAX_RATE_CHAOS: number | null
    TAX_RATE_STORE: number | null
    TAX_HUNT_ZONE: number | null
  }

  export type MuCastle_DATAMaxAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    SIEGE_START_DATE: Date | null
    SIEGE_END_DATE: Date | null
    SIEGE_GUILDLIST_SETTED: boolean | null
    SIEGE_ENDED: boolean | null
    CASTLE_OCCUPY: boolean | null
    OWNER_GUILD: string | null
    MONEY: number | null
    TAX_RATE_CHAOS: number | null
    TAX_RATE_STORE: number | null
    TAX_HUNT_ZONE: number | null
  }

  export type MuCastle_DATACountAggregateOutputType = {
    MAP_SVR_GROUP: number
    SIEGE_START_DATE: number
    SIEGE_END_DATE: number
    SIEGE_GUILDLIST_SETTED: number
    SIEGE_ENDED: number
    CASTLE_OCCUPY: number
    OWNER_GUILD: number
    MONEY: number
    TAX_RATE_CHAOS: number
    TAX_RATE_STORE: number
    TAX_HUNT_ZONE: number
    _all: number
  }


  export type MuCastle_DATAAvgAggregateInputType = {
    MAP_SVR_GROUP?: true
    MONEY?: true
    TAX_RATE_CHAOS?: true
    TAX_RATE_STORE?: true
    TAX_HUNT_ZONE?: true
  }

  export type MuCastle_DATASumAggregateInputType = {
    MAP_SVR_GROUP?: true
    MONEY?: true
    TAX_RATE_CHAOS?: true
    TAX_RATE_STORE?: true
    TAX_HUNT_ZONE?: true
  }

  export type MuCastle_DATAMinAggregateInputType = {
    MAP_SVR_GROUP?: true
    SIEGE_START_DATE?: true
    SIEGE_END_DATE?: true
    SIEGE_GUILDLIST_SETTED?: true
    SIEGE_ENDED?: true
    CASTLE_OCCUPY?: true
    OWNER_GUILD?: true
    MONEY?: true
    TAX_RATE_CHAOS?: true
    TAX_RATE_STORE?: true
    TAX_HUNT_ZONE?: true
  }

  export type MuCastle_DATAMaxAggregateInputType = {
    MAP_SVR_GROUP?: true
    SIEGE_START_DATE?: true
    SIEGE_END_DATE?: true
    SIEGE_GUILDLIST_SETTED?: true
    SIEGE_ENDED?: true
    CASTLE_OCCUPY?: true
    OWNER_GUILD?: true
    MONEY?: true
    TAX_RATE_CHAOS?: true
    TAX_RATE_STORE?: true
    TAX_HUNT_ZONE?: true
  }

  export type MuCastle_DATACountAggregateInputType = {
    MAP_SVR_GROUP?: true
    SIEGE_START_DATE?: true
    SIEGE_END_DATE?: true
    SIEGE_GUILDLIST_SETTED?: true
    SIEGE_ENDED?: true
    CASTLE_OCCUPY?: true
    OWNER_GUILD?: true
    MONEY?: true
    TAX_RATE_CHAOS?: true
    TAX_RATE_STORE?: true
    TAX_HUNT_ZONE?: true
    _all?: true
  }

  export type MuCastle_DATAAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MuCastle_DATA to aggregate.
     */
    where?: MuCastle_DATAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_DATA to fetch.
     */
    orderBy?: MuCastle_DATAOrderByWithRelationInput | MuCastle_DATAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MuCastle_DATAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_DATA from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_DATA.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MuCastle_DATA
    **/
    _count?: true | MuCastle_DATACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MuCastle_DATAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MuCastle_DATASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuCastle_DATAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuCastle_DATAMaxAggregateInputType
  }

  export type GetMuCastle_DATAAggregateType<T extends MuCastle_DATAAggregateArgs> = {
        [P in keyof T & keyof AggregateMuCastle_DATA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMuCastle_DATA[P]>
      : GetScalarType<T[P], AggregateMuCastle_DATA[P]>
  }




  export type MuCastle_DATAGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuCastle_DATAWhereInput
    orderBy?: MuCastle_DATAOrderByWithAggregationInput | MuCastle_DATAOrderByWithAggregationInput[]
    by: MuCastle_DATAScalarFieldEnum[] | MuCastle_DATAScalarFieldEnum
    having?: MuCastle_DATAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuCastle_DATACountAggregateInputType | true
    _avg?: MuCastle_DATAAvgAggregateInputType
    _sum?: MuCastle_DATASumAggregateInputType
    _min?: MuCastle_DATAMinAggregateInputType
    _max?: MuCastle_DATAMaxAggregateInputType
  }

  export type MuCastle_DATAGroupByOutputType = {
    MAP_SVR_GROUP: number
    SIEGE_START_DATE: Date
    SIEGE_END_DATE: Date
    SIEGE_GUILDLIST_SETTED: boolean
    SIEGE_ENDED: boolean
    CASTLE_OCCUPY: boolean
    OWNER_GUILD: string
    MONEY: number
    TAX_RATE_CHAOS: number
    TAX_RATE_STORE: number
    TAX_HUNT_ZONE: number
    _count: MuCastle_DATACountAggregateOutputType | null
    _avg: MuCastle_DATAAvgAggregateOutputType | null
    _sum: MuCastle_DATASumAggregateOutputType | null
    _min: MuCastle_DATAMinAggregateOutputType | null
    _max: MuCastle_DATAMaxAggregateOutputType | null
  }

  type GetMuCastle_DATAGroupByPayload<T extends MuCastle_DATAGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MuCastle_DATAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MuCastle_DATAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MuCastle_DATAGroupByOutputType[P]>
            : GetScalarType<T[P], MuCastle_DATAGroupByOutputType[P]>
        }
      >
    >


  export type MuCastle_DATASelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MAP_SVR_GROUP?: boolean
    SIEGE_START_DATE?: boolean
    SIEGE_END_DATE?: boolean
    SIEGE_GUILDLIST_SETTED?: boolean
    SIEGE_ENDED?: boolean
    CASTLE_OCCUPY?: boolean
    OWNER_GUILD?: boolean
    MONEY?: boolean
    TAX_RATE_CHAOS?: boolean
    TAX_RATE_STORE?: boolean
    TAX_HUNT_ZONE?: boolean
  }, ExtArgs["result"]["muCastle_DATA"]>

  export type MuCastle_DATASelectScalar = {
    MAP_SVR_GROUP?: boolean
    SIEGE_START_DATE?: boolean
    SIEGE_END_DATE?: boolean
    SIEGE_GUILDLIST_SETTED?: boolean
    SIEGE_ENDED?: boolean
    CASTLE_OCCUPY?: boolean
    OWNER_GUILD?: boolean
    MONEY?: boolean
    TAX_RATE_CHAOS?: boolean
    TAX_RATE_STORE?: boolean
    TAX_HUNT_ZONE?: boolean
  }


  export type $MuCastle_DATAPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MuCastle_DATA"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      MAP_SVR_GROUP: number
      SIEGE_START_DATE: Date
      SIEGE_END_DATE: Date
      SIEGE_GUILDLIST_SETTED: boolean
      SIEGE_ENDED: boolean
      CASTLE_OCCUPY: boolean
      OWNER_GUILD: string
      MONEY: number
      TAX_RATE_CHAOS: number
      TAX_RATE_STORE: number
      TAX_HUNT_ZONE: number
    }, ExtArgs["result"]["muCastle_DATA"]>
    composites: {}
  }


  type MuCastle_DATAGetPayload<S extends boolean | null | undefined | MuCastle_DATADefaultArgs> = $Result.GetResult<Prisma.$MuCastle_DATAPayload, S>

  type MuCastle_DATACountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MuCastle_DATAFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MuCastle_DATACountAggregateInputType | true
    }

  export interface MuCastle_DATADelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MuCastle_DATA'], meta: { name: 'MuCastle_DATA' } }
    /**
     * Find zero or one MuCastle_DATA that matches the filter.
     * @param {MuCastle_DATAFindUniqueArgs} args - Arguments to find a MuCastle_DATA
     * @example
     * // Get one MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MuCastle_DATAFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_DATAFindUniqueArgs<ExtArgs>>
    ): Prisma__MuCastle_DATAClient<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MuCastle_DATA that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MuCastle_DATAFindUniqueOrThrowArgs} args - Arguments to find a MuCastle_DATA
     * @example
     * // Get one MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MuCastle_DATAFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_DATAFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MuCastle_DATAClient<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MuCastle_DATA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_DATAFindFirstArgs} args - Arguments to find a MuCastle_DATA
     * @example
     * // Get one MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MuCastle_DATAFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_DATAFindFirstArgs<ExtArgs>>
    ): Prisma__MuCastle_DATAClient<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MuCastle_DATA that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_DATAFindFirstOrThrowArgs} args - Arguments to find a MuCastle_DATA
     * @example
     * // Get one MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MuCastle_DATAFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_DATAFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MuCastle_DATAClient<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MuCastle_DATA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_DATAFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.findMany()
     * 
     * // Get first 10 MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.findMany({ take: 10 })
     * 
     * // Only select the `MAP_SVR_GROUP`
     * const muCastle_DATAWithMAP_SVR_GROUPOnly = await prisma.muCastle_DATA.findMany({ select: { MAP_SVR_GROUP: true } })
     * 
    **/
    findMany<T extends MuCastle_DATAFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_DATAFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MuCastle_DATA.
     * @param {MuCastle_DATACreateArgs} args - Arguments to create a MuCastle_DATA.
     * @example
     * // Create one MuCastle_DATA
     * const MuCastle_DATA = await prisma.muCastle_DATA.create({
     *   data: {
     *     // ... data to create a MuCastle_DATA
     *   }
     * })
     * 
    **/
    create<T extends MuCastle_DATACreateArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_DATACreateArgs<ExtArgs>>
    ): Prisma__MuCastle_DATAClient<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MuCastle_DATA.
     *     @param {MuCastle_DATACreateManyArgs} args - Arguments to create many MuCastle_DATA.
     *     @example
     *     // Create many MuCastle_DATA
     *     const muCastle_DATA = await prisma.muCastle_DATA.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MuCastle_DATACreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_DATACreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MuCastle_DATA.
     * @param {MuCastle_DATADeleteArgs} args - Arguments to delete one MuCastle_DATA.
     * @example
     * // Delete one MuCastle_DATA
     * const MuCastle_DATA = await prisma.muCastle_DATA.delete({
     *   where: {
     *     // ... filter to delete one MuCastle_DATA
     *   }
     * })
     * 
    **/
    delete<T extends MuCastle_DATADeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_DATADeleteArgs<ExtArgs>>
    ): Prisma__MuCastle_DATAClient<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MuCastle_DATA.
     * @param {MuCastle_DATAUpdateArgs} args - Arguments to update one MuCastle_DATA.
     * @example
     * // Update one MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MuCastle_DATAUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_DATAUpdateArgs<ExtArgs>>
    ): Prisma__MuCastle_DATAClient<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MuCastle_DATA.
     * @param {MuCastle_DATADeleteManyArgs} args - Arguments to filter MuCastle_DATA to delete.
     * @example
     * // Delete a few MuCastle_DATA
     * const { count } = await prisma.muCastle_DATA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MuCastle_DATADeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_DATADeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MuCastle_DATA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_DATAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MuCastle_DATAUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_DATAUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MuCastle_DATA.
     * @param {MuCastle_DATAUpsertArgs} args - Arguments to update or create a MuCastle_DATA.
     * @example
     * // Update or create a MuCastle_DATA
     * const muCastle_DATA = await prisma.muCastle_DATA.upsert({
     *   create: {
     *     // ... data to create a MuCastle_DATA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MuCastle_DATA we want to update
     *   }
     * })
    **/
    upsert<T extends MuCastle_DATAUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_DATAUpsertArgs<ExtArgs>>
    ): Prisma__MuCastle_DATAClient<$Result.GetResult<Prisma.$MuCastle_DATAPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MuCastle_DATA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_DATACountArgs} args - Arguments to filter MuCastle_DATA to count.
     * @example
     * // Count the number of MuCastle_DATA
     * const count = await prisma.muCastle_DATA.count({
     *   where: {
     *     // ... the filter for the MuCastle_DATA we want to count
     *   }
     * })
    **/
    count<T extends MuCastle_DATACountArgs>(
      args?: Subset<T, MuCastle_DATACountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuCastle_DATACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MuCastle_DATA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_DATAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuCastle_DATAAggregateArgs>(args: Subset<T, MuCastle_DATAAggregateArgs>): Prisma.PrismaPromise<GetMuCastle_DATAAggregateType<T>>

    /**
     * Group by MuCastle_DATA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_DATAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuCastle_DATAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuCastle_DATAGroupByArgs['orderBy'] }
        : { orderBy?: MuCastle_DATAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuCastle_DATAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuCastle_DATAGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MuCastle_DATA model
   */
  readonly fields: MuCastle_DATAFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MuCastle_DATA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MuCastle_DATAClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MuCastle_DATA model
   */ 
  interface MuCastle_DATAFieldRefs {
    readonly MAP_SVR_GROUP: FieldRef<"MuCastle_DATA", 'Int'>
    readonly SIEGE_START_DATE: FieldRef<"MuCastle_DATA", 'DateTime'>
    readonly SIEGE_END_DATE: FieldRef<"MuCastle_DATA", 'DateTime'>
    readonly SIEGE_GUILDLIST_SETTED: FieldRef<"MuCastle_DATA", 'Boolean'>
    readonly SIEGE_ENDED: FieldRef<"MuCastle_DATA", 'Boolean'>
    readonly CASTLE_OCCUPY: FieldRef<"MuCastle_DATA", 'Boolean'>
    readonly OWNER_GUILD: FieldRef<"MuCastle_DATA", 'String'>
    readonly MONEY: FieldRef<"MuCastle_DATA", 'Float'>
    readonly TAX_RATE_CHAOS: FieldRef<"MuCastle_DATA", 'Int'>
    readonly TAX_RATE_STORE: FieldRef<"MuCastle_DATA", 'Int'>
    readonly TAX_HUNT_ZONE: FieldRef<"MuCastle_DATA", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MuCastle_DATA findUnique
   */
  export type MuCastle_DATAFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_DATA to fetch.
     */
    where: MuCastle_DATAWhereUniqueInput
  }


  /**
   * MuCastle_DATA findUniqueOrThrow
   */
  export type MuCastle_DATAFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_DATA to fetch.
     */
    where: MuCastle_DATAWhereUniqueInput
  }


  /**
   * MuCastle_DATA findFirst
   */
  export type MuCastle_DATAFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_DATA to fetch.
     */
    where?: MuCastle_DATAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_DATA to fetch.
     */
    orderBy?: MuCastle_DATAOrderByWithRelationInput | MuCastle_DATAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuCastle_DATA.
     */
    cursor?: MuCastle_DATAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_DATA from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_DATA.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuCastle_DATA.
     */
    distinct?: MuCastle_DATAScalarFieldEnum | MuCastle_DATAScalarFieldEnum[]
  }


  /**
   * MuCastle_DATA findFirstOrThrow
   */
  export type MuCastle_DATAFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_DATA to fetch.
     */
    where?: MuCastle_DATAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_DATA to fetch.
     */
    orderBy?: MuCastle_DATAOrderByWithRelationInput | MuCastle_DATAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuCastle_DATA.
     */
    cursor?: MuCastle_DATAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_DATA from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_DATA.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuCastle_DATA.
     */
    distinct?: MuCastle_DATAScalarFieldEnum | MuCastle_DATAScalarFieldEnum[]
  }


  /**
   * MuCastle_DATA findMany
   */
  export type MuCastle_DATAFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_DATA to fetch.
     */
    where?: MuCastle_DATAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_DATA to fetch.
     */
    orderBy?: MuCastle_DATAOrderByWithRelationInput | MuCastle_DATAOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MuCastle_DATA.
     */
    cursor?: MuCastle_DATAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_DATA from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_DATA.
     */
    skip?: number
    distinct?: MuCastle_DATAScalarFieldEnum | MuCastle_DATAScalarFieldEnum[]
  }


  /**
   * MuCastle_DATA create
   */
  export type MuCastle_DATACreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * The data needed to create a MuCastle_DATA.
     */
    data: XOR<MuCastle_DATACreateInput, MuCastle_DATAUncheckedCreateInput>
  }


  /**
   * MuCastle_DATA createMany
   */
  export type MuCastle_DATACreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MuCastle_DATA.
     */
    data: MuCastle_DATACreateManyInput | MuCastle_DATACreateManyInput[]
  }


  /**
   * MuCastle_DATA update
   */
  export type MuCastle_DATAUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * The data needed to update a MuCastle_DATA.
     */
    data: XOR<MuCastle_DATAUpdateInput, MuCastle_DATAUncheckedUpdateInput>
    /**
     * Choose, which MuCastle_DATA to update.
     */
    where: MuCastle_DATAWhereUniqueInput
  }


  /**
   * MuCastle_DATA updateMany
   */
  export type MuCastle_DATAUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MuCastle_DATA.
     */
    data: XOR<MuCastle_DATAUpdateManyMutationInput, MuCastle_DATAUncheckedUpdateManyInput>
    /**
     * Filter which MuCastle_DATA to update
     */
    where?: MuCastle_DATAWhereInput
  }


  /**
   * MuCastle_DATA upsert
   */
  export type MuCastle_DATAUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * The filter to search for the MuCastle_DATA to update in case it exists.
     */
    where: MuCastle_DATAWhereUniqueInput
    /**
     * In case the MuCastle_DATA found by the `where` argument doesn't exist, create a new MuCastle_DATA with this data.
     */
    create: XOR<MuCastle_DATACreateInput, MuCastle_DATAUncheckedCreateInput>
    /**
     * In case the MuCastle_DATA was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MuCastle_DATAUpdateInput, MuCastle_DATAUncheckedUpdateInput>
  }


  /**
   * MuCastle_DATA delete
   */
  export type MuCastle_DATADeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
    /**
     * Filter which MuCastle_DATA to delete.
     */
    where: MuCastle_DATAWhereUniqueInput
  }


  /**
   * MuCastle_DATA deleteMany
   */
  export type MuCastle_DATADeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MuCastle_DATA to delete
     */
    where?: MuCastle_DATAWhereInput
  }


  /**
   * MuCastle_DATA without action
   */
  export type MuCastle_DATADefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_DATA
     */
    select?: MuCastle_DATASelect<ExtArgs> | null
  }



  /**
   * Model MuCastle_NPC
   */

  export type AggregateMuCastle_NPC = {
    _count: MuCastle_NPCCountAggregateOutputType | null
    _avg: MuCastle_NPCAvgAggregateOutputType | null
    _sum: MuCastle_NPCSumAggregateOutputType | null
    _min: MuCastle_NPCMinAggregateOutputType | null
    _max: MuCastle_NPCMaxAggregateOutputType | null
  }

  export type MuCastle_NPCAvgAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    NPC_NUMBER: number | null
    NPC_INDEX: number | null
    NPC_DF_LEVEL: number | null
    NPC_RG_LEVEL: number | null
    NPC_MAXHP: number | null
    NPC_HP: number | null
    NPC_X: number | null
    NPC_Y: number | null
    NPC_DIR: number | null
  }

  export type MuCastle_NPCSumAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    NPC_NUMBER: number | null
    NPC_INDEX: number | null
    NPC_DF_LEVEL: number | null
    NPC_RG_LEVEL: number | null
    NPC_MAXHP: number | null
    NPC_HP: number | null
    NPC_X: number | null
    NPC_Y: number | null
    NPC_DIR: number | null
  }

  export type MuCastle_NPCMinAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    NPC_NUMBER: number | null
    NPC_INDEX: number | null
    NPC_DF_LEVEL: number | null
    NPC_RG_LEVEL: number | null
    NPC_MAXHP: number | null
    NPC_HP: number | null
    NPC_X: number | null
    NPC_Y: number | null
    NPC_DIR: number | null
    NPC_CREATEDATE: Date | null
  }

  export type MuCastle_NPCMaxAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    NPC_NUMBER: number | null
    NPC_INDEX: number | null
    NPC_DF_LEVEL: number | null
    NPC_RG_LEVEL: number | null
    NPC_MAXHP: number | null
    NPC_HP: number | null
    NPC_X: number | null
    NPC_Y: number | null
    NPC_DIR: number | null
    NPC_CREATEDATE: Date | null
  }

  export type MuCastle_NPCCountAggregateOutputType = {
    MAP_SVR_GROUP: number
    NPC_NUMBER: number
    NPC_INDEX: number
    NPC_DF_LEVEL: number
    NPC_RG_LEVEL: number
    NPC_MAXHP: number
    NPC_HP: number
    NPC_X: number
    NPC_Y: number
    NPC_DIR: number
    NPC_CREATEDATE: number
    _all: number
  }


  export type MuCastle_NPCAvgAggregateInputType = {
    MAP_SVR_GROUP?: true
    NPC_NUMBER?: true
    NPC_INDEX?: true
    NPC_DF_LEVEL?: true
    NPC_RG_LEVEL?: true
    NPC_MAXHP?: true
    NPC_HP?: true
    NPC_X?: true
    NPC_Y?: true
    NPC_DIR?: true
  }

  export type MuCastle_NPCSumAggregateInputType = {
    MAP_SVR_GROUP?: true
    NPC_NUMBER?: true
    NPC_INDEX?: true
    NPC_DF_LEVEL?: true
    NPC_RG_LEVEL?: true
    NPC_MAXHP?: true
    NPC_HP?: true
    NPC_X?: true
    NPC_Y?: true
    NPC_DIR?: true
  }

  export type MuCastle_NPCMinAggregateInputType = {
    MAP_SVR_GROUP?: true
    NPC_NUMBER?: true
    NPC_INDEX?: true
    NPC_DF_LEVEL?: true
    NPC_RG_LEVEL?: true
    NPC_MAXHP?: true
    NPC_HP?: true
    NPC_X?: true
    NPC_Y?: true
    NPC_DIR?: true
    NPC_CREATEDATE?: true
  }

  export type MuCastle_NPCMaxAggregateInputType = {
    MAP_SVR_GROUP?: true
    NPC_NUMBER?: true
    NPC_INDEX?: true
    NPC_DF_LEVEL?: true
    NPC_RG_LEVEL?: true
    NPC_MAXHP?: true
    NPC_HP?: true
    NPC_X?: true
    NPC_Y?: true
    NPC_DIR?: true
    NPC_CREATEDATE?: true
  }

  export type MuCastle_NPCCountAggregateInputType = {
    MAP_SVR_GROUP?: true
    NPC_NUMBER?: true
    NPC_INDEX?: true
    NPC_DF_LEVEL?: true
    NPC_RG_LEVEL?: true
    NPC_MAXHP?: true
    NPC_HP?: true
    NPC_X?: true
    NPC_Y?: true
    NPC_DIR?: true
    NPC_CREATEDATE?: true
    _all?: true
  }

  export type MuCastle_NPCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MuCastle_NPC to aggregate.
     */
    where?: MuCastle_NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_NPCS to fetch.
     */
    orderBy?: MuCastle_NPCOrderByWithRelationInput | MuCastle_NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MuCastle_NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MuCastle_NPCS
    **/
    _count?: true | MuCastle_NPCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MuCastle_NPCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MuCastle_NPCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuCastle_NPCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuCastle_NPCMaxAggregateInputType
  }

  export type GetMuCastle_NPCAggregateType<T extends MuCastle_NPCAggregateArgs> = {
        [P in keyof T & keyof AggregateMuCastle_NPC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMuCastle_NPC[P]>
      : GetScalarType<T[P], AggregateMuCastle_NPC[P]>
  }




  export type MuCastle_NPCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuCastle_NPCWhereInput
    orderBy?: MuCastle_NPCOrderByWithAggregationInput | MuCastle_NPCOrderByWithAggregationInput[]
    by: MuCastle_NPCScalarFieldEnum[] | MuCastle_NPCScalarFieldEnum
    having?: MuCastle_NPCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuCastle_NPCCountAggregateInputType | true
    _avg?: MuCastle_NPCAvgAggregateInputType
    _sum?: MuCastle_NPCSumAggregateInputType
    _min?: MuCastle_NPCMinAggregateInputType
    _max?: MuCastle_NPCMaxAggregateInputType
  }

  export type MuCastle_NPCGroupByOutputType = {
    MAP_SVR_GROUP: number
    NPC_NUMBER: number
    NPC_INDEX: number
    NPC_DF_LEVEL: number
    NPC_RG_LEVEL: number
    NPC_MAXHP: number
    NPC_HP: number
    NPC_X: number
    NPC_Y: number
    NPC_DIR: number
    NPC_CREATEDATE: Date
    _count: MuCastle_NPCCountAggregateOutputType | null
    _avg: MuCastle_NPCAvgAggregateOutputType | null
    _sum: MuCastle_NPCSumAggregateOutputType | null
    _min: MuCastle_NPCMinAggregateOutputType | null
    _max: MuCastle_NPCMaxAggregateOutputType | null
  }

  type GetMuCastle_NPCGroupByPayload<T extends MuCastle_NPCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MuCastle_NPCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MuCastle_NPCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MuCastle_NPCGroupByOutputType[P]>
            : GetScalarType<T[P], MuCastle_NPCGroupByOutputType[P]>
        }
      >
    >


  export type MuCastle_NPCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MAP_SVR_GROUP?: boolean
    NPC_NUMBER?: boolean
    NPC_INDEX?: boolean
    NPC_DF_LEVEL?: boolean
    NPC_RG_LEVEL?: boolean
    NPC_MAXHP?: boolean
    NPC_HP?: boolean
    NPC_X?: boolean
    NPC_Y?: boolean
    NPC_DIR?: boolean
    NPC_CREATEDATE?: boolean
  }, ExtArgs["result"]["muCastle_NPC"]>

  export type MuCastle_NPCSelectScalar = {
    MAP_SVR_GROUP?: boolean
    NPC_NUMBER?: boolean
    NPC_INDEX?: boolean
    NPC_DF_LEVEL?: boolean
    NPC_RG_LEVEL?: boolean
    NPC_MAXHP?: boolean
    NPC_HP?: boolean
    NPC_X?: boolean
    NPC_Y?: boolean
    NPC_DIR?: boolean
    NPC_CREATEDATE?: boolean
  }


  export type $MuCastle_NPCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MuCastle_NPC"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      MAP_SVR_GROUP: number
      NPC_NUMBER: number
      NPC_INDEX: number
      NPC_DF_LEVEL: number
      NPC_RG_LEVEL: number
      NPC_MAXHP: number
      NPC_HP: number
      NPC_X: number
      NPC_Y: number
      NPC_DIR: number
      NPC_CREATEDATE: Date
    }, ExtArgs["result"]["muCastle_NPC"]>
    composites: {}
  }


  type MuCastle_NPCGetPayload<S extends boolean | null | undefined | MuCastle_NPCDefaultArgs> = $Result.GetResult<Prisma.$MuCastle_NPCPayload, S>

  type MuCastle_NPCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MuCastle_NPCFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MuCastle_NPCCountAggregateInputType | true
    }

  export interface MuCastle_NPCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MuCastle_NPC'], meta: { name: 'MuCastle_NPC' } }
    /**
     * Find zero or one MuCastle_NPC that matches the filter.
     * @param {MuCastle_NPCFindUniqueArgs} args - Arguments to find a MuCastle_NPC
     * @example
     * // Get one MuCastle_NPC
     * const muCastle_NPC = await prisma.muCastle_NPC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MuCastle_NPCFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_NPCFindUniqueArgs<ExtArgs>>
    ): Prisma__MuCastle_NPCClient<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MuCastle_NPC that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MuCastle_NPCFindUniqueOrThrowArgs} args - Arguments to find a MuCastle_NPC
     * @example
     * // Get one MuCastle_NPC
     * const muCastle_NPC = await prisma.muCastle_NPC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MuCastle_NPCFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_NPCFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MuCastle_NPCClient<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MuCastle_NPC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_NPCFindFirstArgs} args - Arguments to find a MuCastle_NPC
     * @example
     * // Get one MuCastle_NPC
     * const muCastle_NPC = await prisma.muCastle_NPC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MuCastle_NPCFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_NPCFindFirstArgs<ExtArgs>>
    ): Prisma__MuCastle_NPCClient<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MuCastle_NPC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_NPCFindFirstOrThrowArgs} args - Arguments to find a MuCastle_NPC
     * @example
     * // Get one MuCastle_NPC
     * const muCastle_NPC = await prisma.muCastle_NPC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MuCastle_NPCFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_NPCFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MuCastle_NPCClient<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MuCastle_NPCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_NPCFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MuCastle_NPCS
     * const muCastle_NPCS = await prisma.muCastle_NPC.findMany()
     * 
     * // Get first 10 MuCastle_NPCS
     * const muCastle_NPCS = await prisma.muCastle_NPC.findMany({ take: 10 })
     * 
     * // Only select the `MAP_SVR_GROUP`
     * const muCastle_NPCWithMAP_SVR_GROUPOnly = await prisma.muCastle_NPC.findMany({ select: { MAP_SVR_GROUP: true } })
     * 
    **/
    findMany<T extends MuCastle_NPCFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_NPCFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MuCastle_NPC.
     * @param {MuCastle_NPCCreateArgs} args - Arguments to create a MuCastle_NPC.
     * @example
     * // Create one MuCastle_NPC
     * const MuCastle_NPC = await prisma.muCastle_NPC.create({
     *   data: {
     *     // ... data to create a MuCastle_NPC
     *   }
     * })
     * 
    **/
    create<T extends MuCastle_NPCCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_NPCCreateArgs<ExtArgs>>
    ): Prisma__MuCastle_NPCClient<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MuCastle_NPCS.
     *     @param {MuCastle_NPCCreateManyArgs} args - Arguments to create many MuCastle_NPCS.
     *     @example
     *     // Create many MuCastle_NPCS
     *     const muCastle_NPC = await prisma.muCastle_NPC.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MuCastle_NPCCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_NPCCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MuCastle_NPC.
     * @param {MuCastle_NPCDeleteArgs} args - Arguments to delete one MuCastle_NPC.
     * @example
     * // Delete one MuCastle_NPC
     * const MuCastle_NPC = await prisma.muCastle_NPC.delete({
     *   where: {
     *     // ... filter to delete one MuCastle_NPC
     *   }
     * })
     * 
    **/
    delete<T extends MuCastle_NPCDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_NPCDeleteArgs<ExtArgs>>
    ): Prisma__MuCastle_NPCClient<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MuCastle_NPC.
     * @param {MuCastle_NPCUpdateArgs} args - Arguments to update one MuCastle_NPC.
     * @example
     * // Update one MuCastle_NPC
     * const muCastle_NPC = await prisma.muCastle_NPC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MuCastle_NPCUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_NPCUpdateArgs<ExtArgs>>
    ): Prisma__MuCastle_NPCClient<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MuCastle_NPCS.
     * @param {MuCastle_NPCDeleteManyArgs} args - Arguments to filter MuCastle_NPCS to delete.
     * @example
     * // Delete a few MuCastle_NPCS
     * const { count } = await prisma.muCastle_NPC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MuCastle_NPCDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_NPCDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MuCastle_NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_NPCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MuCastle_NPCS
     * const muCastle_NPC = await prisma.muCastle_NPC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MuCastle_NPCUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_NPCUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MuCastle_NPC.
     * @param {MuCastle_NPCUpsertArgs} args - Arguments to update or create a MuCastle_NPC.
     * @example
     * // Update or create a MuCastle_NPC
     * const muCastle_NPC = await prisma.muCastle_NPC.upsert({
     *   create: {
     *     // ... data to create a MuCastle_NPC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MuCastle_NPC we want to update
     *   }
     * })
    **/
    upsert<T extends MuCastle_NPCUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_NPCUpsertArgs<ExtArgs>>
    ): Prisma__MuCastle_NPCClient<$Result.GetResult<Prisma.$MuCastle_NPCPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MuCastle_NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_NPCCountArgs} args - Arguments to filter MuCastle_NPCS to count.
     * @example
     * // Count the number of MuCastle_NPCS
     * const count = await prisma.muCastle_NPC.count({
     *   where: {
     *     // ... the filter for the MuCastle_NPCS we want to count
     *   }
     * })
    **/
    count<T extends MuCastle_NPCCountArgs>(
      args?: Subset<T, MuCastle_NPCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuCastle_NPCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MuCastle_NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_NPCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuCastle_NPCAggregateArgs>(args: Subset<T, MuCastle_NPCAggregateArgs>): Prisma.PrismaPromise<GetMuCastle_NPCAggregateType<T>>

    /**
     * Group by MuCastle_NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_NPCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuCastle_NPCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuCastle_NPCGroupByArgs['orderBy'] }
        : { orderBy?: MuCastle_NPCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuCastle_NPCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuCastle_NPCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MuCastle_NPC model
   */
  readonly fields: MuCastle_NPCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MuCastle_NPC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MuCastle_NPCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MuCastle_NPC model
   */ 
  interface MuCastle_NPCFieldRefs {
    readonly MAP_SVR_GROUP: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_NUMBER: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_INDEX: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_DF_LEVEL: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_RG_LEVEL: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_MAXHP: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_HP: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_X: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_Y: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_DIR: FieldRef<"MuCastle_NPC", 'Int'>
    readonly NPC_CREATEDATE: FieldRef<"MuCastle_NPC", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MuCastle_NPC findUnique
   */
  export type MuCastle_NPCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_NPC to fetch.
     */
    where: MuCastle_NPCWhereUniqueInput
  }


  /**
   * MuCastle_NPC findUniqueOrThrow
   */
  export type MuCastle_NPCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_NPC to fetch.
     */
    where: MuCastle_NPCWhereUniqueInput
  }


  /**
   * MuCastle_NPC findFirst
   */
  export type MuCastle_NPCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_NPC to fetch.
     */
    where?: MuCastle_NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_NPCS to fetch.
     */
    orderBy?: MuCastle_NPCOrderByWithRelationInput | MuCastle_NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuCastle_NPCS.
     */
    cursor?: MuCastle_NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuCastle_NPCS.
     */
    distinct?: MuCastle_NPCScalarFieldEnum | MuCastle_NPCScalarFieldEnum[]
  }


  /**
   * MuCastle_NPC findFirstOrThrow
   */
  export type MuCastle_NPCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_NPC to fetch.
     */
    where?: MuCastle_NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_NPCS to fetch.
     */
    orderBy?: MuCastle_NPCOrderByWithRelationInput | MuCastle_NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuCastle_NPCS.
     */
    cursor?: MuCastle_NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuCastle_NPCS.
     */
    distinct?: MuCastle_NPCScalarFieldEnum | MuCastle_NPCScalarFieldEnum[]
  }


  /**
   * MuCastle_NPC findMany
   */
  export type MuCastle_NPCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_NPCS to fetch.
     */
    where?: MuCastle_NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_NPCS to fetch.
     */
    orderBy?: MuCastle_NPCOrderByWithRelationInput | MuCastle_NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MuCastle_NPCS.
     */
    cursor?: MuCastle_NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_NPCS.
     */
    skip?: number
    distinct?: MuCastle_NPCScalarFieldEnum | MuCastle_NPCScalarFieldEnum[]
  }


  /**
   * MuCastle_NPC create
   */
  export type MuCastle_NPCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * The data needed to create a MuCastle_NPC.
     */
    data: XOR<MuCastle_NPCCreateInput, MuCastle_NPCUncheckedCreateInput>
  }


  /**
   * MuCastle_NPC createMany
   */
  export type MuCastle_NPCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MuCastle_NPCS.
     */
    data: MuCastle_NPCCreateManyInput | MuCastle_NPCCreateManyInput[]
  }


  /**
   * MuCastle_NPC update
   */
  export type MuCastle_NPCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * The data needed to update a MuCastle_NPC.
     */
    data: XOR<MuCastle_NPCUpdateInput, MuCastle_NPCUncheckedUpdateInput>
    /**
     * Choose, which MuCastle_NPC to update.
     */
    where: MuCastle_NPCWhereUniqueInput
  }


  /**
   * MuCastle_NPC updateMany
   */
  export type MuCastle_NPCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MuCastle_NPCS.
     */
    data: XOR<MuCastle_NPCUpdateManyMutationInput, MuCastle_NPCUncheckedUpdateManyInput>
    /**
     * Filter which MuCastle_NPCS to update
     */
    where?: MuCastle_NPCWhereInput
  }


  /**
   * MuCastle_NPC upsert
   */
  export type MuCastle_NPCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * The filter to search for the MuCastle_NPC to update in case it exists.
     */
    where: MuCastle_NPCWhereUniqueInput
    /**
     * In case the MuCastle_NPC found by the `where` argument doesn't exist, create a new MuCastle_NPC with this data.
     */
    create: XOR<MuCastle_NPCCreateInput, MuCastle_NPCUncheckedCreateInput>
    /**
     * In case the MuCastle_NPC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MuCastle_NPCUpdateInput, MuCastle_NPCUncheckedUpdateInput>
  }


  /**
   * MuCastle_NPC delete
   */
  export type MuCastle_NPCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
    /**
     * Filter which MuCastle_NPC to delete.
     */
    where: MuCastle_NPCWhereUniqueInput
  }


  /**
   * MuCastle_NPC deleteMany
   */
  export type MuCastle_NPCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MuCastle_NPCS to delete
     */
    where?: MuCastle_NPCWhereInput
  }


  /**
   * MuCastle_NPC without action
   */
  export type MuCastle_NPCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_NPC
     */
    select?: MuCastle_NPCSelect<ExtArgs> | null
  }



  /**
   * Model MuCastle_REG_SIEGE
   */

  export type AggregateMuCastle_REG_SIEGE = {
    _count: MuCastle_REG_SIEGECountAggregateOutputType | null
    _avg: MuCastle_REG_SIEGEAvgAggregateOutputType | null
    _sum: MuCastle_REG_SIEGESumAggregateOutputType | null
    _min: MuCastle_REG_SIEGEMinAggregateOutputType | null
    _max: MuCastle_REG_SIEGEMaxAggregateOutputType | null
  }

  export type MuCastle_REG_SIEGEAvgAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    REG_MARKS: number | null
    IS_GIVEUP: number | null
    SEQ_NUM: number | null
  }

  export type MuCastle_REG_SIEGESumAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    REG_MARKS: number | null
    IS_GIVEUP: number | null
    SEQ_NUM: number | null
  }

  export type MuCastle_REG_SIEGEMinAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    REG_SIEGE_GUILD: string | null
    REG_MARKS: number | null
    IS_GIVEUP: number | null
    SEQ_NUM: number | null
  }

  export type MuCastle_REG_SIEGEMaxAggregateOutputType = {
    MAP_SVR_GROUP: number | null
    REG_SIEGE_GUILD: string | null
    REG_MARKS: number | null
    IS_GIVEUP: number | null
    SEQ_NUM: number | null
  }

  export type MuCastle_REG_SIEGECountAggregateOutputType = {
    MAP_SVR_GROUP: number
    REG_SIEGE_GUILD: number
    REG_MARKS: number
    IS_GIVEUP: number
    SEQ_NUM: number
    _all: number
  }


  export type MuCastle_REG_SIEGEAvgAggregateInputType = {
    MAP_SVR_GROUP?: true
    REG_MARKS?: true
    IS_GIVEUP?: true
    SEQ_NUM?: true
  }

  export type MuCastle_REG_SIEGESumAggregateInputType = {
    MAP_SVR_GROUP?: true
    REG_MARKS?: true
    IS_GIVEUP?: true
    SEQ_NUM?: true
  }

  export type MuCastle_REG_SIEGEMinAggregateInputType = {
    MAP_SVR_GROUP?: true
    REG_SIEGE_GUILD?: true
    REG_MARKS?: true
    IS_GIVEUP?: true
    SEQ_NUM?: true
  }

  export type MuCastle_REG_SIEGEMaxAggregateInputType = {
    MAP_SVR_GROUP?: true
    REG_SIEGE_GUILD?: true
    REG_MARKS?: true
    IS_GIVEUP?: true
    SEQ_NUM?: true
  }

  export type MuCastle_REG_SIEGECountAggregateInputType = {
    MAP_SVR_GROUP?: true
    REG_SIEGE_GUILD?: true
    REG_MARKS?: true
    IS_GIVEUP?: true
    SEQ_NUM?: true
    _all?: true
  }

  export type MuCastle_REG_SIEGEAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MuCastle_REG_SIEGE to aggregate.
     */
    where?: MuCastle_REG_SIEGEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_REG_SIEGES to fetch.
     */
    orderBy?: MuCastle_REG_SIEGEOrderByWithRelationInput | MuCastle_REG_SIEGEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MuCastle_REG_SIEGEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_REG_SIEGES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_REG_SIEGES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MuCastle_REG_SIEGES
    **/
    _count?: true | MuCastle_REG_SIEGECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MuCastle_REG_SIEGEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MuCastle_REG_SIEGESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuCastle_REG_SIEGEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuCastle_REG_SIEGEMaxAggregateInputType
  }

  export type GetMuCastle_REG_SIEGEAggregateType<T extends MuCastle_REG_SIEGEAggregateArgs> = {
        [P in keyof T & keyof AggregateMuCastle_REG_SIEGE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMuCastle_REG_SIEGE[P]>
      : GetScalarType<T[P], AggregateMuCastle_REG_SIEGE[P]>
  }




  export type MuCastle_REG_SIEGEGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuCastle_REG_SIEGEWhereInput
    orderBy?: MuCastle_REG_SIEGEOrderByWithAggregationInput | MuCastle_REG_SIEGEOrderByWithAggregationInput[]
    by: MuCastle_REG_SIEGEScalarFieldEnum[] | MuCastle_REG_SIEGEScalarFieldEnum
    having?: MuCastle_REG_SIEGEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuCastle_REG_SIEGECountAggregateInputType | true
    _avg?: MuCastle_REG_SIEGEAvgAggregateInputType
    _sum?: MuCastle_REG_SIEGESumAggregateInputType
    _min?: MuCastle_REG_SIEGEMinAggregateInputType
    _max?: MuCastle_REG_SIEGEMaxAggregateInputType
  }

  export type MuCastle_REG_SIEGEGroupByOutputType = {
    MAP_SVR_GROUP: number
    REG_SIEGE_GUILD: string
    REG_MARKS: number
    IS_GIVEUP: number
    SEQ_NUM: number
    _count: MuCastle_REG_SIEGECountAggregateOutputType | null
    _avg: MuCastle_REG_SIEGEAvgAggregateOutputType | null
    _sum: MuCastle_REG_SIEGESumAggregateOutputType | null
    _min: MuCastle_REG_SIEGEMinAggregateOutputType | null
    _max: MuCastle_REG_SIEGEMaxAggregateOutputType | null
  }

  type GetMuCastle_REG_SIEGEGroupByPayload<T extends MuCastle_REG_SIEGEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MuCastle_REG_SIEGEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MuCastle_REG_SIEGEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MuCastle_REG_SIEGEGroupByOutputType[P]>
            : GetScalarType<T[P], MuCastle_REG_SIEGEGroupByOutputType[P]>
        }
      >
    >


  export type MuCastle_REG_SIEGESelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MAP_SVR_GROUP?: boolean
    REG_SIEGE_GUILD?: boolean
    REG_MARKS?: boolean
    IS_GIVEUP?: boolean
    SEQ_NUM?: boolean
  }, ExtArgs["result"]["muCastle_REG_SIEGE"]>

  export type MuCastle_REG_SIEGESelectScalar = {
    MAP_SVR_GROUP?: boolean
    REG_SIEGE_GUILD?: boolean
    REG_MARKS?: boolean
    IS_GIVEUP?: boolean
    SEQ_NUM?: boolean
  }


  export type $MuCastle_REG_SIEGEPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MuCastle_REG_SIEGE"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      MAP_SVR_GROUP: number
      REG_SIEGE_GUILD: string
      REG_MARKS: number
      IS_GIVEUP: number
      SEQ_NUM: number
    }, ExtArgs["result"]["muCastle_REG_SIEGE"]>
    composites: {}
  }


  type MuCastle_REG_SIEGEGetPayload<S extends boolean | null | undefined | MuCastle_REG_SIEGEDefaultArgs> = $Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload, S>

  type MuCastle_REG_SIEGECountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MuCastle_REG_SIEGEFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MuCastle_REG_SIEGECountAggregateInputType | true
    }

  export interface MuCastle_REG_SIEGEDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MuCastle_REG_SIEGE'], meta: { name: 'MuCastle_REG_SIEGE' } }
    /**
     * Find zero or one MuCastle_REG_SIEGE that matches the filter.
     * @param {MuCastle_REG_SIEGEFindUniqueArgs} args - Arguments to find a MuCastle_REG_SIEGE
     * @example
     * // Get one MuCastle_REG_SIEGE
     * const muCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MuCastle_REG_SIEGEFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_REG_SIEGEFindUniqueArgs<ExtArgs>>
    ): Prisma__MuCastle_REG_SIEGEClient<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MuCastle_REG_SIEGE that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MuCastle_REG_SIEGEFindUniqueOrThrowArgs} args - Arguments to find a MuCastle_REG_SIEGE
     * @example
     * // Get one MuCastle_REG_SIEGE
     * const muCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MuCastle_REG_SIEGEFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_REG_SIEGEFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MuCastle_REG_SIEGEClient<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MuCastle_REG_SIEGE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_REG_SIEGEFindFirstArgs} args - Arguments to find a MuCastle_REG_SIEGE
     * @example
     * // Get one MuCastle_REG_SIEGE
     * const muCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MuCastle_REG_SIEGEFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_REG_SIEGEFindFirstArgs<ExtArgs>>
    ): Prisma__MuCastle_REG_SIEGEClient<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MuCastle_REG_SIEGE that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_REG_SIEGEFindFirstOrThrowArgs} args - Arguments to find a MuCastle_REG_SIEGE
     * @example
     * // Get one MuCastle_REG_SIEGE
     * const muCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MuCastle_REG_SIEGEFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_REG_SIEGEFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MuCastle_REG_SIEGEClient<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MuCastle_REG_SIEGES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_REG_SIEGEFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MuCastle_REG_SIEGES
     * const muCastle_REG_SIEGES = await prisma.muCastle_REG_SIEGE.findMany()
     * 
     * // Get first 10 MuCastle_REG_SIEGES
     * const muCastle_REG_SIEGES = await prisma.muCastle_REG_SIEGE.findMany({ take: 10 })
     * 
     * // Only select the `MAP_SVR_GROUP`
     * const muCastle_REG_SIEGEWithMAP_SVR_GROUPOnly = await prisma.muCastle_REG_SIEGE.findMany({ select: { MAP_SVR_GROUP: true } })
     * 
    **/
    findMany<T extends MuCastle_REG_SIEGEFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_REG_SIEGEFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MuCastle_REG_SIEGE.
     * @param {MuCastle_REG_SIEGECreateArgs} args - Arguments to create a MuCastle_REG_SIEGE.
     * @example
     * // Create one MuCastle_REG_SIEGE
     * const MuCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.create({
     *   data: {
     *     // ... data to create a MuCastle_REG_SIEGE
     *   }
     * })
     * 
    **/
    create<T extends MuCastle_REG_SIEGECreateArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_REG_SIEGECreateArgs<ExtArgs>>
    ): Prisma__MuCastle_REG_SIEGEClient<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MuCastle_REG_SIEGES.
     *     @param {MuCastle_REG_SIEGECreateManyArgs} args - Arguments to create many MuCastle_REG_SIEGES.
     *     @example
     *     // Create many MuCastle_REG_SIEGES
     *     const muCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MuCastle_REG_SIEGECreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_REG_SIEGECreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MuCastle_REG_SIEGE.
     * @param {MuCastle_REG_SIEGEDeleteArgs} args - Arguments to delete one MuCastle_REG_SIEGE.
     * @example
     * // Delete one MuCastle_REG_SIEGE
     * const MuCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.delete({
     *   where: {
     *     // ... filter to delete one MuCastle_REG_SIEGE
     *   }
     * })
     * 
    **/
    delete<T extends MuCastle_REG_SIEGEDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_REG_SIEGEDeleteArgs<ExtArgs>>
    ): Prisma__MuCastle_REG_SIEGEClient<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MuCastle_REG_SIEGE.
     * @param {MuCastle_REG_SIEGEUpdateArgs} args - Arguments to update one MuCastle_REG_SIEGE.
     * @example
     * // Update one MuCastle_REG_SIEGE
     * const muCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MuCastle_REG_SIEGEUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_REG_SIEGEUpdateArgs<ExtArgs>>
    ): Prisma__MuCastle_REG_SIEGEClient<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MuCastle_REG_SIEGES.
     * @param {MuCastle_REG_SIEGEDeleteManyArgs} args - Arguments to filter MuCastle_REG_SIEGES to delete.
     * @example
     * // Delete a few MuCastle_REG_SIEGES
     * const { count } = await prisma.muCastle_REG_SIEGE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MuCastle_REG_SIEGEDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MuCastle_REG_SIEGEDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MuCastle_REG_SIEGES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_REG_SIEGEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MuCastle_REG_SIEGES
     * const muCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MuCastle_REG_SIEGEUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_REG_SIEGEUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MuCastle_REG_SIEGE.
     * @param {MuCastle_REG_SIEGEUpsertArgs} args - Arguments to update or create a MuCastle_REG_SIEGE.
     * @example
     * // Update or create a MuCastle_REG_SIEGE
     * const muCastle_REG_SIEGE = await prisma.muCastle_REG_SIEGE.upsert({
     *   create: {
     *     // ... data to create a MuCastle_REG_SIEGE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MuCastle_REG_SIEGE we want to update
     *   }
     * })
    **/
    upsert<T extends MuCastle_REG_SIEGEUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MuCastle_REG_SIEGEUpsertArgs<ExtArgs>>
    ): Prisma__MuCastle_REG_SIEGEClient<$Result.GetResult<Prisma.$MuCastle_REG_SIEGEPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MuCastle_REG_SIEGES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_REG_SIEGECountArgs} args - Arguments to filter MuCastle_REG_SIEGES to count.
     * @example
     * // Count the number of MuCastle_REG_SIEGES
     * const count = await prisma.muCastle_REG_SIEGE.count({
     *   where: {
     *     // ... the filter for the MuCastle_REG_SIEGES we want to count
     *   }
     * })
    **/
    count<T extends MuCastle_REG_SIEGECountArgs>(
      args?: Subset<T, MuCastle_REG_SIEGECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuCastle_REG_SIEGECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MuCastle_REG_SIEGE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_REG_SIEGEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuCastle_REG_SIEGEAggregateArgs>(args: Subset<T, MuCastle_REG_SIEGEAggregateArgs>): Prisma.PrismaPromise<GetMuCastle_REG_SIEGEAggregateType<T>>

    /**
     * Group by MuCastle_REG_SIEGE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuCastle_REG_SIEGEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuCastle_REG_SIEGEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuCastle_REG_SIEGEGroupByArgs['orderBy'] }
        : { orderBy?: MuCastle_REG_SIEGEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuCastle_REG_SIEGEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuCastle_REG_SIEGEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MuCastle_REG_SIEGE model
   */
  readonly fields: MuCastle_REG_SIEGEFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MuCastle_REG_SIEGE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MuCastle_REG_SIEGEClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MuCastle_REG_SIEGE model
   */ 
  interface MuCastle_REG_SIEGEFieldRefs {
    readonly MAP_SVR_GROUP: FieldRef<"MuCastle_REG_SIEGE", 'Int'>
    readonly REG_SIEGE_GUILD: FieldRef<"MuCastle_REG_SIEGE", 'String'>
    readonly REG_MARKS: FieldRef<"MuCastle_REG_SIEGE", 'Int'>
    readonly IS_GIVEUP: FieldRef<"MuCastle_REG_SIEGE", 'Int'>
    readonly SEQ_NUM: FieldRef<"MuCastle_REG_SIEGE", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MuCastle_REG_SIEGE findUnique
   */
  export type MuCastle_REG_SIEGEFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_REG_SIEGE to fetch.
     */
    where: MuCastle_REG_SIEGEWhereUniqueInput
  }


  /**
   * MuCastle_REG_SIEGE findUniqueOrThrow
   */
  export type MuCastle_REG_SIEGEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_REG_SIEGE to fetch.
     */
    where: MuCastle_REG_SIEGEWhereUniqueInput
  }


  /**
   * MuCastle_REG_SIEGE findFirst
   */
  export type MuCastle_REG_SIEGEFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_REG_SIEGE to fetch.
     */
    where?: MuCastle_REG_SIEGEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_REG_SIEGES to fetch.
     */
    orderBy?: MuCastle_REG_SIEGEOrderByWithRelationInput | MuCastle_REG_SIEGEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuCastle_REG_SIEGES.
     */
    cursor?: MuCastle_REG_SIEGEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_REG_SIEGES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_REG_SIEGES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuCastle_REG_SIEGES.
     */
    distinct?: MuCastle_REG_SIEGEScalarFieldEnum | MuCastle_REG_SIEGEScalarFieldEnum[]
  }


  /**
   * MuCastle_REG_SIEGE findFirstOrThrow
   */
  export type MuCastle_REG_SIEGEFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_REG_SIEGE to fetch.
     */
    where?: MuCastle_REG_SIEGEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_REG_SIEGES to fetch.
     */
    orderBy?: MuCastle_REG_SIEGEOrderByWithRelationInput | MuCastle_REG_SIEGEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuCastle_REG_SIEGES.
     */
    cursor?: MuCastle_REG_SIEGEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_REG_SIEGES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_REG_SIEGES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuCastle_REG_SIEGES.
     */
    distinct?: MuCastle_REG_SIEGEScalarFieldEnum | MuCastle_REG_SIEGEScalarFieldEnum[]
  }


  /**
   * MuCastle_REG_SIEGE findMany
   */
  export type MuCastle_REG_SIEGEFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * Filter, which MuCastle_REG_SIEGES to fetch.
     */
    where?: MuCastle_REG_SIEGEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuCastle_REG_SIEGES to fetch.
     */
    orderBy?: MuCastle_REG_SIEGEOrderByWithRelationInput | MuCastle_REG_SIEGEOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MuCastle_REG_SIEGES.
     */
    cursor?: MuCastle_REG_SIEGEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuCastle_REG_SIEGES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuCastle_REG_SIEGES.
     */
    skip?: number
    distinct?: MuCastle_REG_SIEGEScalarFieldEnum | MuCastle_REG_SIEGEScalarFieldEnum[]
  }


  /**
   * MuCastle_REG_SIEGE create
   */
  export type MuCastle_REG_SIEGECreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * The data needed to create a MuCastle_REG_SIEGE.
     */
    data: XOR<MuCastle_REG_SIEGECreateInput, MuCastle_REG_SIEGEUncheckedCreateInput>
  }


  /**
   * MuCastle_REG_SIEGE createMany
   */
  export type MuCastle_REG_SIEGECreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MuCastle_REG_SIEGES.
     */
    data: MuCastle_REG_SIEGECreateManyInput | MuCastle_REG_SIEGECreateManyInput[]
  }


  /**
   * MuCastle_REG_SIEGE update
   */
  export type MuCastle_REG_SIEGEUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * The data needed to update a MuCastle_REG_SIEGE.
     */
    data: XOR<MuCastle_REG_SIEGEUpdateInput, MuCastle_REG_SIEGEUncheckedUpdateInput>
    /**
     * Choose, which MuCastle_REG_SIEGE to update.
     */
    where: MuCastle_REG_SIEGEWhereUniqueInput
  }


  /**
   * MuCastle_REG_SIEGE updateMany
   */
  export type MuCastle_REG_SIEGEUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MuCastle_REG_SIEGES.
     */
    data: XOR<MuCastle_REG_SIEGEUpdateManyMutationInput, MuCastle_REG_SIEGEUncheckedUpdateManyInput>
    /**
     * Filter which MuCastle_REG_SIEGES to update
     */
    where?: MuCastle_REG_SIEGEWhereInput
  }


  /**
   * MuCastle_REG_SIEGE upsert
   */
  export type MuCastle_REG_SIEGEUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * The filter to search for the MuCastle_REG_SIEGE to update in case it exists.
     */
    where: MuCastle_REG_SIEGEWhereUniqueInput
    /**
     * In case the MuCastle_REG_SIEGE found by the `where` argument doesn't exist, create a new MuCastle_REG_SIEGE with this data.
     */
    create: XOR<MuCastle_REG_SIEGECreateInput, MuCastle_REG_SIEGEUncheckedCreateInput>
    /**
     * In case the MuCastle_REG_SIEGE was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MuCastle_REG_SIEGEUpdateInput, MuCastle_REG_SIEGEUncheckedUpdateInput>
  }


  /**
   * MuCastle_REG_SIEGE delete
   */
  export type MuCastle_REG_SIEGEDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
    /**
     * Filter which MuCastle_REG_SIEGE to delete.
     */
    where: MuCastle_REG_SIEGEWhereUniqueInput
  }


  /**
   * MuCastle_REG_SIEGE deleteMany
   */
  export type MuCastle_REG_SIEGEDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MuCastle_REG_SIEGES to delete
     */
    where?: MuCastle_REG_SIEGEWhereInput
  }


  /**
   * MuCastle_REG_SIEGE without action
   */
  export type MuCastle_REG_SIEGEDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuCastle_REG_SIEGE
     */
    select?: MuCastle_REG_SIEGESelect<ExtArgs> | null
  }



  /**
   * Model OptionData
   */

  export type AggregateOptionData = {
    _count: OptionDataCountAggregateOutputType | null
    _avg: OptionDataAvgAggregateOutputType | null
    _sum: OptionDataSumAggregateOutputType | null
    _min: OptionDataMinAggregateOutputType | null
    _max: OptionDataMaxAggregateOutputType | null
  }

  export type OptionDataAvgAggregateOutputType = {
    GameOption: number | null
    Qkey: number | null
    Wkey: number | null
    Ekey: number | null
    ChatWindow: number | null
    Rkey: number | null
    QWERLevel: number | null
  }

  export type OptionDataSumAggregateOutputType = {
    GameOption: number | null
    Qkey: number | null
    Wkey: number | null
    Ekey: number | null
    ChatWindow: number | null
    Rkey: number | null
    QWERLevel: number | null
  }

  export type OptionDataMinAggregateOutputType = {
    Name: string | null
    SkillKey: Buffer | null
    GameOption: number | null
    Qkey: number | null
    Wkey: number | null
    Ekey: number | null
    ChatWindow: number | null
    Rkey: number | null
    QWERLevel: number | null
  }

  export type OptionDataMaxAggregateOutputType = {
    Name: string | null
    SkillKey: Buffer | null
    GameOption: number | null
    Qkey: number | null
    Wkey: number | null
    Ekey: number | null
    ChatWindow: number | null
    Rkey: number | null
    QWERLevel: number | null
  }

  export type OptionDataCountAggregateOutputType = {
    Name: number
    SkillKey: number
    GameOption: number
    Qkey: number
    Wkey: number
    Ekey: number
    ChatWindow: number
    Rkey: number
    QWERLevel: number
    _all: number
  }


  export type OptionDataAvgAggregateInputType = {
    GameOption?: true
    Qkey?: true
    Wkey?: true
    Ekey?: true
    ChatWindow?: true
    Rkey?: true
    QWERLevel?: true
  }

  export type OptionDataSumAggregateInputType = {
    GameOption?: true
    Qkey?: true
    Wkey?: true
    Ekey?: true
    ChatWindow?: true
    Rkey?: true
    QWERLevel?: true
  }

  export type OptionDataMinAggregateInputType = {
    Name?: true
    SkillKey?: true
    GameOption?: true
    Qkey?: true
    Wkey?: true
    Ekey?: true
    ChatWindow?: true
    Rkey?: true
    QWERLevel?: true
  }

  export type OptionDataMaxAggregateInputType = {
    Name?: true
    SkillKey?: true
    GameOption?: true
    Qkey?: true
    Wkey?: true
    Ekey?: true
    ChatWindow?: true
    Rkey?: true
    QWERLevel?: true
  }

  export type OptionDataCountAggregateInputType = {
    Name?: true
    SkillKey?: true
    GameOption?: true
    Qkey?: true
    Wkey?: true
    Ekey?: true
    ChatWindow?: true
    Rkey?: true
    QWERLevel?: true
    _all?: true
  }

  export type OptionDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionData to aggregate.
     */
    where?: OptionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionData to fetch.
     */
    orderBy?: OptionDataOrderByWithRelationInput | OptionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptionData
    **/
    _count?: true | OptionDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptionDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptionDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionDataMaxAggregateInputType
  }

  export type GetOptionDataAggregateType<T extends OptionDataAggregateArgs> = {
        [P in keyof T & keyof AggregateOptionData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptionData[P]>
      : GetScalarType<T[P], AggregateOptionData[P]>
  }




  export type OptionDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionDataWhereInput
    orderBy?: OptionDataOrderByWithAggregationInput | OptionDataOrderByWithAggregationInput[]
    by: OptionDataScalarFieldEnum[] | OptionDataScalarFieldEnum
    having?: OptionDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionDataCountAggregateInputType | true
    _avg?: OptionDataAvgAggregateInputType
    _sum?: OptionDataSumAggregateInputType
    _min?: OptionDataMinAggregateInputType
    _max?: OptionDataMaxAggregateInputType
  }

  export type OptionDataGroupByOutputType = {
    Name: string
    SkillKey: Buffer | null
    GameOption: number | null
    Qkey: number | null
    Wkey: number | null
    Ekey: number | null
    ChatWindow: number | null
    Rkey: number | null
    QWERLevel: number | null
    _count: OptionDataCountAggregateOutputType | null
    _avg: OptionDataAvgAggregateOutputType | null
    _sum: OptionDataSumAggregateOutputType | null
    _min: OptionDataMinAggregateOutputType | null
    _max: OptionDataMaxAggregateOutputType | null
  }

  type GetOptionDataGroupByPayload<T extends OptionDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionDataGroupByOutputType[P]>
            : GetScalarType<T[P], OptionDataGroupByOutputType[P]>
        }
      >
    >


  export type OptionDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    SkillKey?: boolean
    GameOption?: boolean
    Qkey?: boolean
    Wkey?: boolean
    Ekey?: boolean
    ChatWindow?: boolean
    Rkey?: boolean
    QWERLevel?: boolean
  }, ExtArgs["result"]["optionData"]>

  export type OptionDataSelectScalar = {
    Name?: boolean
    SkillKey?: boolean
    GameOption?: boolean
    Qkey?: boolean
    Wkey?: boolean
    Ekey?: boolean
    ChatWindow?: boolean
    Rkey?: boolean
    QWERLevel?: boolean
  }


  export type $OptionDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OptionData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      SkillKey: Buffer | null
      GameOption: number | null
      Qkey: number | null
      Wkey: number | null
      Ekey: number | null
      ChatWindow: number | null
      Rkey: number | null
      QWERLevel: number | null
    }, ExtArgs["result"]["optionData"]>
    composites: {}
  }


  type OptionDataGetPayload<S extends boolean | null | undefined | OptionDataDefaultArgs> = $Result.GetResult<Prisma.$OptionDataPayload, S>

  type OptionDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OptionDataFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: OptionDataCountAggregateInputType | true
    }

  export interface OptionDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptionData'], meta: { name: 'OptionData' } }
    /**
     * Find zero or one OptionData that matches the filter.
     * @param {OptionDataFindUniqueArgs} args - Arguments to find a OptionData
     * @example
     * // Get one OptionData
     * const optionData = await prisma.optionData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OptionDataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OptionDataFindUniqueArgs<ExtArgs>>
    ): Prisma__OptionDataClient<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OptionData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OptionDataFindUniqueOrThrowArgs} args - Arguments to find a OptionData
     * @example
     * // Get one OptionData
     * const optionData = await prisma.optionData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OptionDataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OptionDataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OptionDataClient<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OptionData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionDataFindFirstArgs} args - Arguments to find a OptionData
     * @example
     * // Get one OptionData
     * const optionData = await prisma.optionData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OptionDataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OptionDataFindFirstArgs<ExtArgs>>
    ): Prisma__OptionDataClient<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OptionData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionDataFindFirstOrThrowArgs} args - Arguments to find a OptionData
     * @example
     * // Get one OptionData
     * const optionData = await prisma.optionData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OptionDataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OptionDataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OptionDataClient<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OptionData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptionData
     * const optionData = await prisma.optionData.findMany()
     * 
     * // Get first 10 OptionData
     * const optionData = await prisma.optionData.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const optionDataWithNameOnly = await prisma.optionData.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends OptionDataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OptionDataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OptionData.
     * @param {OptionDataCreateArgs} args - Arguments to create a OptionData.
     * @example
     * // Create one OptionData
     * const OptionData = await prisma.optionData.create({
     *   data: {
     *     // ... data to create a OptionData
     *   }
     * })
     * 
    **/
    create<T extends OptionDataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OptionDataCreateArgs<ExtArgs>>
    ): Prisma__OptionDataClient<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OptionData.
     *     @param {OptionDataCreateManyArgs} args - Arguments to create many OptionData.
     *     @example
     *     // Create many OptionData
     *     const optionData = await prisma.optionData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OptionDataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OptionDataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OptionData.
     * @param {OptionDataDeleteArgs} args - Arguments to delete one OptionData.
     * @example
     * // Delete one OptionData
     * const OptionData = await prisma.optionData.delete({
     *   where: {
     *     // ... filter to delete one OptionData
     *   }
     * })
     * 
    **/
    delete<T extends OptionDataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OptionDataDeleteArgs<ExtArgs>>
    ): Prisma__OptionDataClient<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OptionData.
     * @param {OptionDataUpdateArgs} args - Arguments to update one OptionData.
     * @example
     * // Update one OptionData
     * const optionData = await prisma.optionData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OptionDataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OptionDataUpdateArgs<ExtArgs>>
    ): Prisma__OptionDataClient<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OptionData.
     * @param {OptionDataDeleteManyArgs} args - Arguments to filter OptionData to delete.
     * @example
     * // Delete a few OptionData
     * const { count } = await prisma.optionData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OptionDataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OptionDataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptionData
     * const optionData = await prisma.optionData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OptionDataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OptionDataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OptionData.
     * @param {OptionDataUpsertArgs} args - Arguments to update or create a OptionData.
     * @example
     * // Update or create a OptionData
     * const optionData = await prisma.optionData.upsert({
     *   create: {
     *     // ... data to create a OptionData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptionData we want to update
     *   }
     * })
    **/
    upsert<T extends OptionDataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OptionDataUpsertArgs<ExtArgs>>
    ): Prisma__OptionDataClient<$Result.GetResult<Prisma.$OptionDataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OptionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionDataCountArgs} args - Arguments to filter OptionData to count.
     * @example
     * // Count the number of OptionData
     * const count = await prisma.optionData.count({
     *   where: {
     *     // ... the filter for the OptionData we want to count
     *   }
     * })
    **/
    count<T extends OptionDataCountArgs>(
      args?: Subset<T, OptionDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionDataAggregateArgs>(args: Subset<T, OptionDataAggregateArgs>): Prisma.PrismaPromise<GetOptionDataAggregateType<T>>

    /**
     * Group by OptionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionDataGroupByArgs['orderBy'] }
        : { orderBy?: OptionDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptionData model
   */
  readonly fields: OptionDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptionData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OptionData model
   */ 
  interface OptionDataFieldRefs {
    readonly Name: FieldRef<"OptionData", 'String'>
    readonly SkillKey: FieldRef<"OptionData", 'Bytes'>
    readonly GameOption: FieldRef<"OptionData", 'Int'>
    readonly Qkey: FieldRef<"OptionData", 'Int'>
    readonly Wkey: FieldRef<"OptionData", 'Int'>
    readonly Ekey: FieldRef<"OptionData", 'Int'>
    readonly ChatWindow: FieldRef<"OptionData", 'Int'>
    readonly Rkey: FieldRef<"OptionData", 'Int'>
    readonly QWERLevel: FieldRef<"OptionData", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * OptionData findUnique
   */
  export type OptionDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * Filter, which OptionData to fetch.
     */
    where: OptionDataWhereUniqueInput
  }


  /**
   * OptionData findUniqueOrThrow
   */
  export type OptionDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * Filter, which OptionData to fetch.
     */
    where: OptionDataWhereUniqueInput
  }


  /**
   * OptionData findFirst
   */
  export type OptionDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * Filter, which OptionData to fetch.
     */
    where?: OptionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionData to fetch.
     */
    orderBy?: OptionDataOrderByWithRelationInput | OptionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionData.
     */
    cursor?: OptionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionData.
     */
    distinct?: OptionDataScalarFieldEnum | OptionDataScalarFieldEnum[]
  }


  /**
   * OptionData findFirstOrThrow
   */
  export type OptionDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * Filter, which OptionData to fetch.
     */
    where?: OptionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionData to fetch.
     */
    orderBy?: OptionDataOrderByWithRelationInput | OptionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptionData.
     */
    cursor?: OptionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptionData.
     */
    distinct?: OptionDataScalarFieldEnum | OptionDataScalarFieldEnum[]
  }


  /**
   * OptionData findMany
   */
  export type OptionDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * Filter, which OptionData to fetch.
     */
    where?: OptionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptionData to fetch.
     */
    orderBy?: OptionDataOrderByWithRelationInput | OptionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptionData.
     */
    cursor?: OptionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptionData.
     */
    skip?: number
    distinct?: OptionDataScalarFieldEnum | OptionDataScalarFieldEnum[]
  }


  /**
   * OptionData create
   */
  export type OptionDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * The data needed to create a OptionData.
     */
    data: XOR<OptionDataCreateInput, OptionDataUncheckedCreateInput>
  }


  /**
   * OptionData createMany
   */
  export type OptionDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptionData.
     */
    data: OptionDataCreateManyInput | OptionDataCreateManyInput[]
  }


  /**
   * OptionData update
   */
  export type OptionDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * The data needed to update a OptionData.
     */
    data: XOR<OptionDataUpdateInput, OptionDataUncheckedUpdateInput>
    /**
     * Choose, which OptionData to update.
     */
    where: OptionDataWhereUniqueInput
  }


  /**
   * OptionData updateMany
   */
  export type OptionDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptionData.
     */
    data: XOR<OptionDataUpdateManyMutationInput, OptionDataUncheckedUpdateManyInput>
    /**
     * Filter which OptionData to update
     */
    where?: OptionDataWhereInput
  }


  /**
   * OptionData upsert
   */
  export type OptionDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * The filter to search for the OptionData to update in case it exists.
     */
    where: OptionDataWhereUniqueInput
    /**
     * In case the OptionData found by the `where` argument doesn't exist, create a new OptionData with this data.
     */
    create: XOR<OptionDataCreateInput, OptionDataUncheckedCreateInput>
    /**
     * In case the OptionData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptionDataUpdateInput, OptionDataUncheckedUpdateInput>
  }


  /**
   * OptionData delete
   */
  export type OptionDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
    /**
     * Filter which OptionData to delete.
     */
    where: OptionDataWhereUniqueInput
  }


  /**
   * OptionData deleteMany
   */
  export type OptionDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptionData to delete
     */
    where?: OptionDataWhereInput
  }


  /**
   * OptionData without action
   */
  export type OptionDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptionData
     */
    select?: OptionDataSelect<ExtArgs> | null
  }



  /**
   * Model QuestKillCount
   */

  export type AggregateQuestKillCount = {
    _count: QuestKillCountCountAggregateOutputType | null
    _avg: QuestKillCountAvgAggregateOutputType | null
    _sum: QuestKillCountSumAggregateOutputType | null
    _min: QuestKillCountMinAggregateOutputType | null
    _max: QuestKillCountMaxAggregateOutputType | null
  }

  export type QuestKillCountAvgAggregateOutputType = {
    QuestIndex: number | null
    MonsterClass1: number | null
    KillCount1: number | null
    MonsterClass2: number | null
    KillCount2: number | null
    MonsterClass3: number | null
    KillCount3: number | null
    MonsterClass4: number | null
    KillCount4: number | null
    MonsterClass5: number | null
    KillCount5: number | null
  }

  export type QuestKillCountSumAggregateOutputType = {
    QuestIndex: number | null
    MonsterClass1: number | null
    KillCount1: number | null
    MonsterClass2: number | null
    KillCount2: number | null
    MonsterClass3: number | null
    KillCount3: number | null
    MonsterClass4: number | null
    KillCount4: number | null
    MonsterClass5: number | null
    KillCount5: number | null
  }

  export type QuestKillCountMinAggregateOutputType = {
    Name: string | null
    QuestIndex: number | null
    MonsterClass1: number | null
    KillCount1: number | null
    MonsterClass2: number | null
    KillCount2: number | null
    MonsterClass3: number | null
    KillCount3: number | null
    MonsterClass4: number | null
    KillCount4: number | null
    MonsterClass5: number | null
    KillCount5: number | null
  }

  export type QuestKillCountMaxAggregateOutputType = {
    Name: string | null
    QuestIndex: number | null
    MonsterClass1: number | null
    KillCount1: number | null
    MonsterClass2: number | null
    KillCount2: number | null
    MonsterClass3: number | null
    KillCount3: number | null
    MonsterClass4: number | null
    KillCount4: number | null
    MonsterClass5: number | null
    KillCount5: number | null
  }

  export type QuestKillCountCountAggregateOutputType = {
    Name: number
    QuestIndex: number
    MonsterClass1: number
    KillCount1: number
    MonsterClass2: number
    KillCount2: number
    MonsterClass3: number
    KillCount3: number
    MonsterClass4: number
    KillCount4: number
    MonsterClass5: number
    KillCount5: number
    _all: number
  }


  export type QuestKillCountAvgAggregateInputType = {
    QuestIndex?: true
    MonsterClass1?: true
    KillCount1?: true
    MonsterClass2?: true
    KillCount2?: true
    MonsterClass3?: true
    KillCount3?: true
    MonsterClass4?: true
    KillCount4?: true
    MonsterClass5?: true
    KillCount5?: true
  }

  export type QuestKillCountSumAggregateInputType = {
    QuestIndex?: true
    MonsterClass1?: true
    KillCount1?: true
    MonsterClass2?: true
    KillCount2?: true
    MonsterClass3?: true
    KillCount3?: true
    MonsterClass4?: true
    KillCount4?: true
    MonsterClass5?: true
    KillCount5?: true
  }

  export type QuestKillCountMinAggregateInputType = {
    Name?: true
    QuestIndex?: true
    MonsterClass1?: true
    KillCount1?: true
    MonsterClass2?: true
    KillCount2?: true
    MonsterClass3?: true
    KillCount3?: true
    MonsterClass4?: true
    KillCount4?: true
    MonsterClass5?: true
    KillCount5?: true
  }

  export type QuestKillCountMaxAggregateInputType = {
    Name?: true
    QuestIndex?: true
    MonsterClass1?: true
    KillCount1?: true
    MonsterClass2?: true
    KillCount2?: true
    MonsterClass3?: true
    KillCount3?: true
    MonsterClass4?: true
    KillCount4?: true
    MonsterClass5?: true
    KillCount5?: true
  }

  export type QuestKillCountCountAggregateInputType = {
    Name?: true
    QuestIndex?: true
    MonsterClass1?: true
    KillCount1?: true
    MonsterClass2?: true
    KillCount2?: true
    MonsterClass3?: true
    KillCount3?: true
    MonsterClass4?: true
    KillCount4?: true
    MonsterClass5?: true
    KillCount5?: true
    _all?: true
  }

  export type QuestKillCountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestKillCount to aggregate.
     */
    where?: QuestKillCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestKillCounts to fetch.
     */
    orderBy?: QuestKillCountOrderByWithRelationInput | QuestKillCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestKillCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestKillCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestKillCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestKillCounts
    **/
    _count?: true | QuestKillCountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestKillCountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestKillCountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestKillCountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestKillCountMaxAggregateInputType
  }

  export type GetQuestKillCountAggregateType<T extends QuestKillCountAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestKillCount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestKillCount[P]>
      : GetScalarType<T[P], AggregateQuestKillCount[P]>
  }




  export type QuestKillCountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestKillCountWhereInput
    orderBy?: QuestKillCountOrderByWithAggregationInput | QuestKillCountOrderByWithAggregationInput[]
    by: QuestKillCountScalarFieldEnum[] | QuestKillCountScalarFieldEnum
    having?: QuestKillCountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestKillCountCountAggregateInputType | true
    _avg?: QuestKillCountAvgAggregateInputType
    _sum?: QuestKillCountSumAggregateInputType
    _min?: QuestKillCountMinAggregateInputType
    _max?: QuestKillCountMaxAggregateInputType
  }

  export type QuestKillCountGroupByOutputType = {
    Name: string
    QuestIndex: number | null
    MonsterClass1: number | null
    KillCount1: number | null
    MonsterClass2: number | null
    KillCount2: number | null
    MonsterClass3: number | null
    KillCount3: number | null
    MonsterClass4: number | null
    KillCount4: number | null
    MonsterClass5: number | null
    KillCount5: number | null
    _count: QuestKillCountCountAggregateOutputType | null
    _avg: QuestKillCountAvgAggregateOutputType | null
    _sum: QuestKillCountSumAggregateOutputType | null
    _min: QuestKillCountMinAggregateOutputType | null
    _max: QuestKillCountMaxAggregateOutputType | null
  }

  type GetQuestKillCountGroupByPayload<T extends QuestKillCountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestKillCountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestKillCountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestKillCountGroupByOutputType[P]>
            : GetScalarType<T[P], QuestKillCountGroupByOutputType[P]>
        }
      >
    >


  export type QuestKillCountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    QuestIndex?: boolean
    MonsterClass1?: boolean
    KillCount1?: boolean
    MonsterClass2?: boolean
    KillCount2?: boolean
    MonsterClass3?: boolean
    KillCount3?: boolean
    MonsterClass4?: boolean
    KillCount4?: boolean
    MonsterClass5?: boolean
    KillCount5?: boolean
  }, ExtArgs["result"]["questKillCount"]>

  export type QuestKillCountSelectScalar = {
    Name?: boolean
    QuestIndex?: boolean
    MonsterClass1?: boolean
    KillCount1?: boolean
    MonsterClass2?: boolean
    KillCount2?: boolean
    MonsterClass3?: boolean
    KillCount3?: boolean
    MonsterClass4?: boolean
    KillCount4?: boolean
    MonsterClass5?: boolean
    KillCount5?: boolean
  }


  export type $QuestKillCountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestKillCount"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      QuestIndex: number | null
      MonsterClass1: number | null
      KillCount1: number | null
      MonsterClass2: number | null
      KillCount2: number | null
      MonsterClass3: number | null
      KillCount3: number | null
      MonsterClass4: number | null
      KillCount4: number | null
      MonsterClass5: number | null
      KillCount5: number | null
    }, ExtArgs["result"]["questKillCount"]>
    composites: {}
  }


  type QuestKillCountGetPayload<S extends boolean | null | undefined | QuestKillCountDefaultArgs> = $Result.GetResult<Prisma.$QuestKillCountPayload, S>

  type QuestKillCountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestKillCountFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: QuestKillCountCountAggregateInputType | true
    }

  export interface QuestKillCountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestKillCount'], meta: { name: 'QuestKillCount' } }
    /**
     * Find zero or one QuestKillCount that matches the filter.
     * @param {QuestKillCountFindUniqueArgs} args - Arguments to find a QuestKillCount
     * @example
     * // Get one QuestKillCount
     * const questKillCount = await prisma.questKillCount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestKillCountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuestKillCountFindUniqueArgs<ExtArgs>>
    ): Prisma__QuestKillCountClient<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one QuestKillCount that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestKillCountFindUniqueOrThrowArgs} args - Arguments to find a QuestKillCount
     * @example
     * // Get one QuestKillCount
     * const questKillCount = await prisma.questKillCount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestKillCountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestKillCountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuestKillCountClient<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first QuestKillCount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestKillCountFindFirstArgs} args - Arguments to find a QuestKillCount
     * @example
     * // Get one QuestKillCount
     * const questKillCount = await prisma.questKillCount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestKillCountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestKillCountFindFirstArgs<ExtArgs>>
    ): Prisma__QuestKillCountClient<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first QuestKillCount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestKillCountFindFirstOrThrowArgs} args - Arguments to find a QuestKillCount
     * @example
     * // Get one QuestKillCount
     * const questKillCount = await prisma.questKillCount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestKillCountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestKillCountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuestKillCountClient<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more QuestKillCounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestKillCountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestKillCounts
     * const questKillCounts = await prisma.questKillCount.findMany()
     * 
     * // Get first 10 QuestKillCounts
     * const questKillCounts = await prisma.questKillCount.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const questKillCountWithNameOnly = await prisma.questKillCount.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends QuestKillCountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestKillCountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a QuestKillCount.
     * @param {QuestKillCountCreateArgs} args - Arguments to create a QuestKillCount.
     * @example
     * // Create one QuestKillCount
     * const QuestKillCount = await prisma.questKillCount.create({
     *   data: {
     *     // ... data to create a QuestKillCount
     *   }
     * })
     * 
    **/
    create<T extends QuestKillCountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestKillCountCreateArgs<ExtArgs>>
    ): Prisma__QuestKillCountClient<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many QuestKillCounts.
     *     @param {QuestKillCountCreateManyArgs} args - Arguments to create many QuestKillCounts.
     *     @example
     *     // Create many QuestKillCounts
     *     const questKillCount = await prisma.questKillCount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestKillCountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestKillCountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuestKillCount.
     * @param {QuestKillCountDeleteArgs} args - Arguments to delete one QuestKillCount.
     * @example
     * // Delete one QuestKillCount
     * const QuestKillCount = await prisma.questKillCount.delete({
     *   where: {
     *     // ... filter to delete one QuestKillCount
     *   }
     * })
     * 
    **/
    delete<T extends QuestKillCountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuestKillCountDeleteArgs<ExtArgs>>
    ): Prisma__QuestKillCountClient<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one QuestKillCount.
     * @param {QuestKillCountUpdateArgs} args - Arguments to update one QuestKillCount.
     * @example
     * // Update one QuestKillCount
     * const questKillCount = await prisma.questKillCount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestKillCountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestKillCountUpdateArgs<ExtArgs>>
    ): Prisma__QuestKillCountClient<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more QuestKillCounts.
     * @param {QuestKillCountDeleteManyArgs} args - Arguments to filter QuestKillCounts to delete.
     * @example
     * // Delete a few QuestKillCounts
     * const { count } = await prisma.questKillCount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestKillCountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestKillCountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestKillCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestKillCountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestKillCounts
     * const questKillCount = await prisma.questKillCount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestKillCountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuestKillCountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestKillCount.
     * @param {QuestKillCountUpsertArgs} args - Arguments to update or create a QuestKillCount.
     * @example
     * // Update or create a QuestKillCount
     * const questKillCount = await prisma.questKillCount.upsert({
     *   create: {
     *     // ... data to create a QuestKillCount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestKillCount we want to update
     *   }
     * })
    **/
    upsert<T extends QuestKillCountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuestKillCountUpsertArgs<ExtArgs>>
    ): Prisma__QuestKillCountClient<$Result.GetResult<Prisma.$QuestKillCountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of QuestKillCounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestKillCountCountArgs} args - Arguments to filter QuestKillCounts to count.
     * @example
     * // Count the number of QuestKillCounts
     * const count = await prisma.questKillCount.count({
     *   where: {
     *     // ... the filter for the QuestKillCounts we want to count
     *   }
     * })
    **/
    count<T extends QuestKillCountCountArgs>(
      args?: Subset<T, QuestKillCountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestKillCountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestKillCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestKillCountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestKillCountAggregateArgs>(args: Subset<T, QuestKillCountAggregateArgs>): Prisma.PrismaPromise<GetQuestKillCountAggregateType<T>>

    /**
     * Group by QuestKillCount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestKillCountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestKillCountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestKillCountGroupByArgs['orderBy'] }
        : { orderBy?: QuestKillCountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestKillCountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestKillCountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestKillCount model
   */
  readonly fields: QuestKillCountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestKillCount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestKillCountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the QuestKillCount model
   */ 
  interface QuestKillCountFieldRefs {
    readonly Name: FieldRef<"QuestKillCount", 'String'>
    readonly QuestIndex: FieldRef<"QuestKillCount", 'Int'>
    readonly MonsterClass1: FieldRef<"QuestKillCount", 'Int'>
    readonly KillCount1: FieldRef<"QuestKillCount", 'Int'>
    readonly MonsterClass2: FieldRef<"QuestKillCount", 'Int'>
    readonly KillCount2: FieldRef<"QuestKillCount", 'Int'>
    readonly MonsterClass3: FieldRef<"QuestKillCount", 'Int'>
    readonly KillCount3: FieldRef<"QuestKillCount", 'Int'>
    readonly MonsterClass4: FieldRef<"QuestKillCount", 'Int'>
    readonly KillCount4: FieldRef<"QuestKillCount", 'Int'>
    readonly MonsterClass5: FieldRef<"QuestKillCount", 'Int'>
    readonly KillCount5: FieldRef<"QuestKillCount", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * QuestKillCount findUnique
   */
  export type QuestKillCountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * Filter, which QuestKillCount to fetch.
     */
    where: QuestKillCountWhereUniqueInput
  }


  /**
   * QuestKillCount findUniqueOrThrow
   */
  export type QuestKillCountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * Filter, which QuestKillCount to fetch.
     */
    where: QuestKillCountWhereUniqueInput
  }


  /**
   * QuestKillCount findFirst
   */
  export type QuestKillCountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * Filter, which QuestKillCount to fetch.
     */
    where?: QuestKillCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestKillCounts to fetch.
     */
    orderBy?: QuestKillCountOrderByWithRelationInput | QuestKillCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestKillCounts.
     */
    cursor?: QuestKillCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestKillCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestKillCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestKillCounts.
     */
    distinct?: QuestKillCountScalarFieldEnum | QuestKillCountScalarFieldEnum[]
  }


  /**
   * QuestKillCount findFirstOrThrow
   */
  export type QuestKillCountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * Filter, which QuestKillCount to fetch.
     */
    where?: QuestKillCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestKillCounts to fetch.
     */
    orderBy?: QuestKillCountOrderByWithRelationInput | QuestKillCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestKillCounts.
     */
    cursor?: QuestKillCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestKillCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestKillCounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestKillCounts.
     */
    distinct?: QuestKillCountScalarFieldEnum | QuestKillCountScalarFieldEnum[]
  }


  /**
   * QuestKillCount findMany
   */
  export type QuestKillCountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * Filter, which QuestKillCounts to fetch.
     */
    where?: QuestKillCountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestKillCounts to fetch.
     */
    orderBy?: QuestKillCountOrderByWithRelationInput | QuestKillCountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestKillCounts.
     */
    cursor?: QuestKillCountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestKillCounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestKillCounts.
     */
    skip?: number
    distinct?: QuestKillCountScalarFieldEnum | QuestKillCountScalarFieldEnum[]
  }


  /**
   * QuestKillCount create
   */
  export type QuestKillCountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * The data needed to create a QuestKillCount.
     */
    data: XOR<QuestKillCountCreateInput, QuestKillCountUncheckedCreateInput>
  }


  /**
   * QuestKillCount createMany
   */
  export type QuestKillCountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestKillCounts.
     */
    data: QuestKillCountCreateManyInput | QuestKillCountCreateManyInput[]
  }


  /**
   * QuestKillCount update
   */
  export type QuestKillCountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * The data needed to update a QuestKillCount.
     */
    data: XOR<QuestKillCountUpdateInput, QuestKillCountUncheckedUpdateInput>
    /**
     * Choose, which QuestKillCount to update.
     */
    where: QuestKillCountWhereUniqueInput
  }


  /**
   * QuestKillCount updateMany
   */
  export type QuestKillCountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestKillCounts.
     */
    data: XOR<QuestKillCountUpdateManyMutationInput, QuestKillCountUncheckedUpdateManyInput>
    /**
     * Filter which QuestKillCounts to update
     */
    where?: QuestKillCountWhereInput
  }


  /**
   * QuestKillCount upsert
   */
  export type QuestKillCountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * The filter to search for the QuestKillCount to update in case it exists.
     */
    where: QuestKillCountWhereUniqueInput
    /**
     * In case the QuestKillCount found by the `where` argument doesn't exist, create a new QuestKillCount with this data.
     */
    create: XOR<QuestKillCountCreateInput, QuestKillCountUncheckedCreateInput>
    /**
     * In case the QuestKillCount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestKillCountUpdateInput, QuestKillCountUncheckedUpdateInput>
  }


  /**
   * QuestKillCount delete
   */
  export type QuestKillCountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
    /**
     * Filter which QuestKillCount to delete.
     */
    where: QuestKillCountWhereUniqueInput
  }


  /**
   * QuestKillCount deleteMany
   */
  export type QuestKillCountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestKillCounts to delete
     */
    where?: QuestKillCountWhereInput
  }


  /**
   * QuestKillCount without action
   */
  export type QuestKillCountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestKillCount
     */
    select?: QuestKillCountSelect<ExtArgs> | null
  }



  /**
   * Model QuestWorld
   */

  export type AggregateQuestWorld = {
    _count: QuestWorldCountAggregateOutputType | null
    _min: QuestWorldMinAggregateOutputType | null
    _max: QuestWorldMaxAggregateOutputType | null
  }

  export type QuestWorldMinAggregateOutputType = {
    Name: string | null
    QuestWorldList: Buffer | null
  }

  export type QuestWorldMaxAggregateOutputType = {
    Name: string | null
    QuestWorldList: Buffer | null
  }

  export type QuestWorldCountAggregateOutputType = {
    Name: number
    QuestWorldList: number
    _all: number
  }


  export type QuestWorldMinAggregateInputType = {
    Name?: true
    QuestWorldList?: true
  }

  export type QuestWorldMaxAggregateInputType = {
    Name?: true
    QuestWorldList?: true
  }

  export type QuestWorldCountAggregateInputType = {
    Name?: true
    QuestWorldList?: true
    _all?: true
  }

  export type QuestWorldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestWorld to aggregate.
     */
    where?: QuestWorldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestWorlds to fetch.
     */
    orderBy?: QuestWorldOrderByWithRelationInput | QuestWorldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestWorldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestWorlds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestWorlds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestWorlds
    **/
    _count?: true | QuestWorldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestWorldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestWorldMaxAggregateInputType
  }

  export type GetQuestWorldAggregateType<T extends QuestWorldAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestWorld]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestWorld[P]>
      : GetScalarType<T[P], AggregateQuestWorld[P]>
  }




  export type QuestWorldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestWorldWhereInput
    orderBy?: QuestWorldOrderByWithAggregationInput | QuestWorldOrderByWithAggregationInput[]
    by: QuestWorldScalarFieldEnum[] | QuestWorldScalarFieldEnum
    having?: QuestWorldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestWorldCountAggregateInputType | true
    _min?: QuestWorldMinAggregateInputType
    _max?: QuestWorldMaxAggregateInputType
  }

  export type QuestWorldGroupByOutputType = {
    Name: string
    QuestWorldList: Buffer | null
    _count: QuestWorldCountAggregateOutputType | null
    _min: QuestWorldMinAggregateOutputType | null
    _max: QuestWorldMaxAggregateOutputType | null
  }

  type GetQuestWorldGroupByPayload<T extends QuestWorldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestWorldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestWorldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestWorldGroupByOutputType[P]>
            : GetScalarType<T[P], QuestWorldGroupByOutputType[P]>
        }
      >
    >


  export type QuestWorldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    QuestWorldList?: boolean
  }, ExtArgs["result"]["questWorld"]>

  export type QuestWorldSelectScalar = {
    Name?: boolean
    QuestWorldList?: boolean
  }


  export type $QuestWorldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestWorld"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      QuestWorldList: Buffer | null
    }, ExtArgs["result"]["questWorld"]>
    composites: {}
  }


  type QuestWorldGetPayload<S extends boolean | null | undefined | QuestWorldDefaultArgs> = $Result.GetResult<Prisma.$QuestWorldPayload, S>

  type QuestWorldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestWorldFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: QuestWorldCountAggregateInputType | true
    }

  export interface QuestWorldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestWorld'], meta: { name: 'QuestWorld' } }
    /**
     * Find zero or one QuestWorld that matches the filter.
     * @param {QuestWorldFindUniqueArgs} args - Arguments to find a QuestWorld
     * @example
     * // Get one QuestWorld
     * const questWorld = await prisma.questWorld.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuestWorldFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, QuestWorldFindUniqueArgs<ExtArgs>>
    ): Prisma__QuestWorldClient<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one QuestWorld that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuestWorldFindUniqueOrThrowArgs} args - Arguments to find a QuestWorld
     * @example
     * // Get one QuestWorld
     * const questWorld = await prisma.questWorld.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuestWorldFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestWorldFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuestWorldClient<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first QuestWorld that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestWorldFindFirstArgs} args - Arguments to find a QuestWorld
     * @example
     * // Get one QuestWorld
     * const questWorld = await prisma.questWorld.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuestWorldFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestWorldFindFirstArgs<ExtArgs>>
    ): Prisma__QuestWorldClient<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first QuestWorld that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestWorldFindFirstOrThrowArgs} args - Arguments to find a QuestWorld
     * @example
     * // Get one QuestWorld
     * const questWorld = await prisma.questWorld.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuestWorldFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestWorldFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuestWorldClient<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more QuestWorlds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestWorldFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestWorlds
     * const questWorlds = await prisma.questWorld.findMany()
     * 
     * // Get first 10 QuestWorlds
     * const questWorlds = await prisma.questWorld.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const questWorldWithNameOnly = await prisma.questWorld.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends QuestWorldFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestWorldFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a QuestWorld.
     * @param {QuestWorldCreateArgs} args - Arguments to create a QuestWorld.
     * @example
     * // Create one QuestWorld
     * const QuestWorld = await prisma.questWorld.create({
     *   data: {
     *     // ... data to create a QuestWorld
     *   }
     * })
     * 
    **/
    create<T extends QuestWorldCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestWorldCreateArgs<ExtArgs>>
    ): Prisma__QuestWorldClient<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many QuestWorlds.
     *     @param {QuestWorldCreateManyArgs} args - Arguments to create many QuestWorlds.
     *     @example
     *     // Create many QuestWorlds
     *     const questWorld = await prisma.questWorld.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuestWorldCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestWorldCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuestWorld.
     * @param {QuestWorldDeleteArgs} args - Arguments to delete one QuestWorld.
     * @example
     * // Delete one QuestWorld
     * const QuestWorld = await prisma.questWorld.delete({
     *   where: {
     *     // ... filter to delete one QuestWorld
     *   }
     * })
     * 
    **/
    delete<T extends QuestWorldDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuestWorldDeleteArgs<ExtArgs>>
    ): Prisma__QuestWorldClient<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one QuestWorld.
     * @param {QuestWorldUpdateArgs} args - Arguments to update one QuestWorld.
     * @example
     * // Update one QuestWorld
     * const questWorld = await prisma.questWorld.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuestWorldUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuestWorldUpdateArgs<ExtArgs>>
    ): Prisma__QuestWorldClient<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more QuestWorlds.
     * @param {QuestWorldDeleteManyArgs} args - Arguments to filter QuestWorlds to delete.
     * @example
     * // Delete a few QuestWorlds
     * const { count } = await prisma.questWorld.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuestWorldDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuestWorldDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestWorlds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestWorldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestWorlds
     * const questWorld = await prisma.questWorld.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuestWorldUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuestWorldUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestWorld.
     * @param {QuestWorldUpsertArgs} args - Arguments to update or create a QuestWorld.
     * @example
     * // Update or create a QuestWorld
     * const questWorld = await prisma.questWorld.upsert({
     *   create: {
     *     // ... data to create a QuestWorld
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestWorld we want to update
     *   }
     * })
    **/
    upsert<T extends QuestWorldUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuestWorldUpsertArgs<ExtArgs>>
    ): Prisma__QuestWorldClient<$Result.GetResult<Prisma.$QuestWorldPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of QuestWorlds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestWorldCountArgs} args - Arguments to filter QuestWorlds to count.
     * @example
     * // Count the number of QuestWorlds
     * const count = await prisma.questWorld.count({
     *   where: {
     *     // ... the filter for the QuestWorlds we want to count
     *   }
     * })
    **/
    count<T extends QuestWorldCountArgs>(
      args?: Subset<T, QuestWorldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestWorldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestWorld.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestWorldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestWorldAggregateArgs>(args: Subset<T, QuestWorldAggregateArgs>): Prisma.PrismaPromise<GetQuestWorldAggregateType<T>>

    /**
     * Group by QuestWorld.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestWorldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestWorldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestWorldGroupByArgs['orderBy'] }
        : { orderBy?: QuestWorldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestWorldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestWorldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestWorld model
   */
  readonly fields: QuestWorldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestWorld.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestWorldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the QuestWorld model
   */ 
  interface QuestWorldFieldRefs {
    readonly Name: FieldRef<"QuestWorld", 'String'>
    readonly QuestWorldList: FieldRef<"QuestWorld", 'Bytes'>
  }
    

  // Custom InputTypes

  /**
   * QuestWorld findUnique
   */
  export type QuestWorldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * Filter, which QuestWorld to fetch.
     */
    where: QuestWorldWhereUniqueInput
  }


  /**
   * QuestWorld findUniqueOrThrow
   */
  export type QuestWorldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * Filter, which QuestWorld to fetch.
     */
    where: QuestWorldWhereUniqueInput
  }


  /**
   * QuestWorld findFirst
   */
  export type QuestWorldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * Filter, which QuestWorld to fetch.
     */
    where?: QuestWorldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestWorlds to fetch.
     */
    orderBy?: QuestWorldOrderByWithRelationInput | QuestWorldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestWorlds.
     */
    cursor?: QuestWorldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestWorlds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestWorlds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestWorlds.
     */
    distinct?: QuestWorldScalarFieldEnum | QuestWorldScalarFieldEnum[]
  }


  /**
   * QuestWorld findFirstOrThrow
   */
  export type QuestWorldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * Filter, which QuestWorld to fetch.
     */
    where?: QuestWorldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestWorlds to fetch.
     */
    orderBy?: QuestWorldOrderByWithRelationInput | QuestWorldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestWorlds.
     */
    cursor?: QuestWorldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestWorlds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestWorlds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestWorlds.
     */
    distinct?: QuestWorldScalarFieldEnum | QuestWorldScalarFieldEnum[]
  }


  /**
   * QuestWorld findMany
   */
  export type QuestWorldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * Filter, which QuestWorlds to fetch.
     */
    where?: QuestWorldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestWorlds to fetch.
     */
    orderBy?: QuestWorldOrderByWithRelationInput | QuestWorldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestWorlds.
     */
    cursor?: QuestWorldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestWorlds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestWorlds.
     */
    skip?: number
    distinct?: QuestWorldScalarFieldEnum | QuestWorldScalarFieldEnum[]
  }


  /**
   * QuestWorld create
   */
  export type QuestWorldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * The data needed to create a QuestWorld.
     */
    data: XOR<QuestWorldCreateInput, QuestWorldUncheckedCreateInput>
  }


  /**
   * QuestWorld createMany
   */
  export type QuestWorldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestWorlds.
     */
    data: QuestWorldCreateManyInput | QuestWorldCreateManyInput[]
  }


  /**
   * QuestWorld update
   */
  export type QuestWorldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * The data needed to update a QuestWorld.
     */
    data: XOR<QuestWorldUpdateInput, QuestWorldUncheckedUpdateInput>
    /**
     * Choose, which QuestWorld to update.
     */
    where: QuestWorldWhereUniqueInput
  }


  /**
   * QuestWorld updateMany
   */
  export type QuestWorldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestWorlds.
     */
    data: XOR<QuestWorldUpdateManyMutationInput, QuestWorldUncheckedUpdateManyInput>
    /**
     * Filter which QuestWorlds to update
     */
    where?: QuestWorldWhereInput
  }


  /**
   * QuestWorld upsert
   */
  export type QuestWorldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * The filter to search for the QuestWorld to update in case it exists.
     */
    where: QuestWorldWhereUniqueInput
    /**
     * In case the QuestWorld found by the `where` argument doesn't exist, create a new QuestWorld with this data.
     */
    create: XOR<QuestWorldCreateInput, QuestWorldUncheckedCreateInput>
    /**
     * In case the QuestWorld was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestWorldUpdateInput, QuestWorldUncheckedUpdateInput>
  }


  /**
   * QuestWorld delete
   */
  export type QuestWorldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
    /**
     * Filter which QuestWorld to delete.
     */
    where: QuestWorldWhereUniqueInput
  }


  /**
   * QuestWorld deleteMany
   */
  export type QuestWorldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestWorlds to delete
     */
    where?: QuestWorldWhereInput
  }


  /**
   * QuestWorld without action
   */
  export type QuestWorldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestWorld
     */
    select?: QuestWorldSelect<ExtArgs> | null
  }



  /**
   * Model RankingBloodCastle
   */

  export type AggregateRankingBloodCastle = {
    _count: RankingBloodCastleCountAggregateOutputType | null
    _avg: RankingBloodCastleAvgAggregateOutputType | null
    _sum: RankingBloodCastleSumAggregateOutputType | null
    _min: RankingBloodCastleMinAggregateOutputType | null
    _max: RankingBloodCastleMaxAggregateOutputType | null
  }

  export type RankingBloodCastleAvgAggregateOutputType = {
    Score: number | null
  }

  export type RankingBloodCastleSumAggregateOutputType = {
    Score: number | null
  }

  export type RankingBloodCastleMinAggregateOutputType = {
    Name: string | null
    Score: number | null
  }

  export type RankingBloodCastleMaxAggregateOutputType = {
    Name: string | null
    Score: number | null
  }

  export type RankingBloodCastleCountAggregateOutputType = {
    Name: number
    Score: number
    _all: number
  }


  export type RankingBloodCastleAvgAggregateInputType = {
    Score?: true
  }

  export type RankingBloodCastleSumAggregateInputType = {
    Score?: true
  }

  export type RankingBloodCastleMinAggregateInputType = {
    Name?: true
    Score?: true
  }

  export type RankingBloodCastleMaxAggregateInputType = {
    Name?: true
    Score?: true
  }

  export type RankingBloodCastleCountAggregateInputType = {
    Name?: true
    Score?: true
    _all?: true
  }

  export type RankingBloodCastleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingBloodCastle to aggregate.
     */
    where?: RankingBloodCastleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingBloodCastles to fetch.
     */
    orderBy?: RankingBloodCastleOrderByWithRelationInput | RankingBloodCastleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankingBloodCastleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingBloodCastles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingBloodCastles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RankingBloodCastles
    **/
    _count?: true | RankingBloodCastleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankingBloodCastleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankingBloodCastleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingBloodCastleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingBloodCastleMaxAggregateInputType
  }

  export type GetRankingBloodCastleAggregateType<T extends RankingBloodCastleAggregateArgs> = {
        [P in keyof T & keyof AggregateRankingBloodCastle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRankingBloodCastle[P]>
      : GetScalarType<T[P], AggregateRankingBloodCastle[P]>
  }




  export type RankingBloodCastleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankingBloodCastleWhereInput
    orderBy?: RankingBloodCastleOrderByWithAggregationInput | RankingBloodCastleOrderByWithAggregationInput[]
    by: RankingBloodCastleScalarFieldEnum[] | RankingBloodCastleScalarFieldEnum
    having?: RankingBloodCastleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingBloodCastleCountAggregateInputType | true
    _avg?: RankingBloodCastleAvgAggregateInputType
    _sum?: RankingBloodCastleSumAggregateInputType
    _min?: RankingBloodCastleMinAggregateInputType
    _max?: RankingBloodCastleMaxAggregateInputType
  }

  export type RankingBloodCastleGroupByOutputType = {
    Name: string
    Score: number | null
    _count: RankingBloodCastleCountAggregateOutputType | null
    _avg: RankingBloodCastleAvgAggregateOutputType | null
    _sum: RankingBloodCastleSumAggregateOutputType | null
    _min: RankingBloodCastleMinAggregateOutputType | null
    _max: RankingBloodCastleMaxAggregateOutputType | null
  }

  type GetRankingBloodCastleGroupByPayload<T extends RankingBloodCastleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankingBloodCastleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingBloodCastleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingBloodCastleGroupByOutputType[P]>
            : GetScalarType<T[P], RankingBloodCastleGroupByOutputType[P]>
        }
      >
    >


  export type RankingBloodCastleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Score?: boolean
  }, ExtArgs["result"]["rankingBloodCastle"]>

  export type RankingBloodCastleSelectScalar = {
    Name?: boolean
    Score?: boolean
  }


  export type $RankingBloodCastlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RankingBloodCastle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Score: number | null
    }, ExtArgs["result"]["rankingBloodCastle"]>
    composites: {}
  }


  type RankingBloodCastleGetPayload<S extends boolean | null | undefined | RankingBloodCastleDefaultArgs> = $Result.GetResult<Prisma.$RankingBloodCastlePayload, S>

  type RankingBloodCastleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RankingBloodCastleFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RankingBloodCastleCountAggregateInputType | true
    }

  export interface RankingBloodCastleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RankingBloodCastle'], meta: { name: 'RankingBloodCastle' } }
    /**
     * Find zero or one RankingBloodCastle that matches the filter.
     * @param {RankingBloodCastleFindUniqueArgs} args - Arguments to find a RankingBloodCastle
     * @example
     * // Get one RankingBloodCastle
     * const rankingBloodCastle = await prisma.rankingBloodCastle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RankingBloodCastleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RankingBloodCastleFindUniqueArgs<ExtArgs>>
    ): Prisma__RankingBloodCastleClient<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RankingBloodCastle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RankingBloodCastleFindUniqueOrThrowArgs} args - Arguments to find a RankingBloodCastle
     * @example
     * // Get one RankingBloodCastle
     * const rankingBloodCastle = await prisma.rankingBloodCastle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RankingBloodCastleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingBloodCastleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RankingBloodCastleClient<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RankingBloodCastle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingBloodCastleFindFirstArgs} args - Arguments to find a RankingBloodCastle
     * @example
     * // Get one RankingBloodCastle
     * const rankingBloodCastle = await prisma.rankingBloodCastle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RankingBloodCastleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingBloodCastleFindFirstArgs<ExtArgs>>
    ): Prisma__RankingBloodCastleClient<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RankingBloodCastle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingBloodCastleFindFirstOrThrowArgs} args - Arguments to find a RankingBloodCastle
     * @example
     * // Get one RankingBloodCastle
     * const rankingBloodCastle = await prisma.rankingBloodCastle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RankingBloodCastleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingBloodCastleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RankingBloodCastleClient<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RankingBloodCastles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingBloodCastleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RankingBloodCastles
     * const rankingBloodCastles = await prisma.rankingBloodCastle.findMany()
     * 
     * // Get first 10 RankingBloodCastles
     * const rankingBloodCastles = await prisma.rankingBloodCastle.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const rankingBloodCastleWithNameOnly = await prisma.rankingBloodCastle.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends RankingBloodCastleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingBloodCastleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RankingBloodCastle.
     * @param {RankingBloodCastleCreateArgs} args - Arguments to create a RankingBloodCastle.
     * @example
     * // Create one RankingBloodCastle
     * const RankingBloodCastle = await prisma.rankingBloodCastle.create({
     *   data: {
     *     // ... data to create a RankingBloodCastle
     *   }
     * })
     * 
    **/
    create<T extends RankingBloodCastleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingBloodCastleCreateArgs<ExtArgs>>
    ): Prisma__RankingBloodCastleClient<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RankingBloodCastles.
     *     @param {RankingBloodCastleCreateManyArgs} args - Arguments to create many RankingBloodCastles.
     *     @example
     *     // Create many RankingBloodCastles
     *     const rankingBloodCastle = await prisma.rankingBloodCastle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RankingBloodCastleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingBloodCastleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RankingBloodCastle.
     * @param {RankingBloodCastleDeleteArgs} args - Arguments to delete one RankingBloodCastle.
     * @example
     * // Delete one RankingBloodCastle
     * const RankingBloodCastle = await prisma.rankingBloodCastle.delete({
     *   where: {
     *     // ... filter to delete one RankingBloodCastle
     *   }
     * })
     * 
    **/
    delete<T extends RankingBloodCastleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RankingBloodCastleDeleteArgs<ExtArgs>>
    ): Prisma__RankingBloodCastleClient<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RankingBloodCastle.
     * @param {RankingBloodCastleUpdateArgs} args - Arguments to update one RankingBloodCastle.
     * @example
     * // Update one RankingBloodCastle
     * const rankingBloodCastle = await prisma.rankingBloodCastle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RankingBloodCastleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingBloodCastleUpdateArgs<ExtArgs>>
    ): Prisma__RankingBloodCastleClient<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RankingBloodCastles.
     * @param {RankingBloodCastleDeleteManyArgs} args - Arguments to filter RankingBloodCastles to delete.
     * @example
     * // Delete a few RankingBloodCastles
     * const { count } = await prisma.rankingBloodCastle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RankingBloodCastleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingBloodCastleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RankingBloodCastles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingBloodCastleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RankingBloodCastles
     * const rankingBloodCastle = await prisma.rankingBloodCastle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RankingBloodCastleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RankingBloodCastleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RankingBloodCastle.
     * @param {RankingBloodCastleUpsertArgs} args - Arguments to update or create a RankingBloodCastle.
     * @example
     * // Update or create a RankingBloodCastle
     * const rankingBloodCastle = await prisma.rankingBloodCastle.upsert({
     *   create: {
     *     // ... data to create a RankingBloodCastle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RankingBloodCastle we want to update
     *   }
     * })
    **/
    upsert<T extends RankingBloodCastleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RankingBloodCastleUpsertArgs<ExtArgs>>
    ): Prisma__RankingBloodCastleClient<$Result.GetResult<Prisma.$RankingBloodCastlePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RankingBloodCastles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingBloodCastleCountArgs} args - Arguments to filter RankingBloodCastles to count.
     * @example
     * // Count the number of RankingBloodCastles
     * const count = await prisma.rankingBloodCastle.count({
     *   where: {
     *     // ... the filter for the RankingBloodCastles we want to count
     *   }
     * })
    **/
    count<T extends RankingBloodCastleCountArgs>(
      args?: Subset<T, RankingBloodCastleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingBloodCastleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RankingBloodCastle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingBloodCastleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingBloodCastleAggregateArgs>(args: Subset<T, RankingBloodCastleAggregateArgs>): Prisma.PrismaPromise<GetRankingBloodCastleAggregateType<T>>

    /**
     * Group by RankingBloodCastle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingBloodCastleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankingBloodCastleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankingBloodCastleGroupByArgs['orderBy'] }
        : { orderBy?: RankingBloodCastleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankingBloodCastleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingBloodCastleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RankingBloodCastle model
   */
  readonly fields: RankingBloodCastleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RankingBloodCastle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankingBloodCastleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RankingBloodCastle model
   */ 
  interface RankingBloodCastleFieldRefs {
    readonly Name: FieldRef<"RankingBloodCastle", 'String'>
    readonly Score: FieldRef<"RankingBloodCastle", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RankingBloodCastle findUnique
   */
  export type RankingBloodCastleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingBloodCastle to fetch.
     */
    where: RankingBloodCastleWhereUniqueInput
  }


  /**
   * RankingBloodCastle findUniqueOrThrow
   */
  export type RankingBloodCastleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingBloodCastle to fetch.
     */
    where: RankingBloodCastleWhereUniqueInput
  }


  /**
   * RankingBloodCastle findFirst
   */
  export type RankingBloodCastleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingBloodCastle to fetch.
     */
    where?: RankingBloodCastleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingBloodCastles to fetch.
     */
    orderBy?: RankingBloodCastleOrderByWithRelationInput | RankingBloodCastleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingBloodCastles.
     */
    cursor?: RankingBloodCastleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingBloodCastles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingBloodCastles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingBloodCastles.
     */
    distinct?: RankingBloodCastleScalarFieldEnum | RankingBloodCastleScalarFieldEnum[]
  }


  /**
   * RankingBloodCastle findFirstOrThrow
   */
  export type RankingBloodCastleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingBloodCastle to fetch.
     */
    where?: RankingBloodCastleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingBloodCastles to fetch.
     */
    orderBy?: RankingBloodCastleOrderByWithRelationInput | RankingBloodCastleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingBloodCastles.
     */
    cursor?: RankingBloodCastleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingBloodCastles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingBloodCastles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingBloodCastles.
     */
    distinct?: RankingBloodCastleScalarFieldEnum | RankingBloodCastleScalarFieldEnum[]
  }


  /**
   * RankingBloodCastle findMany
   */
  export type RankingBloodCastleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingBloodCastles to fetch.
     */
    where?: RankingBloodCastleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingBloodCastles to fetch.
     */
    orderBy?: RankingBloodCastleOrderByWithRelationInput | RankingBloodCastleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RankingBloodCastles.
     */
    cursor?: RankingBloodCastleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingBloodCastles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingBloodCastles.
     */
    skip?: number
    distinct?: RankingBloodCastleScalarFieldEnum | RankingBloodCastleScalarFieldEnum[]
  }


  /**
   * RankingBloodCastle create
   */
  export type RankingBloodCastleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * The data needed to create a RankingBloodCastle.
     */
    data: XOR<RankingBloodCastleCreateInput, RankingBloodCastleUncheckedCreateInput>
  }


  /**
   * RankingBloodCastle createMany
   */
  export type RankingBloodCastleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RankingBloodCastles.
     */
    data: RankingBloodCastleCreateManyInput | RankingBloodCastleCreateManyInput[]
  }


  /**
   * RankingBloodCastle update
   */
  export type RankingBloodCastleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * The data needed to update a RankingBloodCastle.
     */
    data: XOR<RankingBloodCastleUpdateInput, RankingBloodCastleUncheckedUpdateInput>
    /**
     * Choose, which RankingBloodCastle to update.
     */
    where: RankingBloodCastleWhereUniqueInput
  }


  /**
   * RankingBloodCastle updateMany
   */
  export type RankingBloodCastleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RankingBloodCastles.
     */
    data: XOR<RankingBloodCastleUpdateManyMutationInput, RankingBloodCastleUncheckedUpdateManyInput>
    /**
     * Filter which RankingBloodCastles to update
     */
    where?: RankingBloodCastleWhereInput
  }


  /**
   * RankingBloodCastle upsert
   */
  export type RankingBloodCastleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * The filter to search for the RankingBloodCastle to update in case it exists.
     */
    where: RankingBloodCastleWhereUniqueInput
    /**
     * In case the RankingBloodCastle found by the `where` argument doesn't exist, create a new RankingBloodCastle with this data.
     */
    create: XOR<RankingBloodCastleCreateInput, RankingBloodCastleUncheckedCreateInput>
    /**
     * In case the RankingBloodCastle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankingBloodCastleUpdateInput, RankingBloodCastleUncheckedUpdateInput>
  }


  /**
   * RankingBloodCastle delete
   */
  export type RankingBloodCastleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
    /**
     * Filter which RankingBloodCastle to delete.
     */
    where: RankingBloodCastleWhereUniqueInput
  }


  /**
   * RankingBloodCastle deleteMany
   */
  export type RankingBloodCastleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingBloodCastles to delete
     */
    where?: RankingBloodCastleWhereInput
  }


  /**
   * RankingBloodCastle without action
   */
  export type RankingBloodCastleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingBloodCastle
     */
    select?: RankingBloodCastleSelect<ExtArgs> | null
  }



  /**
   * Model RankingChaosCastle
   */

  export type AggregateRankingChaosCastle = {
    _count: RankingChaosCastleCountAggregateOutputType | null
    _avg: RankingChaosCastleAvgAggregateOutputType | null
    _sum: RankingChaosCastleSumAggregateOutputType | null
    _min: RankingChaosCastleMinAggregateOutputType | null
    _max: RankingChaosCastleMaxAggregateOutputType | null
  }

  export type RankingChaosCastleAvgAggregateOutputType = {
    Score: number | null
  }

  export type RankingChaosCastleSumAggregateOutputType = {
    Score: number | null
  }

  export type RankingChaosCastleMinAggregateOutputType = {
    Name: string | null
    Score: number | null
  }

  export type RankingChaosCastleMaxAggregateOutputType = {
    Name: string | null
    Score: number | null
  }

  export type RankingChaosCastleCountAggregateOutputType = {
    Name: number
    Score: number
    _all: number
  }


  export type RankingChaosCastleAvgAggregateInputType = {
    Score?: true
  }

  export type RankingChaosCastleSumAggregateInputType = {
    Score?: true
  }

  export type RankingChaosCastleMinAggregateInputType = {
    Name?: true
    Score?: true
  }

  export type RankingChaosCastleMaxAggregateInputType = {
    Name?: true
    Score?: true
  }

  export type RankingChaosCastleCountAggregateInputType = {
    Name?: true
    Score?: true
    _all?: true
  }

  export type RankingChaosCastleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingChaosCastle to aggregate.
     */
    where?: RankingChaosCastleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingChaosCastles to fetch.
     */
    orderBy?: RankingChaosCastleOrderByWithRelationInput | RankingChaosCastleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankingChaosCastleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingChaosCastles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingChaosCastles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RankingChaosCastles
    **/
    _count?: true | RankingChaosCastleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankingChaosCastleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankingChaosCastleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingChaosCastleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingChaosCastleMaxAggregateInputType
  }

  export type GetRankingChaosCastleAggregateType<T extends RankingChaosCastleAggregateArgs> = {
        [P in keyof T & keyof AggregateRankingChaosCastle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRankingChaosCastle[P]>
      : GetScalarType<T[P], AggregateRankingChaosCastle[P]>
  }




  export type RankingChaosCastleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankingChaosCastleWhereInput
    orderBy?: RankingChaosCastleOrderByWithAggregationInput | RankingChaosCastleOrderByWithAggregationInput[]
    by: RankingChaosCastleScalarFieldEnum[] | RankingChaosCastleScalarFieldEnum
    having?: RankingChaosCastleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingChaosCastleCountAggregateInputType | true
    _avg?: RankingChaosCastleAvgAggregateInputType
    _sum?: RankingChaosCastleSumAggregateInputType
    _min?: RankingChaosCastleMinAggregateInputType
    _max?: RankingChaosCastleMaxAggregateInputType
  }

  export type RankingChaosCastleGroupByOutputType = {
    Name: string
    Score: number | null
    _count: RankingChaosCastleCountAggregateOutputType | null
    _avg: RankingChaosCastleAvgAggregateOutputType | null
    _sum: RankingChaosCastleSumAggregateOutputType | null
    _min: RankingChaosCastleMinAggregateOutputType | null
    _max: RankingChaosCastleMaxAggregateOutputType | null
  }

  type GetRankingChaosCastleGroupByPayload<T extends RankingChaosCastleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankingChaosCastleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingChaosCastleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingChaosCastleGroupByOutputType[P]>
            : GetScalarType<T[P], RankingChaosCastleGroupByOutputType[P]>
        }
      >
    >


  export type RankingChaosCastleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Score?: boolean
  }, ExtArgs["result"]["rankingChaosCastle"]>

  export type RankingChaosCastleSelectScalar = {
    Name?: boolean
    Score?: boolean
  }


  export type $RankingChaosCastlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RankingChaosCastle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Score: number | null
    }, ExtArgs["result"]["rankingChaosCastle"]>
    composites: {}
  }


  type RankingChaosCastleGetPayload<S extends boolean | null | undefined | RankingChaosCastleDefaultArgs> = $Result.GetResult<Prisma.$RankingChaosCastlePayload, S>

  type RankingChaosCastleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RankingChaosCastleFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RankingChaosCastleCountAggregateInputType | true
    }

  export interface RankingChaosCastleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RankingChaosCastle'], meta: { name: 'RankingChaosCastle' } }
    /**
     * Find zero or one RankingChaosCastle that matches the filter.
     * @param {RankingChaosCastleFindUniqueArgs} args - Arguments to find a RankingChaosCastle
     * @example
     * // Get one RankingChaosCastle
     * const rankingChaosCastle = await prisma.rankingChaosCastle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RankingChaosCastleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RankingChaosCastleFindUniqueArgs<ExtArgs>>
    ): Prisma__RankingChaosCastleClient<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RankingChaosCastle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RankingChaosCastleFindUniqueOrThrowArgs} args - Arguments to find a RankingChaosCastle
     * @example
     * // Get one RankingChaosCastle
     * const rankingChaosCastle = await prisma.rankingChaosCastle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RankingChaosCastleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingChaosCastleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RankingChaosCastleClient<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RankingChaosCastle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingChaosCastleFindFirstArgs} args - Arguments to find a RankingChaosCastle
     * @example
     * // Get one RankingChaosCastle
     * const rankingChaosCastle = await prisma.rankingChaosCastle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RankingChaosCastleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingChaosCastleFindFirstArgs<ExtArgs>>
    ): Prisma__RankingChaosCastleClient<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RankingChaosCastle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingChaosCastleFindFirstOrThrowArgs} args - Arguments to find a RankingChaosCastle
     * @example
     * // Get one RankingChaosCastle
     * const rankingChaosCastle = await prisma.rankingChaosCastle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RankingChaosCastleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingChaosCastleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RankingChaosCastleClient<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RankingChaosCastles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingChaosCastleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RankingChaosCastles
     * const rankingChaosCastles = await prisma.rankingChaosCastle.findMany()
     * 
     * // Get first 10 RankingChaosCastles
     * const rankingChaosCastles = await prisma.rankingChaosCastle.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const rankingChaosCastleWithNameOnly = await prisma.rankingChaosCastle.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends RankingChaosCastleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingChaosCastleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RankingChaosCastle.
     * @param {RankingChaosCastleCreateArgs} args - Arguments to create a RankingChaosCastle.
     * @example
     * // Create one RankingChaosCastle
     * const RankingChaosCastle = await prisma.rankingChaosCastle.create({
     *   data: {
     *     // ... data to create a RankingChaosCastle
     *   }
     * })
     * 
    **/
    create<T extends RankingChaosCastleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingChaosCastleCreateArgs<ExtArgs>>
    ): Prisma__RankingChaosCastleClient<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RankingChaosCastles.
     *     @param {RankingChaosCastleCreateManyArgs} args - Arguments to create many RankingChaosCastles.
     *     @example
     *     // Create many RankingChaosCastles
     *     const rankingChaosCastle = await prisma.rankingChaosCastle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RankingChaosCastleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingChaosCastleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RankingChaosCastle.
     * @param {RankingChaosCastleDeleteArgs} args - Arguments to delete one RankingChaosCastle.
     * @example
     * // Delete one RankingChaosCastle
     * const RankingChaosCastle = await prisma.rankingChaosCastle.delete({
     *   where: {
     *     // ... filter to delete one RankingChaosCastle
     *   }
     * })
     * 
    **/
    delete<T extends RankingChaosCastleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RankingChaosCastleDeleteArgs<ExtArgs>>
    ): Prisma__RankingChaosCastleClient<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RankingChaosCastle.
     * @param {RankingChaosCastleUpdateArgs} args - Arguments to update one RankingChaosCastle.
     * @example
     * // Update one RankingChaosCastle
     * const rankingChaosCastle = await prisma.rankingChaosCastle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RankingChaosCastleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingChaosCastleUpdateArgs<ExtArgs>>
    ): Prisma__RankingChaosCastleClient<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RankingChaosCastles.
     * @param {RankingChaosCastleDeleteManyArgs} args - Arguments to filter RankingChaosCastles to delete.
     * @example
     * // Delete a few RankingChaosCastles
     * const { count } = await prisma.rankingChaosCastle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RankingChaosCastleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingChaosCastleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RankingChaosCastles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingChaosCastleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RankingChaosCastles
     * const rankingChaosCastle = await prisma.rankingChaosCastle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RankingChaosCastleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RankingChaosCastleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RankingChaosCastle.
     * @param {RankingChaosCastleUpsertArgs} args - Arguments to update or create a RankingChaosCastle.
     * @example
     * // Update or create a RankingChaosCastle
     * const rankingChaosCastle = await prisma.rankingChaosCastle.upsert({
     *   create: {
     *     // ... data to create a RankingChaosCastle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RankingChaosCastle we want to update
     *   }
     * })
    **/
    upsert<T extends RankingChaosCastleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RankingChaosCastleUpsertArgs<ExtArgs>>
    ): Prisma__RankingChaosCastleClient<$Result.GetResult<Prisma.$RankingChaosCastlePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RankingChaosCastles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingChaosCastleCountArgs} args - Arguments to filter RankingChaosCastles to count.
     * @example
     * // Count the number of RankingChaosCastles
     * const count = await prisma.rankingChaosCastle.count({
     *   where: {
     *     // ... the filter for the RankingChaosCastles we want to count
     *   }
     * })
    **/
    count<T extends RankingChaosCastleCountArgs>(
      args?: Subset<T, RankingChaosCastleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingChaosCastleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RankingChaosCastle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingChaosCastleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingChaosCastleAggregateArgs>(args: Subset<T, RankingChaosCastleAggregateArgs>): Prisma.PrismaPromise<GetRankingChaosCastleAggregateType<T>>

    /**
     * Group by RankingChaosCastle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingChaosCastleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankingChaosCastleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankingChaosCastleGroupByArgs['orderBy'] }
        : { orderBy?: RankingChaosCastleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankingChaosCastleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingChaosCastleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RankingChaosCastle model
   */
  readonly fields: RankingChaosCastleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RankingChaosCastle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankingChaosCastleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RankingChaosCastle model
   */ 
  interface RankingChaosCastleFieldRefs {
    readonly Name: FieldRef<"RankingChaosCastle", 'String'>
    readonly Score: FieldRef<"RankingChaosCastle", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RankingChaosCastle findUnique
   */
  export type RankingChaosCastleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingChaosCastle to fetch.
     */
    where: RankingChaosCastleWhereUniqueInput
  }


  /**
   * RankingChaosCastle findUniqueOrThrow
   */
  export type RankingChaosCastleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingChaosCastle to fetch.
     */
    where: RankingChaosCastleWhereUniqueInput
  }


  /**
   * RankingChaosCastle findFirst
   */
  export type RankingChaosCastleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingChaosCastle to fetch.
     */
    where?: RankingChaosCastleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingChaosCastles to fetch.
     */
    orderBy?: RankingChaosCastleOrderByWithRelationInput | RankingChaosCastleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingChaosCastles.
     */
    cursor?: RankingChaosCastleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingChaosCastles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingChaosCastles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingChaosCastles.
     */
    distinct?: RankingChaosCastleScalarFieldEnum | RankingChaosCastleScalarFieldEnum[]
  }


  /**
   * RankingChaosCastle findFirstOrThrow
   */
  export type RankingChaosCastleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingChaosCastle to fetch.
     */
    where?: RankingChaosCastleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingChaosCastles to fetch.
     */
    orderBy?: RankingChaosCastleOrderByWithRelationInput | RankingChaosCastleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingChaosCastles.
     */
    cursor?: RankingChaosCastleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingChaosCastles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingChaosCastles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingChaosCastles.
     */
    distinct?: RankingChaosCastleScalarFieldEnum | RankingChaosCastleScalarFieldEnum[]
  }


  /**
   * RankingChaosCastle findMany
   */
  export type RankingChaosCastleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * Filter, which RankingChaosCastles to fetch.
     */
    where?: RankingChaosCastleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingChaosCastles to fetch.
     */
    orderBy?: RankingChaosCastleOrderByWithRelationInput | RankingChaosCastleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RankingChaosCastles.
     */
    cursor?: RankingChaosCastleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingChaosCastles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingChaosCastles.
     */
    skip?: number
    distinct?: RankingChaosCastleScalarFieldEnum | RankingChaosCastleScalarFieldEnum[]
  }


  /**
   * RankingChaosCastle create
   */
  export type RankingChaosCastleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * The data needed to create a RankingChaosCastle.
     */
    data: XOR<RankingChaosCastleCreateInput, RankingChaosCastleUncheckedCreateInput>
  }


  /**
   * RankingChaosCastle createMany
   */
  export type RankingChaosCastleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RankingChaosCastles.
     */
    data: RankingChaosCastleCreateManyInput | RankingChaosCastleCreateManyInput[]
  }


  /**
   * RankingChaosCastle update
   */
  export type RankingChaosCastleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * The data needed to update a RankingChaosCastle.
     */
    data: XOR<RankingChaosCastleUpdateInput, RankingChaosCastleUncheckedUpdateInput>
    /**
     * Choose, which RankingChaosCastle to update.
     */
    where: RankingChaosCastleWhereUniqueInput
  }


  /**
   * RankingChaosCastle updateMany
   */
  export type RankingChaosCastleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RankingChaosCastles.
     */
    data: XOR<RankingChaosCastleUpdateManyMutationInput, RankingChaosCastleUncheckedUpdateManyInput>
    /**
     * Filter which RankingChaosCastles to update
     */
    where?: RankingChaosCastleWhereInput
  }


  /**
   * RankingChaosCastle upsert
   */
  export type RankingChaosCastleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * The filter to search for the RankingChaosCastle to update in case it exists.
     */
    where: RankingChaosCastleWhereUniqueInput
    /**
     * In case the RankingChaosCastle found by the `where` argument doesn't exist, create a new RankingChaosCastle with this data.
     */
    create: XOR<RankingChaosCastleCreateInput, RankingChaosCastleUncheckedCreateInput>
    /**
     * In case the RankingChaosCastle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankingChaosCastleUpdateInput, RankingChaosCastleUncheckedUpdateInput>
  }


  /**
   * RankingChaosCastle delete
   */
  export type RankingChaosCastleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
    /**
     * Filter which RankingChaosCastle to delete.
     */
    where: RankingChaosCastleWhereUniqueInput
  }


  /**
   * RankingChaosCastle deleteMany
   */
  export type RankingChaosCastleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingChaosCastles to delete
     */
    where?: RankingChaosCastleWhereInput
  }


  /**
   * RankingChaosCastle without action
   */
  export type RankingChaosCastleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingChaosCastle
     */
    select?: RankingChaosCastleSelect<ExtArgs> | null
  }



  /**
   * Model RankingDevilSquare
   */

  export type AggregateRankingDevilSquare = {
    _count: RankingDevilSquareCountAggregateOutputType | null
    _avg: RankingDevilSquareAvgAggregateOutputType | null
    _sum: RankingDevilSquareSumAggregateOutputType | null
    _min: RankingDevilSquareMinAggregateOutputType | null
    _max: RankingDevilSquareMaxAggregateOutputType | null
  }

  export type RankingDevilSquareAvgAggregateOutputType = {
    Score: number | null
  }

  export type RankingDevilSquareSumAggregateOutputType = {
    Score: number | null
  }

  export type RankingDevilSquareMinAggregateOutputType = {
    Name: string | null
    Score: number | null
  }

  export type RankingDevilSquareMaxAggregateOutputType = {
    Name: string | null
    Score: number | null
  }

  export type RankingDevilSquareCountAggregateOutputType = {
    Name: number
    Score: number
    _all: number
  }


  export type RankingDevilSquareAvgAggregateInputType = {
    Score?: true
  }

  export type RankingDevilSquareSumAggregateInputType = {
    Score?: true
  }

  export type RankingDevilSquareMinAggregateInputType = {
    Name?: true
    Score?: true
  }

  export type RankingDevilSquareMaxAggregateInputType = {
    Name?: true
    Score?: true
  }

  export type RankingDevilSquareCountAggregateInputType = {
    Name?: true
    Score?: true
    _all?: true
  }

  export type RankingDevilSquareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingDevilSquare to aggregate.
     */
    where?: RankingDevilSquareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingDevilSquares to fetch.
     */
    orderBy?: RankingDevilSquareOrderByWithRelationInput | RankingDevilSquareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankingDevilSquareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingDevilSquares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingDevilSquares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RankingDevilSquares
    **/
    _count?: true | RankingDevilSquareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankingDevilSquareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankingDevilSquareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingDevilSquareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingDevilSquareMaxAggregateInputType
  }

  export type GetRankingDevilSquareAggregateType<T extends RankingDevilSquareAggregateArgs> = {
        [P in keyof T & keyof AggregateRankingDevilSquare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRankingDevilSquare[P]>
      : GetScalarType<T[P], AggregateRankingDevilSquare[P]>
  }




  export type RankingDevilSquareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankingDevilSquareWhereInput
    orderBy?: RankingDevilSquareOrderByWithAggregationInput | RankingDevilSquareOrderByWithAggregationInput[]
    by: RankingDevilSquareScalarFieldEnum[] | RankingDevilSquareScalarFieldEnum
    having?: RankingDevilSquareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingDevilSquareCountAggregateInputType | true
    _avg?: RankingDevilSquareAvgAggregateInputType
    _sum?: RankingDevilSquareSumAggregateInputType
    _min?: RankingDevilSquareMinAggregateInputType
    _max?: RankingDevilSquareMaxAggregateInputType
  }

  export type RankingDevilSquareGroupByOutputType = {
    Name: string
    Score: number | null
    _count: RankingDevilSquareCountAggregateOutputType | null
    _avg: RankingDevilSquareAvgAggregateOutputType | null
    _sum: RankingDevilSquareSumAggregateOutputType | null
    _min: RankingDevilSquareMinAggregateOutputType | null
    _max: RankingDevilSquareMaxAggregateOutputType | null
  }

  type GetRankingDevilSquareGroupByPayload<T extends RankingDevilSquareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankingDevilSquareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingDevilSquareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingDevilSquareGroupByOutputType[P]>
            : GetScalarType<T[P], RankingDevilSquareGroupByOutputType[P]>
        }
      >
    >


  export type RankingDevilSquareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Score?: boolean
  }, ExtArgs["result"]["rankingDevilSquare"]>

  export type RankingDevilSquareSelectScalar = {
    Name?: boolean
    Score?: boolean
  }


  export type $RankingDevilSquarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RankingDevilSquare"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Score: number | null
    }, ExtArgs["result"]["rankingDevilSquare"]>
    composites: {}
  }


  type RankingDevilSquareGetPayload<S extends boolean | null | undefined | RankingDevilSquareDefaultArgs> = $Result.GetResult<Prisma.$RankingDevilSquarePayload, S>

  type RankingDevilSquareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RankingDevilSquareFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RankingDevilSquareCountAggregateInputType | true
    }

  export interface RankingDevilSquareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RankingDevilSquare'], meta: { name: 'RankingDevilSquare' } }
    /**
     * Find zero or one RankingDevilSquare that matches the filter.
     * @param {RankingDevilSquareFindUniqueArgs} args - Arguments to find a RankingDevilSquare
     * @example
     * // Get one RankingDevilSquare
     * const rankingDevilSquare = await prisma.rankingDevilSquare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RankingDevilSquareFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDevilSquareFindUniqueArgs<ExtArgs>>
    ): Prisma__RankingDevilSquareClient<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RankingDevilSquare that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RankingDevilSquareFindUniqueOrThrowArgs} args - Arguments to find a RankingDevilSquare
     * @example
     * // Get one RankingDevilSquare
     * const rankingDevilSquare = await prisma.rankingDevilSquare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RankingDevilSquareFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDevilSquareFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RankingDevilSquareClient<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RankingDevilSquare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDevilSquareFindFirstArgs} args - Arguments to find a RankingDevilSquare
     * @example
     * // Get one RankingDevilSquare
     * const rankingDevilSquare = await prisma.rankingDevilSquare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RankingDevilSquareFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDevilSquareFindFirstArgs<ExtArgs>>
    ): Prisma__RankingDevilSquareClient<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RankingDevilSquare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDevilSquareFindFirstOrThrowArgs} args - Arguments to find a RankingDevilSquare
     * @example
     * // Get one RankingDevilSquare
     * const rankingDevilSquare = await prisma.rankingDevilSquare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RankingDevilSquareFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDevilSquareFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RankingDevilSquareClient<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RankingDevilSquares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDevilSquareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RankingDevilSquares
     * const rankingDevilSquares = await prisma.rankingDevilSquare.findMany()
     * 
     * // Get first 10 RankingDevilSquares
     * const rankingDevilSquares = await prisma.rankingDevilSquare.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const rankingDevilSquareWithNameOnly = await prisma.rankingDevilSquare.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends RankingDevilSquareFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDevilSquareFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RankingDevilSquare.
     * @param {RankingDevilSquareCreateArgs} args - Arguments to create a RankingDevilSquare.
     * @example
     * // Create one RankingDevilSquare
     * const RankingDevilSquare = await prisma.rankingDevilSquare.create({
     *   data: {
     *     // ... data to create a RankingDevilSquare
     *   }
     * })
     * 
    **/
    create<T extends RankingDevilSquareCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDevilSquareCreateArgs<ExtArgs>>
    ): Prisma__RankingDevilSquareClient<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RankingDevilSquares.
     *     @param {RankingDevilSquareCreateManyArgs} args - Arguments to create many RankingDevilSquares.
     *     @example
     *     // Create many RankingDevilSquares
     *     const rankingDevilSquare = await prisma.rankingDevilSquare.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RankingDevilSquareCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDevilSquareCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RankingDevilSquare.
     * @param {RankingDevilSquareDeleteArgs} args - Arguments to delete one RankingDevilSquare.
     * @example
     * // Delete one RankingDevilSquare
     * const RankingDevilSquare = await prisma.rankingDevilSquare.delete({
     *   where: {
     *     // ... filter to delete one RankingDevilSquare
     *   }
     * })
     * 
    **/
    delete<T extends RankingDevilSquareDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDevilSquareDeleteArgs<ExtArgs>>
    ): Prisma__RankingDevilSquareClient<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RankingDevilSquare.
     * @param {RankingDevilSquareUpdateArgs} args - Arguments to update one RankingDevilSquare.
     * @example
     * // Update one RankingDevilSquare
     * const rankingDevilSquare = await prisma.rankingDevilSquare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RankingDevilSquareUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDevilSquareUpdateArgs<ExtArgs>>
    ): Prisma__RankingDevilSquareClient<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RankingDevilSquares.
     * @param {RankingDevilSquareDeleteManyArgs} args - Arguments to filter RankingDevilSquares to delete.
     * @example
     * // Delete a few RankingDevilSquares
     * const { count } = await prisma.rankingDevilSquare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RankingDevilSquareDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDevilSquareDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RankingDevilSquares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDevilSquareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RankingDevilSquares
     * const rankingDevilSquare = await prisma.rankingDevilSquare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RankingDevilSquareUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDevilSquareUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RankingDevilSquare.
     * @param {RankingDevilSquareUpsertArgs} args - Arguments to update or create a RankingDevilSquare.
     * @example
     * // Update or create a RankingDevilSquare
     * const rankingDevilSquare = await prisma.rankingDevilSquare.upsert({
     *   create: {
     *     // ... data to create a RankingDevilSquare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RankingDevilSquare we want to update
     *   }
     * })
    **/
    upsert<T extends RankingDevilSquareUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDevilSquareUpsertArgs<ExtArgs>>
    ): Prisma__RankingDevilSquareClient<$Result.GetResult<Prisma.$RankingDevilSquarePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RankingDevilSquares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDevilSquareCountArgs} args - Arguments to filter RankingDevilSquares to count.
     * @example
     * // Count the number of RankingDevilSquares
     * const count = await prisma.rankingDevilSquare.count({
     *   where: {
     *     // ... the filter for the RankingDevilSquares we want to count
     *   }
     * })
    **/
    count<T extends RankingDevilSquareCountArgs>(
      args?: Subset<T, RankingDevilSquareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingDevilSquareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RankingDevilSquare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDevilSquareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingDevilSquareAggregateArgs>(args: Subset<T, RankingDevilSquareAggregateArgs>): Prisma.PrismaPromise<GetRankingDevilSquareAggregateType<T>>

    /**
     * Group by RankingDevilSquare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDevilSquareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankingDevilSquareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankingDevilSquareGroupByArgs['orderBy'] }
        : { orderBy?: RankingDevilSquareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankingDevilSquareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingDevilSquareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RankingDevilSquare model
   */
  readonly fields: RankingDevilSquareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RankingDevilSquare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankingDevilSquareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RankingDevilSquare model
   */ 
  interface RankingDevilSquareFieldRefs {
    readonly Name: FieldRef<"RankingDevilSquare", 'String'>
    readonly Score: FieldRef<"RankingDevilSquare", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RankingDevilSquare findUnique
   */
  export type RankingDevilSquareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * Filter, which RankingDevilSquare to fetch.
     */
    where: RankingDevilSquareWhereUniqueInput
  }


  /**
   * RankingDevilSquare findUniqueOrThrow
   */
  export type RankingDevilSquareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * Filter, which RankingDevilSquare to fetch.
     */
    where: RankingDevilSquareWhereUniqueInput
  }


  /**
   * RankingDevilSquare findFirst
   */
  export type RankingDevilSquareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * Filter, which RankingDevilSquare to fetch.
     */
    where?: RankingDevilSquareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingDevilSquares to fetch.
     */
    orderBy?: RankingDevilSquareOrderByWithRelationInput | RankingDevilSquareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingDevilSquares.
     */
    cursor?: RankingDevilSquareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingDevilSquares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingDevilSquares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingDevilSquares.
     */
    distinct?: RankingDevilSquareScalarFieldEnum | RankingDevilSquareScalarFieldEnum[]
  }


  /**
   * RankingDevilSquare findFirstOrThrow
   */
  export type RankingDevilSquareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * Filter, which RankingDevilSquare to fetch.
     */
    where?: RankingDevilSquareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingDevilSquares to fetch.
     */
    orderBy?: RankingDevilSquareOrderByWithRelationInput | RankingDevilSquareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingDevilSquares.
     */
    cursor?: RankingDevilSquareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingDevilSquares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingDevilSquares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingDevilSquares.
     */
    distinct?: RankingDevilSquareScalarFieldEnum | RankingDevilSquareScalarFieldEnum[]
  }


  /**
   * RankingDevilSquare findMany
   */
  export type RankingDevilSquareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * Filter, which RankingDevilSquares to fetch.
     */
    where?: RankingDevilSquareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingDevilSquares to fetch.
     */
    orderBy?: RankingDevilSquareOrderByWithRelationInput | RankingDevilSquareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RankingDevilSquares.
     */
    cursor?: RankingDevilSquareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingDevilSquares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingDevilSquares.
     */
    skip?: number
    distinct?: RankingDevilSquareScalarFieldEnum | RankingDevilSquareScalarFieldEnum[]
  }


  /**
   * RankingDevilSquare create
   */
  export type RankingDevilSquareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * The data needed to create a RankingDevilSquare.
     */
    data: XOR<RankingDevilSquareCreateInput, RankingDevilSquareUncheckedCreateInput>
  }


  /**
   * RankingDevilSquare createMany
   */
  export type RankingDevilSquareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RankingDevilSquares.
     */
    data: RankingDevilSquareCreateManyInput | RankingDevilSquareCreateManyInput[]
  }


  /**
   * RankingDevilSquare update
   */
  export type RankingDevilSquareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * The data needed to update a RankingDevilSquare.
     */
    data: XOR<RankingDevilSquareUpdateInput, RankingDevilSquareUncheckedUpdateInput>
    /**
     * Choose, which RankingDevilSquare to update.
     */
    where: RankingDevilSquareWhereUniqueInput
  }


  /**
   * RankingDevilSquare updateMany
   */
  export type RankingDevilSquareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RankingDevilSquares.
     */
    data: XOR<RankingDevilSquareUpdateManyMutationInput, RankingDevilSquareUncheckedUpdateManyInput>
    /**
     * Filter which RankingDevilSquares to update
     */
    where?: RankingDevilSquareWhereInput
  }


  /**
   * RankingDevilSquare upsert
   */
  export type RankingDevilSquareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * The filter to search for the RankingDevilSquare to update in case it exists.
     */
    where: RankingDevilSquareWhereUniqueInput
    /**
     * In case the RankingDevilSquare found by the `where` argument doesn't exist, create a new RankingDevilSquare with this data.
     */
    create: XOR<RankingDevilSquareCreateInput, RankingDevilSquareUncheckedCreateInput>
    /**
     * In case the RankingDevilSquare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankingDevilSquareUpdateInput, RankingDevilSquareUncheckedUpdateInput>
  }


  /**
   * RankingDevilSquare delete
   */
  export type RankingDevilSquareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
    /**
     * Filter which RankingDevilSquare to delete.
     */
    where: RankingDevilSquareWhereUniqueInput
  }


  /**
   * RankingDevilSquare deleteMany
   */
  export type RankingDevilSquareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingDevilSquares to delete
     */
    where?: RankingDevilSquareWhereInput
  }


  /**
   * RankingDevilSquare without action
   */
  export type RankingDevilSquareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDevilSquare
     */
    select?: RankingDevilSquareSelect<ExtArgs> | null
  }



  /**
   * Model RankingDuel
   */

  export type AggregateRankingDuel = {
    _count: RankingDuelCountAggregateOutputType | null
    _avg: RankingDuelAvgAggregateOutputType | null
    _sum: RankingDuelSumAggregateOutputType | null
    _min: RankingDuelMinAggregateOutputType | null
    _max: RankingDuelMaxAggregateOutputType | null
  }

  export type RankingDuelAvgAggregateOutputType = {
    WinScore: number | null
    LoseScore: number | null
  }

  export type RankingDuelSumAggregateOutputType = {
    WinScore: number | null
    LoseScore: number | null
  }

  export type RankingDuelMinAggregateOutputType = {
    Name: string | null
    WinScore: number | null
    LoseScore: number | null
  }

  export type RankingDuelMaxAggregateOutputType = {
    Name: string | null
    WinScore: number | null
    LoseScore: number | null
  }

  export type RankingDuelCountAggregateOutputType = {
    Name: number
    WinScore: number
    LoseScore: number
    _all: number
  }


  export type RankingDuelAvgAggregateInputType = {
    WinScore?: true
    LoseScore?: true
  }

  export type RankingDuelSumAggregateInputType = {
    WinScore?: true
    LoseScore?: true
  }

  export type RankingDuelMinAggregateInputType = {
    Name?: true
    WinScore?: true
    LoseScore?: true
  }

  export type RankingDuelMaxAggregateInputType = {
    Name?: true
    WinScore?: true
    LoseScore?: true
  }

  export type RankingDuelCountAggregateInputType = {
    Name?: true
    WinScore?: true
    LoseScore?: true
    _all?: true
  }

  export type RankingDuelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingDuel to aggregate.
     */
    where?: RankingDuelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingDuels to fetch.
     */
    orderBy?: RankingDuelOrderByWithRelationInput | RankingDuelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankingDuelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingDuels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingDuels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RankingDuels
    **/
    _count?: true | RankingDuelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankingDuelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankingDuelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingDuelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingDuelMaxAggregateInputType
  }

  export type GetRankingDuelAggregateType<T extends RankingDuelAggregateArgs> = {
        [P in keyof T & keyof AggregateRankingDuel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRankingDuel[P]>
      : GetScalarType<T[P], AggregateRankingDuel[P]>
  }




  export type RankingDuelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankingDuelWhereInput
    orderBy?: RankingDuelOrderByWithAggregationInput | RankingDuelOrderByWithAggregationInput[]
    by: RankingDuelScalarFieldEnum[] | RankingDuelScalarFieldEnum
    having?: RankingDuelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingDuelCountAggregateInputType | true
    _avg?: RankingDuelAvgAggregateInputType
    _sum?: RankingDuelSumAggregateInputType
    _min?: RankingDuelMinAggregateInputType
    _max?: RankingDuelMaxAggregateInputType
  }

  export type RankingDuelGroupByOutputType = {
    Name: string
    WinScore: number | null
    LoseScore: number | null
    _count: RankingDuelCountAggregateOutputType | null
    _avg: RankingDuelAvgAggregateOutputType | null
    _sum: RankingDuelSumAggregateOutputType | null
    _min: RankingDuelMinAggregateOutputType | null
    _max: RankingDuelMaxAggregateOutputType | null
  }

  type GetRankingDuelGroupByPayload<T extends RankingDuelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankingDuelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingDuelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingDuelGroupByOutputType[P]>
            : GetScalarType<T[P], RankingDuelGroupByOutputType[P]>
        }
      >
    >


  export type RankingDuelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    WinScore?: boolean
    LoseScore?: boolean
  }, ExtArgs["result"]["rankingDuel"]>

  export type RankingDuelSelectScalar = {
    Name?: boolean
    WinScore?: boolean
    LoseScore?: boolean
  }


  export type $RankingDuelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RankingDuel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      WinScore: number | null
      LoseScore: number | null
    }, ExtArgs["result"]["rankingDuel"]>
    composites: {}
  }


  type RankingDuelGetPayload<S extends boolean | null | undefined | RankingDuelDefaultArgs> = $Result.GetResult<Prisma.$RankingDuelPayload, S>

  type RankingDuelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RankingDuelFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RankingDuelCountAggregateInputType | true
    }

  export interface RankingDuelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RankingDuel'], meta: { name: 'RankingDuel' } }
    /**
     * Find zero or one RankingDuel that matches the filter.
     * @param {RankingDuelFindUniqueArgs} args - Arguments to find a RankingDuel
     * @example
     * // Get one RankingDuel
     * const rankingDuel = await prisma.rankingDuel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RankingDuelFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDuelFindUniqueArgs<ExtArgs>>
    ): Prisma__RankingDuelClient<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RankingDuel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RankingDuelFindUniqueOrThrowArgs} args - Arguments to find a RankingDuel
     * @example
     * // Get one RankingDuel
     * const rankingDuel = await prisma.rankingDuel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RankingDuelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDuelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RankingDuelClient<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RankingDuel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDuelFindFirstArgs} args - Arguments to find a RankingDuel
     * @example
     * // Get one RankingDuel
     * const rankingDuel = await prisma.rankingDuel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RankingDuelFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDuelFindFirstArgs<ExtArgs>>
    ): Prisma__RankingDuelClient<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RankingDuel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDuelFindFirstOrThrowArgs} args - Arguments to find a RankingDuel
     * @example
     * // Get one RankingDuel
     * const rankingDuel = await prisma.rankingDuel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RankingDuelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDuelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RankingDuelClient<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RankingDuels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDuelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RankingDuels
     * const rankingDuels = await prisma.rankingDuel.findMany()
     * 
     * // Get first 10 RankingDuels
     * const rankingDuels = await prisma.rankingDuel.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const rankingDuelWithNameOnly = await prisma.rankingDuel.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends RankingDuelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDuelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RankingDuel.
     * @param {RankingDuelCreateArgs} args - Arguments to create a RankingDuel.
     * @example
     * // Create one RankingDuel
     * const RankingDuel = await prisma.rankingDuel.create({
     *   data: {
     *     // ... data to create a RankingDuel
     *   }
     * })
     * 
    **/
    create<T extends RankingDuelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDuelCreateArgs<ExtArgs>>
    ): Prisma__RankingDuelClient<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RankingDuels.
     *     @param {RankingDuelCreateManyArgs} args - Arguments to create many RankingDuels.
     *     @example
     *     // Create many RankingDuels
     *     const rankingDuel = await prisma.rankingDuel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RankingDuelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDuelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RankingDuel.
     * @param {RankingDuelDeleteArgs} args - Arguments to delete one RankingDuel.
     * @example
     * // Delete one RankingDuel
     * const RankingDuel = await prisma.rankingDuel.delete({
     *   where: {
     *     // ... filter to delete one RankingDuel
     *   }
     * })
     * 
    **/
    delete<T extends RankingDuelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDuelDeleteArgs<ExtArgs>>
    ): Prisma__RankingDuelClient<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RankingDuel.
     * @param {RankingDuelUpdateArgs} args - Arguments to update one RankingDuel.
     * @example
     * // Update one RankingDuel
     * const rankingDuel = await prisma.rankingDuel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RankingDuelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDuelUpdateArgs<ExtArgs>>
    ): Prisma__RankingDuelClient<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RankingDuels.
     * @param {RankingDuelDeleteManyArgs} args - Arguments to filter RankingDuels to delete.
     * @example
     * // Delete a few RankingDuels
     * const { count } = await prisma.rankingDuel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RankingDuelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingDuelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RankingDuels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDuelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RankingDuels
     * const rankingDuel = await prisma.rankingDuel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RankingDuelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDuelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RankingDuel.
     * @param {RankingDuelUpsertArgs} args - Arguments to update or create a RankingDuel.
     * @example
     * // Update or create a RankingDuel
     * const rankingDuel = await prisma.rankingDuel.upsert({
     *   create: {
     *     // ... data to create a RankingDuel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RankingDuel we want to update
     *   }
     * })
    **/
    upsert<T extends RankingDuelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RankingDuelUpsertArgs<ExtArgs>>
    ): Prisma__RankingDuelClient<$Result.GetResult<Prisma.$RankingDuelPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RankingDuels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDuelCountArgs} args - Arguments to filter RankingDuels to count.
     * @example
     * // Count the number of RankingDuels
     * const count = await prisma.rankingDuel.count({
     *   where: {
     *     // ... the filter for the RankingDuels we want to count
     *   }
     * })
    **/
    count<T extends RankingDuelCountArgs>(
      args?: Subset<T, RankingDuelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingDuelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RankingDuel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDuelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingDuelAggregateArgs>(args: Subset<T, RankingDuelAggregateArgs>): Prisma.PrismaPromise<GetRankingDuelAggregateType<T>>

    /**
     * Group by RankingDuel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingDuelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankingDuelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankingDuelGroupByArgs['orderBy'] }
        : { orderBy?: RankingDuelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankingDuelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingDuelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RankingDuel model
   */
  readonly fields: RankingDuelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RankingDuel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankingDuelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RankingDuel model
   */ 
  interface RankingDuelFieldRefs {
    readonly Name: FieldRef<"RankingDuel", 'String'>
    readonly WinScore: FieldRef<"RankingDuel", 'Int'>
    readonly LoseScore: FieldRef<"RankingDuel", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RankingDuel findUnique
   */
  export type RankingDuelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * Filter, which RankingDuel to fetch.
     */
    where: RankingDuelWhereUniqueInput
  }


  /**
   * RankingDuel findUniqueOrThrow
   */
  export type RankingDuelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * Filter, which RankingDuel to fetch.
     */
    where: RankingDuelWhereUniqueInput
  }


  /**
   * RankingDuel findFirst
   */
  export type RankingDuelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * Filter, which RankingDuel to fetch.
     */
    where?: RankingDuelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingDuels to fetch.
     */
    orderBy?: RankingDuelOrderByWithRelationInput | RankingDuelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingDuels.
     */
    cursor?: RankingDuelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingDuels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingDuels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingDuels.
     */
    distinct?: RankingDuelScalarFieldEnum | RankingDuelScalarFieldEnum[]
  }


  /**
   * RankingDuel findFirstOrThrow
   */
  export type RankingDuelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * Filter, which RankingDuel to fetch.
     */
    where?: RankingDuelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingDuels to fetch.
     */
    orderBy?: RankingDuelOrderByWithRelationInput | RankingDuelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingDuels.
     */
    cursor?: RankingDuelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingDuels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingDuels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingDuels.
     */
    distinct?: RankingDuelScalarFieldEnum | RankingDuelScalarFieldEnum[]
  }


  /**
   * RankingDuel findMany
   */
  export type RankingDuelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * Filter, which RankingDuels to fetch.
     */
    where?: RankingDuelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingDuels to fetch.
     */
    orderBy?: RankingDuelOrderByWithRelationInput | RankingDuelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RankingDuels.
     */
    cursor?: RankingDuelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingDuels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingDuels.
     */
    skip?: number
    distinct?: RankingDuelScalarFieldEnum | RankingDuelScalarFieldEnum[]
  }


  /**
   * RankingDuel create
   */
  export type RankingDuelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * The data needed to create a RankingDuel.
     */
    data: XOR<RankingDuelCreateInput, RankingDuelUncheckedCreateInput>
  }


  /**
   * RankingDuel createMany
   */
  export type RankingDuelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RankingDuels.
     */
    data: RankingDuelCreateManyInput | RankingDuelCreateManyInput[]
  }


  /**
   * RankingDuel update
   */
  export type RankingDuelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * The data needed to update a RankingDuel.
     */
    data: XOR<RankingDuelUpdateInput, RankingDuelUncheckedUpdateInput>
    /**
     * Choose, which RankingDuel to update.
     */
    where: RankingDuelWhereUniqueInput
  }


  /**
   * RankingDuel updateMany
   */
  export type RankingDuelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RankingDuels.
     */
    data: XOR<RankingDuelUpdateManyMutationInput, RankingDuelUncheckedUpdateManyInput>
    /**
     * Filter which RankingDuels to update
     */
    where?: RankingDuelWhereInput
  }


  /**
   * RankingDuel upsert
   */
  export type RankingDuelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * The filter to search for the RankingDuel to update in case it exists.
     */
    where: RankingDuelWhereUniqueInput
    /**
     * In case the RankingDuel found by the `where` argument doesn't exist, create a new RankingDuel with this data.
     */
    create: XOR<RankingDuelCreateInput, RankingDuelUncheckedCreateInput>
    /**
     * In case the RankingDuel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankingDuelUpdateInput, RankingDuelUncheckedUpdateInput>
  }


  /**
   * RankingDuel delete
   */
  export type RankingDuelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
    /**
     * Filter which RankingDuel to delete.
     */
    where: RankingDuelWhereUniqueInput
  }


  /**
   * RankingDuel deleteMany
   */
  export type RankingDuelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingDuels to delete
     */
    where?: RankingDuelWhereInput
  }


  /**
   * RankingDuel without action
   */
  export type RankingDuelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingDuel
     */
    select?: RankingDuelSelect<ExtArgs> | null
  }



  /**
   * Model RankingIllusionTemple
   */

  export type AggregateRankingIllusionTemple = {
    _count: RankingIllusionTempleCountAggregateOutputType | null
    _avg: RankingIllusionTempleAvgAggregateOutputType | null
    _sum: RankingIllusionTempleSumAggregateOutputType | null
    _min: RankingIllusionTempleMinAggregateOutputType | null
    _max: RankingIllusionTempleMaxAggregateOutputType | null
  }

  export type RankingIllusionTempleAvgAggregateOutputType = {
    Score: number | null
  }

  export type RankingIllusionTempleSumAggregateOutputType = {
    Score: number | null
  }

  export type RankingIllusionTempleMinAggregateOutputType = {
    Name: string | null
    Score: number | null
  }

  export type RankingIllusionTempleMaxAggregateOutputType = {
    Name: string | null
    Score: number | null
  }

  export type RankingIllusionTempleCountAggregateOutputType = {
    Name: number
    Score: number
    _all: number
  }


  export type RankingIllusionTempleAvgAggregateInputType = {
    Score?: true
  }

  export type RankingIllusionTempleSumAggregateInputType = {
    Score?: true
  }

  export type RankingIllusionTempleMinAggregateInputType = {
    Name?: true
    Score?: true
  }

  export type RankingIllusionTempleMaxAggregateInputType = {
    Name?: true
    Score?: true
  }

  export type RankingIllusionTempleCountAggregateInputType = {
    Name?: true
    Score?: true
    _all?: true
  }

  export type RankingIllusionTempleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingIllusionTemple to aggregate.
     */
    where?: RankingIllusionTempleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingIllusionTemples to fetch.
     */
    orderBy?: RankingIllusionTempleOrderByWithRelationInput | RankingIllusionTempleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankingIllusionTempleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingIllusionTemples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingIllusionTemples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RankingIllusionTemples
    **/
    _count?: true | RankingIllusionTempleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankingIllusionTempleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankingIllusionTempleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingIllusionTempleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingIllusionTempleMaxAggregateInputType
  }

  export type GetRankingIllusionTempleAggregateType<T extends RankingIllusionTempleAggregateArgs> = {
        [P in keyof T & keyof AggregateRankingIllusionTemple]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRankingIllusionTemple[P]>
      : GetScalarType<T[P], AggregateRankingIllusionTemple[P]>
  }




  export type RankingIllusionTempleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankingIllusionTempleWhereInput
    orderBy?: RankingIllusionTempleOrderByWithAggregationInput | RankingIllusionTempleOrderByWithAggregationInput[]
    by: RankingIllusionTempleScalarFieldEnum[] | RankingIllusionTempleScalarFieldEnum
    having?: RankingIllusionTempleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingIllusionTempleCountAggregateInputType | true
    _avg?: RankingIllusionTempleAvgAggregateInputType
    _sum?: RankingIllusionTempleSumAggregateInputType
    _min?: RankingIllusionTempleMinAggregateInputType
    _max?: RankingIllusionTempleMaxAggregateInputType
  }

  export type RankingIllusionTempleGroupByOutputType = {
    Name: string
    Score: number | null
    _count: RankingIllusionTempleCountAggregateOutputType | null
    _avg: RankingIllusionTempleAvgAggregateOutputType | null
    _sum: RankingIllusionTempleSumAggregateOutputType | null
    _min: RankingIllusionTempleMinAggregateOutputType | null
    _max: RankingIllusionTempleMaxAggregateOutputType | null
  }

  type GetRankingIllusionTempleGroupByPayload<T extends RankingIllusionTempleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankingIllusionTempleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingIllusionTempleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingIllusionTempleGroupByOutputType[P]>
            : GetScalarType<T[P], RankingIllusionTempleGroupByOutputType[P]>
        }
      >
    >


  export type RankingIllusionTempleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Name?: boolean
    Score?: boolean
  }, ExtArgs["result"]["rankingIllusionTemple"]>

  export type RankingIllusionTempleSelectScalar = {
    Name?: boolean
    Score?: boolean
  }


  export type $RankingIllusionTemplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RankingIllusionTemple"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Name: string
      Score: number | null
    }, ExtArgs["result"]["rankingIllusionTemple"]>
    composites: {}
  }


  type RankingIllusionTempleGetPayload<S extends boolean | null | undefined | RankingIllusionTempleDefaultArgs> = $Result.GetResult<Prisma.$RankingIllusionTemplePayload, S>

  type RankingIllusionTempleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RankingIllusionTempleFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RankingIllusionTempleCountAggregateInputType | true
    }

  export interface RankingIllusionTempleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RankingIllusionTemple'], meta: { name: 'RankingIllusionTemple' } }
    /**
     * Find zero or one RankingIllusionTemple that matches the filter.
     * @param {RankingIllusionTempleFindUniqueArgs} args - Arguments to find a RankingIllusionTemple
     * @example
     * // Get one RankingIllusionTemple
     * const rankingIllusionTemple = await prisma.rankingIllusionTemple.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RankingIllusionTempleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RankingIllusionTempleFindUniqueArgs<ExtArgs>>
    ): Prisma__RankingIllusionTempleClient<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RankingIllusionTemple that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RankingIllusionTempleFindUniqueOrThrowArgs} args - Arguments to find a RankingIllusionTemple
     * @example
     * // Get one RankingIllusionTemple
     * const rankingIllusionTemple = await prisma.rankingIllusionTemple.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RankingIllusionTempleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingIllusionTempleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RankingIllusionTempleClient<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RankingIllusionTemple that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingIllusionTempleFindFirstArgs} args - Arguments to find a RankingIllusionTemple
     * @example
     * // Get one RankingIllusionTemple
     * const rankingIllusionTemple = await prisma.rankingIllusionTemple.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RankingIllusionTempleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingIllusionTempleFindFirstArgs<ExtArgs>>
    ): Prisma__RankingIllusionTempleClient<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RankingIllusionTemple that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingIllusionTempleFindFirstOrThrowArgs} args - Arguments to find a RankingIllusionTemple
     * @example
     * // Get one RankingIllusionTemple
     * const rankingIllusionTemple = await prisma.rankingIllusionTemple.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RankingIllusionTempleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingIllusionTempleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RankingIllusionTempleClient<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RankingIllusionTemples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingIllusionTempleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RankingIllusionTemples
     * const rankingIllusionTemples = await prisma.rankingIllusionTemple.findMany()
     * 
     * // Get first 10 RankingIllusionTemples
     * const rankingIllusionTemples = await prisma.rankingIllusionTemple.findMany({ take: 10 })
     * 
     * // Only select the `Name`
     * const rankingIllusionTempleWithNameOnly = await prisma.rankingIllusionTemple.findMany({ select: { Name: true } })
     * 
    **/
    findMany<T extends RankingIllusionTempleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingIllusionTempleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RankingIllusionTemple.
     * @param {RankingIllusionTempleCreateArgs} args - Arguments to create a RankingIllusionTemple.
     * @example
     * // Create one RankingIllusionTemple
     * const RankingIllusionTemple = await prisma.rankingIllusionTemple.create({
     *   data: {
     *     // ... data to create a RankingIllusionTemple
     *   }
     * })
     * 
    **/
    create<T extends RankingIllusionTempleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingIllusionTempleCreateArgs<ExtArgs>>
    ): Prisma__RankingIllusionTempleClient<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RankingIllusionTemples.
     *     @param {RankingIllusionTempleCreateManyArgs} args - Arguments to create many RankingIllusionTemples.
     *     @example
     *     // Create many RankingIllusionTemples
     *     const rankingIllusionTemple = await prisma.rankingIllusionTemple.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RankingIllusionTempleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingIllusionTempleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RankingIllusionTemple.
     * @param {RankingIllusionTempleDeleteArgs} args - Arguments to delete one RankingIllusionTemple.
     * @example
     * // Delete one RankingIllusionTemple
     * const RankingIllusionTemple = await prisma.rankingIllusionTemple.delete({
     *   where: {
     *     // ... filter to delete one RankingIllusionTemple
     *   }
     * })
     * 
    **/
    delete<T extends RankingIllusionTempleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RankingIllusionTempleDeleteArgs<ExtArgs>>
    ): Prisma__RankingIllusionTempleClient<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RankingIllusionTemple.
     * @param {RankingIllusionTempleUpdateArgs} args - Arguments to update one RankingIllusionTemple.
     * @example
     * // Update one RankingIllusionTemple
     * const rankingIllusionTemple = await prisma.rankingIllusionTemple.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RankingIllusionTempleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RankingIllusionTempleUpdateArgs<ExtArgs>>
    ): Prisma__RankingIllusionTempleClient<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RankingIllusionTemples.
     * @param {RankingIllusionTempleDeleteManyArgs} args - Arguments to filter RankingIllusionTemples to delete.
     * @example
     * // Delete a few RankingIllusionTemples
     * const { count } = await prisma.rankingIllusionTemple.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RankingIllusionTempleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RankingIllusionTempleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RankingIllusionTemples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingIllusionTempleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RankingIllusionTemples
     * const rankingIllusionTemple = await prisma.rankingIllusionTemple.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RankingIllusionTempleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RankingIllusionTempleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RankingIllusionTemple.
     * @param {RankingIllusionTempleUpsertArgs} args - Arguments to update or create a RankingIllusionTemple.
     * @example
     * // Update or create a RankingIllusionTemple
     * const rankingIllusionTemple = await prisma.rankingIllusionTemple.upsert({
     *   create: {
     *     // ... data to create a RankingIllusionTemple
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RankingIllusionTemple we want to update
     *   }
     * })
    **/
    upsert<T extends RankingIllusionTempleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RankingIllusionTempleUpsertArgs<ExtArgs>>
    ): Prisma__RankingIllusionTempleClient<$Result.GetResult<Prisma.$RankingIllusionTemplePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RankingIllusionTemples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingIllusionTempleCountArgs} args - Arguments to filter RankingIllusionTemples to count.
     * @example
     * // Count the number of RankingIllusionTemples
     * const count = await prisma.rankingIllusionTemple.count({
     *   where: {
     *     // ... the filter for the RankingIllusionTemples we want to count
     *   }
     * })
    **/
    count<T extends RankingIllusionTempleCountArgs>(
      args?: Subset<T, RankingIllusionTempleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingIllusionTempleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RankingIllusionTemple.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingIllusionTempleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingIllusionTempleAggregateArgs>(args: Subset<T, RankingIllusionTempleAggregateArgs>): Prisma.PrismaPromise<GetRankingIllusionTempleAggregateType<T>>

    /**
     * Group by RankingIllusionTemple.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingIllusionTempleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankingIllusionTempleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankingIllusionTempleGroupByArgs['orderBy'] }
        : { orderBy?: RankingIllusionTempleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankingIllusionTempleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingIllusionTempleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RankingIllusionTemple model
   */
  readonly fields: RankingIllusionTempleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RankingIllusionTemple.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankingIllusionTempleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RankingIllusionTemple model
   */ 
  interface RankingIllusionTempleFieldRefs {
    readonly Name: FieldRef<"RankingIllusionTemple", 'String'>
    readonly Score: FieldRef<"RankingIllusionTemple", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RankingIllusionTemple findUnique
   */
  export type RankingIllusionTempleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * Filter, which RankingIllusionTemple to fetch.
     */
    where: RankingIllusionTempleWhereUniqueInput
  }


  /**
   * RankingIllusionTemple findUniqueOrThrow
   */
  export type RankingIllusionTempleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * Filter, which RankingIllusionTemple to fetch.
     */
    where: RankingIllusionTempleWhereUniqueInput
  }


  /**
   * RankingIllusionTemple findFirst
   */
  export type RankingIllusionTempleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * Filter, which RankingIllusionTemple to fetch.
     */
    where?: RankingIllusionTempleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingIllusionTemples to fetch.
     */
    orderBy?: RankingIllusionTempleOrderByWithRelationInput | RankingIllusionTempleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingIllusionTemples.
     */
    cursor?: RankingIllusionTempleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingIllusionTemples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingIllusionTemples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingIllusionTemples.
     */
    distinct?: RankingIllusionTempleScalarFieldEnum | RankingIllusionTempleScalarFieldEnum[]
  }


  /**
   * RankingIllusionTemple findFirstOrThrow
   */
  export type RankingIllusionTempleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * Filter, which RankingIllusionTemple to fetch.
     */
    where?: RankingIllusionTempleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingIllusionTemples to fetch.
     */
    orderBy?: RankingIllusionTempleOrderByWithRelationInput | RankingIllusionTempleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankingIllusionTemples.
     */
    cursor?: RankingIllusionTempleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingIllusionTemples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingIllusionTemples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankingIllusionTemples.
     */
    distinct?: RankingIllusionTempleScalarFieldEnum | RankingIllusionTempleScalarFieldEnum[]
  }


  /**
   * RankingIllusionTemple findMany
   */
  export type RankingIllusionTempleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * Filter, which RankingIllusionTemples to fetch.
     */
    where?: RankingIllusionTempleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankingIllusionTemples to fetch.
     */
    orderBy?: RankingIllusionTempleOrderByWithRelationInput | RankingIllusionTempleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RankingIllusionTemples.
     */
    cursor?: RankingIllusionTempleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankingIllusionTemples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankingIllusionTemples.
     */
    skip?: number
    distinct?: RankingIllusionTempleScalarFieldEnum | RankingIllusionTempleScalarFieldEnum[]
  }


  /**
   * RankingIllusionTemple create
   */
  export type RankingIllusionTempleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * The data needed to create a RankingIllusionTemple.
     */
    data: XOR<RankingIllusionTempleCreateInput, RankingIllusionTempleUncheckedCreateInput>
  }


  /**
   * RankingIllusionTemple createMany
   */
  export type RankingIllusionTempleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RankingIllusionTemples.
     */
    data: RankingIllusionTempleCreateManyInput | RankingIllusionTempleCreateManyInput[]
  }


  /**
   * RankingIllusionTemple update
   */
  export type RankingIllusionTempleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * The data needed to update a RankingIllusionTemple.
     */
    data: XOR<RankingIllusionTempleUpdateInput, RankingIllusionTempleUncheckedUpdateInput>
    /**
     * Choose, which RankingIllusionTemple to update.
     */
    where: RankingIllusionTempleWhereUniqueInput
  }


  /**
   * RankingIllusionTemple updateMany
   */
  export type RankingIllusionTempleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RankingIllusionTemples.
     */
    data: XOR<RankingIllusionTempleUpdateManyMutationInput, RankingIllusionTempleUncheckedUpdateManyInput>
    /**
     * Filter which RankingIllusionTemples to update
     */
    where?: RankingIllusionTempleWhereInput
  }


  /**
   * RankingIllusionTemple upsert
   */
  export type RankingIllusionTempleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * The filter to search for the RankingIllusionTemple to update in case it exists.
     */
    where: RankingIllusionTempleWhereUniqueInput
    /**
     * In case the RankingIllusionTemple found by the `where` argument doesn't exist, create a new RankingIllusionTemple with this data.
     */
    create: XOR<RankingIllusionTempleCreateInput, RankingIllusionTempleUncheckedCreateInput>
    /**
     * In case the RankingIllusionTemple was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankingIllusionTempleUpdateInput, RankingIllusionTempleUncheckedUpdateInput>
  }


  /**
   * RankingIllusionTemple delete
   */
  export type RankingIllusionTempleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
    /**
     * Filter which RankingIllusionTemple to delete.
     */
    where: RankingIllusionTempleWhereUniqueInput
  }


  /**
   * RankingIllusionTemple deleteMany
   */
  export type RankingIllusionTempleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankingIllusionTemples to delete
     */
    where?: RankingIllusionTempleWhereInput
  }


  /**
   * RankingIllusionTemple without action
   */
  export type RankingIllusionTempleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankingIllusionTemple
     */
    select?: RankingIllusionTempleSelect<ExtArgs> | null
  }



  /**
   * Model T_CGuid
   */

  export type AggregateT_CGuid = {
    _count: T_CGuidCountAggregateOutputType | null
    _avg: T_CGuidAvgAggregateOutputType | null
    _sum: T_CGuidSumAggregateOutputType | null
    _min: T_CGuidMinAggregateOutputType | null
    _max: T_CGuidMaxAggregateOutputType | null
  }

  export type T_CGuidAvgAggregateOutputType = {
    GUID: number | null
  }

  export type T_CGuidSumAggregateOutputType = {
    GUID: number | null
  }

  export type T_CGuidMinAggregateOutputType = {
    GUID: number | null
    Name: string | null
  }

  export type T_CGuidMaxAggregateOutputType = {
    GUID: number | null
    Name: string | null
  }

  export type T_CGuidCountAggregateOutputType = {
    GUID: number
    Name: number
    _all: number
  }


  export type T_CGuidAvgAggregateInputType = {
    GUID?: true
  }

  export type T_CGuidSumAggregateInputType = {
    GUID?: true
  }

  export type T_CGuidMinAggregateInputType = {
    GUID?: true
    Name?: true
  }

  export type T_CGuidMaxAggregateInputType = {
    GUID?: true
    Name?: true
  }

  export type T_CGuidCountAggregateInputType = {
    GUID?: true
    Name?: true
    _all?: true
  }

  export type T_CGuidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which T_CGuid to aggregate.
     */
    where?: T_CGuidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_CGuids to fetch.
     */
    orderBy?: T_CGuidOrderByWithRelationInput | T_CGuidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: T_CGuidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_CGuids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_CGuids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned T_CGuids
    **/
    _count?: true | T_CGuidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: T_CGuidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: T_CGuidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_CGuidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_CGuidMaxAggregateInputType
  }

  export type GetT_CGuidAggregateType<T extends T_CGuidAggregateArgs> = {
        [P in keyof T & keyof AggregateT_CGuid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_CGuid[P]>
      : GetScalarType<T[P], AggregateT_CGuid[P]>
  }




  export type T_CGuidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: T_CGuidWhereInput
    orderBy?: T_CGuidOrderByWithAggregationInput | T_CGuidOrderByWithAggregationInput[]
    by: T_CGuidScalarFieldEnum[] | T_CGuidScalarFieldEnum
    having?: T_CGuidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_CGuidCountAggregateInputType | true
    _avg?: T_CGuidAvgAggregateInputType
    _sum?: T_CGuidSumAggregateInputType
    _min?: T_CGuidMinAggregateInputType
    _max?: T_CGuidMaxAggregateInputType
  }

  export type T_CGuidGroupByOutputType = {
    GUID: number
    Name: string
    _count: T_CGuidCountAggregateOutputType | null
    _avg: T_CGuidAvgAggregateOutputType | null
    _sum: T_CGuidSumAggregateOutputType | null
    _min: T_CGuidMinAggregateOutputType | null
    _max: T_CGuidMaxAggregateOutputType | null
  }

  type GetT_CGuidGroupByPayload<T extends T_CGuidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_CGuidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_CGuidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_CGuidGroupByOutputType[P]>
            : GetScalarType<T[P], T_CGuidGroupByOutputType[P]>
        }
      >
    >


  export type T_CGuidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    GUID?: boolean
    Name?: boolean
  }, ExtArgs["result"]["t_CGuid"]>

  export type T_CGuidSelectScalar = {
    GUID?: boolean
    Name?: boolean
  }


  export type $T_CGuidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "T_CGuid"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      GUID: number
      Name: string
    }, ExtArgs["result"]["t_CGuid"]>
    composites: {}
  }


  type T_CGuidGetPayload<S extends boolean | null | undefined | T_CGuidDefaultArgs> = $Result.GetResult<Prisma.$T_CGuidPayload, S>

  type T_CGuidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<T_CGuidFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: T_CGuidCountAggregateInputType | true
    }

  export interface T_CGuidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['T_CGuid'], meta: { name: 'T_CGuid' } }
    /**
     * Find zero or one T_CGuid that matches the filter.
     * @param {T_CGuidFindUniqueArgs} args - Arguments to find a T_CGuid
     * @example
     * // Get one T_CGuid
     * const t_CGuid = await prisma.t_CGuid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends T_CGuidFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, T_CGuidFindUniqueArgs<ExtArgs>>
    ): Prisma__T_CGuidClient<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one T_CGuid that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {T_CGuidFindUniqueOrThrowArgs} args - Arguments to find a T_CGuid
     * @example
     * // Get one T_CGuid
     * const t_CGuid = await prisma.t_CGuid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends T_CGuidFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, T_CGuidFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__T_CGuidClient<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first T_CGuid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_CGuidFindFirstArgs} args - Arguments to find a T_CGuid
     * @example
     * // Get one T_CGuid
     * const t_CGuid = await prisma.t_CGuid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends T_CGuidFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, T_CGuidFindFirstArgs<ExtArgs>>
    ): Prisma__T_CGuidClient<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first T_CGuid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_CGuidFindFirstOrThrowArgs} args - Arguments to find a T_CGuid
     * @example
     * // Get one T_CGuid
     * const t_CGuid = await prisma.t_CGuid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends T_CGuidFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, T_CGuidFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__T_CGuidClient<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more T_CGuids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_CGuidFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_CGuids
     * const t_CGuids = await prisma.t_CGuid.findMany()
     * 
     * // Get first 10 T_CGuids
     * const t_CGuids = await prisma.t_CGuid.findMany({ take: 10 })
     * 
     * // Only select the `GUID`
     * const t_CGuidWithGUIDOnly = await prisma.t_CGuid.findMany({ select: { GUID: true } })
     * 
    **/
    findMany<T extends T_CGuidFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_CGuidFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a T_CGuid.
     * @param {T_CGuidCreateArgs} args - Arguments to create a T_CGuid.
     * @example
     * // Create one T_CGuid
     * const T_CGuid = await prisma.t_CGuid.create({
     *   data: {
     *     // ... data to create a T_CGuid
     *   }
     * })
     * 
    **/
    create<T extends T_CGuidCreateArgs<ExtArgs>>(
      args: SelectSubset<T, T_CGuidCreateArgs<ExtArgs>>
    ): Prisma__T_CGuidClient<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many T_CGuids.
     *     @param {T_CGuidCreateManyArgs} args - Arguments to create many T_CGuids.
     *     @example
     *     // Create many T_CGuids
     *     const t_CGuid = await prisma.t_CGuid.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends T_CGuidCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_CGuidCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a T_CGuid.
     * @param {T_CGuidDeleteArgs} args - Arguments to delete one T_CGuid.
     * @example
     * // Delete one T_CGuid
     * const T_CGuid = await prisma.t_CGuid.delete({
     *   where: {
     *     // ... filter to delete one T_CGuid
     *   }
     * })
     * 
    **/
    delete<T extends T_CGuidDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, T_CGuidDeleteArgs<ExtArgs>>
    ): Prisma__T_CGuidClient<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one T_CGuid.
     * @param {T_CGuidUpdateArgs} args - Arguments to update one T_CGuid.
     * @example
     * // Update one T_CGuid
     * const t_CGuid = await prisma.t_CGuid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends T_CGuidUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, T_CGuidUpdateArgs<ExtArgs>>
    ): Prisma__T_CGuidClient<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more T_CGuids.
     * @param {T_CGuidDeleteManyArgs} args - Arguments to filter T_CGuids to delete.
     * @example
     * // Delete a few T_CGuids
     * const { count } = await prisma.t_CGuid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends T_CGuidDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_CGuidDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_CGuids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_CGuidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_CGuids
     * const t_CGuid = await prisma.t_CGuid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends T_CGuidUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, T_CGuidUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one T_CGuid.
     * @param {T_CGuidUpsertArgs} args - Arguments to update or create a T_CGuid.
     * @example
     * // Update or create a T_CGuid
     * const t_CGuid = await prisma.t_CGuid.upsert({
     *   create: {
     *     // ... data to create a T_CGuid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_CGuid we want to update
     *   }
     * })
    **/
    upsert<T extends T_CGuidUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, T_CGuidUpsertArgs<ExtArgs>>
    ): Prisma__T_CGuidClient<$Result.GetResult<Prisma.$T_CGuidPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of T_CGuids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_CGuidCountArgs} args - Arguments to filter T_CGuids to count.
     * @example
     * // Count the number of T_CGuids
     * const count = await prisma.t_CGuid.count({
     *   where: {
     *     // ... the filter for the T_CGuids we want to count
     *   }
     * })
    **/
    count<T extends T_CGuidCountArgs>(
      args?: Subset<T, T_CGuidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_CGuidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_CGuid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_CGuidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_CGuidAggregateArgs>(args: Subset<T, T_CGuidAggregateArgs>): Prisma.PrismaPromise<GetT_CGuidAggregateType<T>>

    /**
     * Group by T_CGuid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_CGuidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends T_CGuidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: T_CGuidGroupByArgs['orderBy'] }
        : { orderBy?: T_CGuidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, T_CGuidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_CGuidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the T_CGuid model
   */
  readonly fields: T_CGuidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for T_CGuid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__T_CGuidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the T_CGuid model
   */ 
  interface T_CGuidFieldRefs {
    readonly GUID: FieldRef<"T_CGuid", 'Int'>
    readonly Name: FieldRef<"T_CGuid", 'String'>
  }
    

  // Custom InputTypes

  /**
   * T_CGuid findUnique
   */
  export type T_CGuidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * Filter, which T_CGuid to fetch.
     */
    where: T_CGuidWhereUniqueInput
  }


  /**
   * T_CGuid findUniqueOrThrow
   */
  export type T_CGuidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * Filter, which T_CGuid to fetch.
     */
    where: T_CGuidWhereUniqueInput
  }


  /**
   * T_CGuid findFirst
   */
  export type T_CGuidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * Filter, which T_CGuid to fetch.
     */
    where?: T_CGuidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_CGuids to fetch.
     */
    orderBy?: T_CGuidOrderByWithRelationInput | T_CGuidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for T_CGuids.
     */
    cursor?: T_CGuidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_CGuids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_CGuids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of T_CGuids.
     */
    distinct?: T_CGuidScalarFieldEnum | T_CGuidScalarFieldEnum[]
  }


  /**
   * T_CGuid findFirstOrThrow
   */
  export type T_CGuidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * Filter, which T_CGuid to fetch.
     */
    where?: T_CGuidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_CGuids to fetch.
     */
    orderBy?: T_CGuidOrderByWithRelationInput | T_CGuidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for T_CGuids.
     */
    cursor?: T_CGuidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_CGuids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_CGuids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of T_CGuids.
     */
    distinct?: T_CGuidScalarFieldEnum | T_CGuidScalarFieldEnum[]
  }


  /**
   * T_CGuid findMany
   */
  export type T_CGuidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * Filter, which T_CGuids to fetch.
     */
    where?: T_CGuidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_CGuids to fetch.
     */
    orderBy?: T_CGuidOrderByWithRelationInput | T_CGuidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing T_CGuids.
     */
    cursor?: T_CGuidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_CGuids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_CGuids.
     */
    skip?: number
    distinct?: T_CGuidScalarFieldEnum | T_CGuidScalarFieldEnum[]
  }


  /**
   * T_CGuid create
   */
  export type T_CGuidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * The data needed to create a T_CGuid.
     */
    data: XOR<T_CGuidCreateInput, T_CGuidUncheckedCreateInput>
  }


  /**
   * T_CGuid createMany
   */
  export type T_CGuidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many T_CGuids.
     */
    data: T_CGuidCreateManyInput | T_CGuidCreateManyInput[]
  }


  /**
   * T_CGuid update
   */
  export type T_CGuidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * The data needed to update a T_CGuid.
     */
    data: XOR<T_CGuidUpdateInput, T_CGuidUncheckedUpdateInput>
    /**
     * Choose, which T_CGuid to update.
     */
    where: T_CGuidWhereUniqueInput
  }


  /**
   * T_CGuid updateMany
   */
  export type T_CGuidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update T_CGuids.
     */
    data: XOR<T_CGuidUpdateManyMutationInput, T_CGuidUncheckedUpdateManyInput>
    /**
     * Filter which T_CGuids to update
     */
    where?: T_CGuidWhereInput
  }


  /**
   * T_CGuid upsert
   */
  export type T_CGuidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * The filter to search for the T_CGuid to update in case it exists.
     */
    where: T_CGuidWhereUniqueInput
    /**
     * In case the T_CGuid found by the `where` argument doesn't exist, create a new T_CGuid with this data.
     */
    create: XOR<T_CGuidCreateInput, T_CGuidUncheckedCreateInput>
    /**
     * In case the T_CGuid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<T_CGuidUpdateInput, T_CGuidUncheckedUpdateInput>
  }


  /**
   * T_CGuid delete
   */
  export type T_CGuidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
    /**
     * Filter which T_CGuid to delete.
     */
    where: T_CGuidWhereUniqueInput
  }


  /**
   * T_CGuid deleteMany
   */
  export type T_CGuidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which T_CGuids to delete
     */
    where?: T_CGuidWhereInput
  }


  /**
   * T_CGuid without action
   */
  export type T_CGuidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_CGuid
     */
    select?: T_CGuidSelect<ExtArgs> | null
  }



  /**
   * Model T_FriendMail
   */

  export type AggregateT_FriendMail = {
    _count: T_FriendMailCountAggregateOutputType | null
    _avg: T_FriendMailAvgAggregateOutputType | null
    _sum: T_FriendMailSumAggregateOutputType | null
    _min: T_FriendMailMinAggregateOutputType | null
    _max: T_FriendMailMaxAggregateOutputType | null
  }

  export type T_FriendMailAvgAggregateOutputType = {
    MemoIndex: number | null
    GUID: number | null
    Dir: number | null
    Act: number | null
  }

  export type T_FriendMailSumAggregateOutputType = {
    MemoIndex: number | null
    GUID: number | null
    Dir: number | null
    Act: number | null
  }

  export type T_FriendMailMinAggregateOutputType = {
    MemoIndex: number | null
    GUID: number | null
    FriendName: string | null
    wDate: Date | null
    Subject: string | null
    bRead: boolean | null
    Memo: Buffer | null
    Photo: Buffer | null
    Dir: number | null
    Act: number | null
  }

  export type T_FriendMailMaxAggregateOutputType = {
    MemoIndex: number | null
    GUID: number | null
    FriendName: string | null
    wDate: Date | null
    Subject: string | null
    bRead: boolean | null
    Memo: Buffer | null
    Photo: Buffer | null
    Dir: number | null
    Act: number | null
  }

  export type T_FriendMailCountAggregateOutputType = {
    MemoIndex: number
    GUID: number
    FriendName: number
    wDate: number
    Subject: number
    bRead: number
    Memo: number
    Photo: number
    Dir: number
    Act: number
    _all: number
  }


  export type T_FriendMailAvgAggregateInputType = {
    MemoIndex?: true
    GUID?: true
    Dir?: true
    Act?: true
  }

  export type T_FriendMailSumAggregateInputType = {
    MemoIndex?: true
    GUID?: true
    Dir?: true
    Act?: true
  }

  export type T_FriendMailMinAggregateInputType = {
    MemoIndex?: true
    GUID?: true
    FriendName?: true
    wDate?: true
    Subject?: true
    bRead?: true
    Memo?: true
    Photo?: true
    Dir?: true
    Act?: true
  }

  export type T_FriendMailMaxAggregateInputType = {
    MemoIndex?: true
    GUID?: true
    FriendName?: true
    wDate?: true
    Subject?: true
    bRead?: true
    Memo?: true
    Photo?: true
    Dir?: true
    Act?: true
  }

  export type T_FriendMailCountAggregateInputType = {
    MemoIndex?: true
    GUID?: true
    FriendName?: true
    wDate?: true
    Subject?: true
    bRead?: true
    Memo?: true
    Photo?: true
    Dir?: true
    Act?: true
    _all?: true
  }

  export type T_FriendMailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which T_FriendMail to aggregate.
     */
    where?: T_FriendMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_FriendMails to fetch.
     */
    orderBy?: T_FriendMailOrderByWithRelationInput | T_FriendMailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: T_FriendMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_FriendMails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_FriendMails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned T_FriendMails
    **/
    _count?: true | T_FriendMailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: T_FriendMailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: T_FriendMailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_FriendMailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_FriendMailMaxAggregateInputType
  }

  export type GetT_FriendMailAggregateType<T extends T_FriendMailAggregateArgs> = {
        [P in keyof T & keyof AggregateT_FriendMail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_FriendMail[P]>
      : GetScalarType<T[P], AggregateT_FriendMail[P]>
  }




  export type T_FriendMailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: T_FriendMailWhereInput
    orderBy?: T_FriendMailOrderByWithAggregationInput | T_FriendMailOrderByWithAggregationInput[]
    by: T_FriendMailScalarFieldEnum[] | T_FriendMailScalarFieldEnum
    having?: T_FriendMailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_FriendMailCountAggregateInputType | true
    _avg?: T_FriendMailAvgAggregateInputType
    _sum?: T_FriendMailSumAggregateInputType
    _min?: T_FriendMailMinAggregateInputType
    _max?: T_FriendMailMaxAggregateInputType
  }

  export type T_FriendMailGroupByOutputType = {
    MemoIndex: number
    GUID: number
    FriendName: string | null
    wDate: Date
    Subject: string | null
    bRead: boolean
    Memo: Buffer | null
    Photo: Buffer | null
    Dir: number | null
    Act: number | null
    _count: T_FriendMailCountAggregateOutputType | null
    _avg: T_FriendMailAvgAggregateOutputType | null
    _sum: T_FriendMailSumAggregateOutputType | null
    _min: T_FriendMailMinAggregateOutputType | null
    _max: T_FriendMailMaxAggregateOutputType | null
  }

  type GetT_FriendMailGroupByPayload<T extends T_FriendMailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_FriendMailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_FriendMailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_FriendMailGroupByOutputType[P]>
            : GetScalarType<T[P], T_FriendMailGroupByOutputType[P]>
        }
      >
    >


  export type T_FriendMailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MemoIndex?: boolean
    GUID?: boolean
    FriendName?: boolean
    wDate?: boolean
    Subject?: boolean
    bRead?: boolean
    Memo?: boolean
    Photo?: boolean
    Dir?: boolean
    Act?: boolean
  }, ExtArgs["result"]["t_FriendMail"]>

  export type T_FriendMailSelectScalar = {
    MemoIndex?: boolean
    GUID?: boolean
    FriendName?: boolean
    wDate?: boolean
    Subject?: boolean
    bRead?: boolean
    Memo?: boolean
    Photo?: boolean
    Dir?: boolean
    Act?: boolean
  }


  export type $T_FriendMailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "T_FriendMail"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      MemoIndex: number
      GUID: number
      FriendName: string | null
      wDate: Date
      Subject: string | null
      bRead: boolean
      Memo: Buffer | null
      Photo: Buffer | null
      Dir: number | null
      Act: number | null
    }, ExtArgs["result"]["t_FriendMail"]>
    composites: {}
  }


  type T_FriendMailGetPayload<S extends boolean | null | undefined | T_FriendMailDefaultArgs> = $Result.GetResult<Prisma.$T_FriendMailPayload, S>

  type T_FriendMailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<T_FriendMailFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: T_FriendMailCountAggregateInputType | true
    }

  export interface T_FriendMailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['T_FriendMail'], meta: { name: 'T_FriendMail' } }
    /**
     * Find zero or one T_FriendMail that matches the filter.
     * @param {T_FriendMailFindUniqueArgs} args - Arguments to find a T_FriendMail
     * @example
     * // Get one T_FriendMail
     * const t_FriendMail = await prisma.t_FriendMail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends T_FriendMailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMailFindUniqueArgs<ExtArgs>>
    ): Prisma__T_FriendMailClient<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one T_FriendMail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {T_FriendMailFindUniqueOrThrowArgs} args - Arguments to find a T_FriendMail
     * @example
     * // Get one T_FriendMail
     * const t_FriendMail = await prisma.t_FriendMail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends T_FriendMailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__T_FriendMailClient<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first T_FriendMail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMailFindFirstArgs} args - Arguments to find a T_FriendMail
     * @example
     * // Get one T_FriendMail
     * const t_FriendMail = await prisma.t_FriendMail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends T_FriendMailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMailFindFirstArgs<ExtArgs>>
    ): Prisma__T_FriendMailClient<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first T_FriendMail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMailFindFirstOrThrowArgs} args - Arguments to find a T_FriendMail
     * @example
     * // Get one T_FriendMail
     * const t_FriendMail = await prisma.t_FriendMail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends T_FriendMailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__T_FriendMailClient<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more T_FriendMails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_FriendMails
     * const t_FriendMails = await prisma.t_FriendMail.findMany()
     * 
     * // Get first 10 T_FriendMails
     * const t_FriendMails = await prisma.t_FriendMail.findMany({ take: 10 })
     * 
     * // Only select the `MemoIndex`
     * const t_FriendMailWithMemoIndexOnly = await prisma.t_FriendMail.findMany({ select: { MemoIndex: true } })
     * 
    **/
    findMany<T extends T_FriendMailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a T_FriendMail.
     * @param {T_FriendMailCreateArgs} args - Arguments to create a T_FriendMail.
     * @example
     * // Create one T_FriendMail
     * const T_FriendMail = await prisma.t_FriendMail.create({
     *   data: {
     *     // ... data to create a T_FriendMail
     *   }
     * })
     * 
    **/
    create<T extends T_FriendMailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMailCreateArgs<ExtArgs>>
    ): Prisma__T_FriendMailClient<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many T_FriendMails.
     *     @param {T_FriendMailCreateManyArgs} args - Arguments to create many T_FriendMails.
     *     @example
     *     // Create many T_FriendMails
     *     const t_FriendMail = await prisma.t_FriendMail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends T_FriendMailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a T_FriendMail.
     * @param {T_FriendMailDeleteArgs} args - Arguments to delete one T_FriendMail.
     * @example
     * // Delete one T_FriendMail
     * const T_FriendMail = await prisma.t_FriendMail.delete({
     *   where: {
     *     // ... filter to delete one T_FriendMail
     *   }
     * })
     * 
    **/
    delete<T extends T_FriendMailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMailDeleteArgs<ExtArgs>>
    ): Prisma__T_FriendMailClient<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one T_FriendMail.
     * @param {T_FriendMailUpdateArgs} args - Arguments to update one T_FriendMail.
     * @example
     * // Update one T_FriendMail
     * const t_FriendMail = await prisma.t_FriendMail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends T_FriendMailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMailUpdateArgs<ExtArgs>>
    ): Prisma__T_FriendMailClient<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more T_FriendMails.
     * @param {T_FriendMailDeleteManyArgs} args - Arguments to filter T_FriendMails to delete.
     * @example
     * // Delete a few T_FriendMails
     * const { count } = await prisma.t_FriendMail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends T_FriendMailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_FriendMails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_FriendMails
     * const t_FriendMail = await prisma.t_FriendMail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends T_FriendMailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one T_FriendMail.
     * @param {T_FriendMailUpsertArgs} args - Arguments to update or create a T_FriendMail.
     * @example
     * // Update or create a T_FriendMail
     * const t_FriendMail = await prisma.t_FriendMail.upsert({
     *   create: {
     *     // ... data to create a T_FriendMail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_FriendMail we want to update
     *   }
     * })
    **/
    upsert<T extends T_FriendMailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMailUpsertArgs<ExtArgs>>
    ): Prisma__T_FriendMailClient<$Result.GetResult<Prisma.$T_FriendMailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of T_FriendMails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMailCountArgs} args - Arguments to filter T_FriendMails to count.
     * @example
     * // Count the number of T_FriendMails
     * const count = await prisma.t_FriendMail.count({
     *   where: {
     *     // ... the filter for the T_FriendMails we want to count
     *   }
     * })
    **/
    count<T extends T_FriendMailCountArgs>(
      args?: Subset<T, T_FriendMailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_FriendMailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_FriendMail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_FriendMailAggregateArgs>(args: Subset<T, T_FriendMailAggregateArgs>): Prisma.PrismaPromise<GetT_FriendMailAggregateType<T>>

    /**
     * Group by T_FriendMail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends T_FriendMailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: T_FriendMailGroupByArgs['orderBy'] }
        : { orderBy?: T_FriendMailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, T_FriendMailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_FriendMailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the T_FriendMail model
   */
  readonly fields: T_FriendMailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for T_FriendMail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__T_FriendMailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the T_FriendMail model
   */ 
  interface T_FriendMailFieldRefs {
    readonly MemoIndex: FieldRef<"T_FriendMail", 'Int'>
    readonly GUID: FieldRef<"T_FriendMail", 'Int'>
    readonly FriendName: FieldRef<"T_FriendMail", 'String'>
    readonly wDate: FieldRef<"T_FriendMail", 'DateTime'>
    readonly Subject: FieldRef<"T_FriendMail", 'String'>
    readonly bRead: FieldRef<"T_FriendMail", 'Boolean'>
    readonly Memo: FieldRef<"T_FriendMail", 'Bytes'>
    readonly Photo: FieldRef<"T_FriendMail", 'Bytes'>
    readonly Dir: FieldRef<"T_FriendMail", 'Int'>
    readonly Act: FieldRef<"T_FriendMail", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * T_FriendMail findUnique
   */
  export type T_FriendMailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMail to fetch.
     */
    where: T_FriendMailWhereUniqueInput
  }


  /**
   * T_FriendMail findUniqueOrThrow
   */
  export type T_FriendMailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMail to fetch.
     */
    where: T_FriendMailWhereUniqueInput
  }


  /**
   * T_FriendMail findFirst
   */
  export type T_FriendMailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMail to fetch.
     */
    where?: T_FriendMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_FriendMails to fetch.
     */
    orderBy?: T_FriendMailOrderByWithRelationInput | T_FriendMailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for T_FriendMails.
     */
    cursor?: T_FriendMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_FriendMails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_FriendMails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of T_FriendMails.
     */
    distinct?: T_FriendMailScalarFieldEnum | T_FriendMailScalarFieldEnum[]
  }


  /**
   * T_FriendMail findFirstOrThrow
   */
  export type T_FriendMailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMail to fetch.
     */
    where?: T_FriendMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_FriendMails to fetch.
     */
    orderBy?: T_FriendMailOrderByWithRelationInput | T_FriendMailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for T_FriendMails.
     */
    cursor?: T_FriendMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_FriendMails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_FriendMails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of T_FriendMails.
     */
    distinct?: T_FriendMailScalarFieldEnum | T_FriendMailScalarFieldEnum[]
  }


  /**
   * T_FriendMail findMany
   */
  export type T_FriendMailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMails to fetch.
     */
    where?: T_FriendMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_FriendMails to fetch.
     */
    orderBy?: T_FriendMailOrderByWithRelationInput | T_FriendMailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing T_FriendMails.
     */
    cursor?: T_FriendMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_FriendMails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_FriendMails.
     */
    skip?: number
    distinct?: T_FriendMailScalarFieldEnum | T_FriendMailScalarFieldEnum[]
  }


  /**
   * T_FriendMail create
   */
  export type T_FriendMailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * The data needed to create a T_FriendMail.
     */
    data: XOR<T_FriendMailCreateInput, T_FriendMailUncheckedCreateInput>
  }


  /**
   * T_FriendMail createMany
   */
  export type T_FriendMailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many T_FriendMails.
     */
    data: T_FriendMailCreateManyInput | T_FriendMailCreateManyInput[]
  }


  /**
   * T_FriendMail update
   */
  export type T_FriendMailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * The data needed to update a T_FriendMail.
     */
    data: XOR<T_FriendMailUpdateInput, T_FriendMailUncheckedUpdateInput>
    /**
     * Choose, which T_FriendMail to update.
     */
    where: T_FriendMailWhereUniqueInput
  }


  /**
   * T_FriendMail updateMany
   */
  export type T_FriendMailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update T_FriendMails.
     */
    data: XOR<T_FriendMailUpdateManyMutationInput, T_FriendMailUncheckedUpdateManyInput>
    /**
     * Filter which T_FriendMails to update
     */
    where?: T_FriendMailWhereInput
  }


  /**
   * T_FriendMail upsert
   */
  export type T_FriendMailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * The filter to search for the T_FriendMail to update in case it exists.
     */
    where: T_FriendMailWhereUniqueInput
    /**
     * In case the T_FriendMail found by the `where` argument doesn't exist, create a new T_FriendMail with this data.
     */
    create: XOR<T_FriendMailCreateInput, T_FriendMailUncheckedCreateInput>
    /**
     * In case the T_FriendMail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<T_FriendMailUpdateInput, T_FriendMailUncheckedUpdateInput>
  }


  /**
   * T_FriendMail delete
   */
  export type T_FriendMailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
    /**
     * Filter which T_FriendMail to delete.
     */
    where: T_FriendMailWhereUniqueInput
  }


  /**
   * T_FriendMail deleteMany
   */
  export type T_FriendMailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which T_FriendMails to delete
     */
    where?: T_FriendMailWhereInput
  }


  /**
   * T_FriendMail without action
   */
  export type T_FriendMailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMail
     */
    select?: T_FriendMailSelect<ExtArgs> | null
  }



  /**
   * Model T_FriendMain
   */

  export type AggregateT_FriendMain = {
    _count: T_FriendMainCountAggregateOutputType | null
    _avg: T_FriendMainAvgAggregateOutputType | null
    _sum: T_FriendMainSumAggregateOutputType | null
    _min: T_FriendMainMinAggregateOutputType | null
    _max: T_FriendMainMaxAggregateOutputType | null
  }

  export type T_FriendMainAvgAggregateOutputType = {
    GUID: number | null
    FriendCount: number | null
    MemoCount: number | null
    MemoTotal: number | null
  }

  export type T_FriendMainSumAggregateOutputType = {
    GUID: number | null
    FriendCount: number | null
    MemoCount: number | null
    MemoTotal: number | null
  }

  export type T_FriendMainMinAggregateOutputType = {
    GUID: number | null
    Name: string | null
    FriendCount: number | null
    MemoCount: number | null
    MemoTotal: number | null
  }

  export type T_FriendMainMaxAggregateOutputType = {
    GUID: number | null
    Name: string | null
    FriendCount: number | null
    MemoCount: number | null
    MemoTotal: number | null
  }

  export type T_FriendMainCountAggregateOutputType = {
    GUID: number
    Name: number
    FriendCount: number
    MemoCount: number
    MemoTotal: number
    _all: number
  }


  export type T_FriendMainAvgAggregateInputType = {
    GUID?: true
    FriendCount?: true
    MemoCount?: true
    MemoTotal?: true
  }

  export type T_FriendMainSumAggregateInputType = {
    GUID?: true
    FriendCount?: true
    MemoCount?: true
    MemoTotal?: true
  }

  export type T_FriendMainMinAggregateInputType = {
    GUID?: true
    Name?: true
    FriendCount?: true
    MemoCount?: true
    MemoTotal?: true
  }

  export type T_FriendMainMaxAggregateInputType = {
    GUID?: true
    Name?: true
    FriendCount?: true
    MemoCount?: true
    MemoTotal?: true
  }

  export type T_FriendMainCountAggregateInputType = {
    GUID?: true
    Name?: true
    FriendCount?: true
    MemoCount?: true
    MemoTotal?: true
    _all?: true
  }

  export type T_FriendMainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which T_FriendMain to aggregate.
     */
    where?: T_FriendMainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_FriendMains to fetch.
     */
    orderBy?: T_FriendMainOrderByWithRelationInput | T_FriendMainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: T_FriendMainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_FriendMains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_FriendMains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned T_FriendMains
    **/
    _count?: true | T_FriendMainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: T_FriendMainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: T_FriendMainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_FriendMainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_FriendMainMaxAggregateInputType
  }

  export type GetT_FriendMainAggregateType<T extends T_FriendMainAggregateArgs> = {
        [P in keyof T & keyof AggregateT_FriendMain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_FriendMain[P]>
      : GetScalarType<T[P], AggregateT_FriendMain[P]>
  }




  export type T_FriendMainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: T_FriendMainWhereInput
    orderBy?: T_FriendMainOrderByWithAggregationInput | T_FriendMainOrderByWithAggregationInput[]
    by: T_FriendMainScalarFieldEnum[] | T_FriendMainScalarFieldEnum
    having?: T_FriendMainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_FriendMainCountAggregateInputType | true
    _avg?: T_FriendMainAvgAggregateInputType
    _sum?: T_FriendMainSumAggregateInputType
    _min?: T_FriendMainMinAggregateInputType
    _max?: T_FriendMainMaxAggregateInputType
  }

  export type T_FriendMainGroupByOutputType = {
    GUID: number
    Name: string
    FriendCount: number | null
    MemoCount: number | null
    MemoTotal: number | null
    _count: T_FriendMainCountAggregateOutputType | null
    _avg: T_FriendMainAvgAggregateOutputType | null
    _sum: T_FriendMainSumAggregateOutputType | null
    _min: T_FriendMainMinAggregateOutputType | null
    _max: T_FriendMainMaxAggregateOutputType | null
  }

  type GetT_FriendMainGroupByPayload<T extends T_FriendMainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_FriendMainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_FriendMainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_FriendMainGroupByOutputType[P]>
            : GetScalarType<T[P], T_FriendMainGroupByOutputType[P]>
        }
      >
    >


  export type T_FriendMainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    GUID?: boolean
    Name?: boolean
    FriendCount?: boolean
    MemoCount?: boolean
    MemoTotal?: boolean
  }, ExtArgs["result"]["t_FriendMain"]>

  export type T_FriendMainSelectScalar = {
    GUID?: boolean
    Name?: boolean
    FriendCount?: boolean
    MemoCount?: boolean
    MemoTotal?: boolean
  }


  export type $T_FriendMainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "T_FriendMain"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      GUID: number
      Name: string
      FriendCount: number | null
      MemoCount: number | null
      MemoTotal: number | null
    }, ExtArgs["result"]["t_FriendMain"]>
    composites: {}
  }


  type T_FriendMainGetPayload<S extends boolean | null | undefined | T_FriendMainDefaultArgs> = $Result.GetResult<Prisma.$T_FriendMainPayload, S>

  type T_FriendMainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<T_FriendMainFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: T_FriendMainCountAggregateInputType | true
    }

  export interface T_FriendMainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['T_FriendMain'], meta: { name: 'T_FriendMain' } }
    /**
     * Find zero or one T_FriendMain that matches the filter.
     * @param {T_FriendMainFindUniqueArgs} args - Arguments to find a T_FriendMain
     * @example
     * // Get one T_FriendMain
     * const t_FriendMain = await prisma.t_FriendMain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends T_FriendMainFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMainFindUniqueArgs<ExtArgs>>
    ): Prisma__T_FriendMainClient<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one T_FriendMain that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {T_FriendMainFindUniqueOrThrowArgs} args - Arguments to find a T_FriendMain
     * @example
     * // Get one T_FriendMain
     * const t_FriendMain = await prisma.t_FriendMain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends T_FriendMainFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMainFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__T_FriendMainClient<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first T_FriendMain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMainFindFirstArgs} args - Arguments to find a T_FriendMain
     * @example
     * // Get one T_FriendMain
     * const t_FriendMain = await prisma.t_FriendMain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends T_FriendMainFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMainFindFirstArgs<ExtArgs>>
    ): Prisma__T_FriendMainClient<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first T_FriendMain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMainFindFirstOrThrowArgs} args - Arguments to find a T_FriendMain
     * @example
     * // Get one T_FriendMain
     * const t_FriendMain = await prisma.t_FriendMain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends T_FriendMainFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMainFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__T_FriendMainClient<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more T_FriendMains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_FriendMains
     * const t_FriendMains = await prisma.t_FriendMain.findMany()
     * 
     * // Get first 10 T_FriendMains
     * const t_FriendMains = await prisma.t_FriendMain.findMany({ take: 10 })
     * 
     * // Only select the `GUID`
     * const t_FriendMainWithGUIDOnly = await prisma.t_FriendMain.findMany({ select: { GUID: true } })
     * 
    **/
    findMany<T extends T_FriendMainFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMainFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a T_FriendMain.
     * @param {T_FriendMainCreateArgs} args - Arguments to create a T_FriendMain.
     * @example
     * // Create one T_FriendMain
     * const T_FriendMain = await prisma.t_FriendMain.create({
     *   data: {
     *     // ... data to create a T_FriendMain
     *   }
     * })
     * 
    **/
    create<T extends T_FriendMainCreateArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMainCreateArgs<ExtArgs>>
    ): Prisma__T_FriendMainClient<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many T_FriendMains.
     *     @param {T_FriendMainCreateManyArgs} args - Arguments to create many T_FriendMains.
     *     @example
     *     // Create many T_FriendMains
     *     const t_FriendMain = await prisma.t_FriendMain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends T_FriendMainCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMainCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a T_FriendMain.
     * @param {T_FriendMainDeleteArgs} args - Arguments to delete one T_FriendMain.
     * @example
     * // Delete one T_FriendMain
     * const T_FriendMain = await prisma.t_FriendMain.delete({
     *   where: {
     *     // ... filter to delete one T_FriendMain
     *   }
     * })
     * 
    **/
    delete<T extends T_FriendMainDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMainDeleteArgs<ExtArgs>>
    ): Prisma__T_FriendMainClient<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one T_FriendMain.
     * @param {T_FriendMainUpdateArgs} args - Arguments to update one T_FriendMain.
     * @example
     * // Update one T_FriendMain
     * const t_FriendMain = await prisma.t_FriendMain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends T_FriendMainUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMainUpdateArgs<ExtArgs>>
    ): Prisma__T_FriendMainClient<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more T_FriendMains.
     * @param {T_FriendMainDeleteManyArgs} args - Arguments to filter T_FriendMains to delete.
     * @example
     * // Delete a few T_FriendMains
     * const { count } = await prisma.t_FriendMain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends T_FriendMainDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_FriendMainDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_FriendMains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_FriendMains
     * const t_FriendMain = await prisma.t_FriendMain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends T_FriendMainUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMainUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one T_FriendMain.
     * @param {T_FriendMainUpsertArgs} args - Arguments to update or create a T_FriendMain.
     * @example
     * // Update or create a T_FriendMain
     * const t_FriendMain = await prisma.t_FriendMain.upsert({
     *   create: {
     *     // ... data to create a T_FriendMain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_FriendMain we want to update
     *   }
     * })
    **/
    upsert<T extends T_FriendMainUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, T_FriendMainUpsertArgs<ExtArgs>>
    ): Prisma__T_FriendMainClient<$Result.GetResult<Prisma.$T_FriendMainPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of T_FriendMains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMainCountArgs} args - Arguments to filter T_FriendMains to count.
     * @example
     * // Count the number of T_FriendMains
     * const count = await prisma.t_FriendMain.count({
     *   where: {
     *     // ... the filter for the T_FriendMains we want to count
     *   }
     * })
    **/
    count<T extends T_FriendMainCountArgs>(
      args?: Subset<T, T_FriendMainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_FriendMainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_FriendMain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_FriendMainAggregateArgs>(args: Subset<T, T_FriendMainAggregateArgs>): Prisma.PrismaPromise<GetT_FriendMainAggregateType<T>>

    /**
     * Group by T_FriendMain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_FriendMainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends T_FriendMainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: T_FriendMainGroupByArgs['orderBy'] }
        : { orderBy?: T_FriendMainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, T_FriendMainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_FriendMainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the T_FriendMain model
   */
  readonly fields: T_FriendMainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for T_FriendMain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__T_FriendMainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the T_FriendMain model
   */ 
  interface T_FriendMainFieldRefs {
    readonly GUID: FieldRef<"T_FriendMain", 'Int'>
    readonly Name: FieldRef<"T_FriendMain", 'String'>
    readonly FriendCount: FieldRef<"T_FriendMain", 'Int'>
    readonly MemoCount: FieldRef<"T_FriendMain", 'Int'>
    readonly MemoTotal: FieldRef<"T_FriendMain", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * T_FriendMain findUnique
   */
  export type T_FriendMainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMain to fetch.
     */
    where: T_FriendMainWhereUniqueInput
  }


  /**
   * T_FriendMain findUniqueOrThrow
   */
  export type T_FriendMainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMain to fetch.
     */
    where: T_FriendMainWhereUniqueInput
  }


  /**
   * T_FriendMain findFirst
   */
  export type T_FriendMainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMain to fetch.
     */
    where?: T_FriendMainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_FriendMains to fetch.
     */
    orderBy?: T_FriendMainOrderByWithRelationInput | T_FriendMainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for T_FriendMains.
     */
    cursor?: T_FriendMainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_FriendMains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_FriendMains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of T_FriendMains.
     */
    distinct?: T_FriendMainScalarFieldEnum | T_FriendMainScalarFieldEnum[]
  }


  /**
   * T_FriendMain findFirstOrThrow
   */
  export type T_FriendMainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMain to fetch.
     */
    where?: T_FriendMainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_FriendMains to fetch.
     */
    orderBy?: T_FriendMainOrderByWithRelationInput | T_FriendMainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for T_FriendMains.
     */
    cursor?: T_FriendMainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_FriendMains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_FriendMains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of T_FriendMains.
     */
    distinct?: T_FriendMainScalarFieldEnum | T_FriendMainScalarFieldEnum[]
  }


  /**
   * T_FriendMain findMany
   */
  export type T_FriendMainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * Filter, which T_FriendMains to fetch.
     */
    where?: T_FriendMainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_FriendMains to fetch.
     */
    orderBy?: T_FriendMainOrderByWithRelationInput | T_FriendMainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing T_FriendMains.
     */
    cursor?: T_FriendMainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_FriendMains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_FriendMains.
     */
    skip?: number
    distinct?: T_FriendMainScalarFieldEnum | T_FriendMainScalarFieldEnum[]
  }


  /**
   * T_FriendMain create
   */
  export type T_FriendMainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * The data needed to create a T_FriendMain.
     */
    data: XOR<T_FriendMainCreateInput, T_FriendMainUncheckedCreateInput>
  }


  /**
   * T_FriendMain createMany
   */
  export type T_FriendMainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many T_FriendMains.
     */
    data: T_FriendMainCreateManyInput | T_FriendMainCreateManyInput[]
  }


  /**
   * T_FriendMain update
   */
  export type T_FriendMainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * The data needed to update a T_FriendMain.
     */
    data: XOR<T_FriendMainUpdateInput, T_FriendMainUncheckedUpdateInput>
    /**
     * Choose, which T_FriendMain to update.
     */
    where: T_FriendMainWhereUniqueInput
  }


  /**
   * T_FriendMain updateMany
   */
  export type T_FriendMainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update T_FriendMains.
     */
    data: XOR<T_FriendMainUpdateManyMutationInput, T_FriendMainUncheckedUpdateManyInput>
    /**
     * Filter which T_FriendMains to update
     */
    where?: T_FriendMainWhereInput
  }


  /**
   * T_FriendMain upsert
   */
  export type T_FriendMainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * The filter to search for the T_FriendMain to update in case it exists.
     */
    where: T_FriendMainWhereUniqueInput
    /**
     * In case the T_FriendMain found by the `where` argument doesn't exist, create a new T_FriendMain with this data.
     */
    create: XOR<T_FriendMainCreateInput, T_FriendMainUncheckedCreateInput>
    /**
     * In case the T_FriendMain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<T_FriendMainUpdateInput, T_FriendMainUncheckedUpdateInput>
  }


  /**
   * T_FriendMain delete
   */
  export type T_FriendMainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
    /**
     * Filter which T_FriendMain to delete.
     */
    where: T_FriendMainWhereUniqueInput
  }


  /**
   * T_FriendMain deleteMany
   */
  export type T_FriendMainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which T_FriendMains to delete
     */
    where?: T_FriendMainWhereInput
  }


  /**
   * T_FriendMain without action
   */
  export type T_FriendMainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_FriendMain
     */
    select?: T_FriendMainSelect<ExtArgs> | null
  }



  /**
   * Model T_PetItem_Info
   */

  export type AggregateT_PetItem_Info = {
    _count: T_PetItem_InfoCountAggregateOutputType | null
    _avg: T_PetItem_InfoAvgAggregateOutputType | null
    _sum: T_PetItem_InfoSumAggregateOutputType | null
    _min: T_PetItem_InfoMinAggregateOutputType | null
    _max: T_PetItem_InfoMaxAggregateOutputType | null
  }

  export type T_PetItem_InfoAvgAggregateOutputType = {
    ItemSerial: number | null
    Pet_Level: number | null
    Pet_Exp: number | null
  }

  export type T_PetItem_InfoSumAggregateOutputType = {
    ItemSerial: number | null
    Pet_Level: number | null
    Pet_Exp: number | null
  }

  export type T_PetItem_InfoMinAggregateOutputType = {
    ItemSerial: number | null
    Pet_Level: number | null
    Pet_Exp: number | null
  }

  export type T_PetItem_InfoMaxAggregateOutputType = {
    ItemSerial: number | null
    Pet_Level: number | null
    Pet_Exp: number | null
  }

  export type T_PetItem_InfoCountAggregateOutputType = {
    ItemSerial: number
    Pet_Level: number
    Pet_Exp: number
    _all: number
  }


  export type T_PetItem_InfoAvgAggregateInputType = {
    ItemSerial?: true
    Pet_Level?: true
    Pet_Exp?: true
  }

  export type T_PetItem_InfoSumAggregateInputType = {
    ItemSerial?: true
    Pet_Level?: true
    Pet_Exp?: true
  }

  export type T_PetItem_InfoMinAggregateInputType = {
    ItemSerial?: true
    Pet_Level?: true
    Pet_Exp?: true
  }

  export type T_PetItem_InfoMaxAggregateInputType = {
    ItemSerial?: true
    Pet_Level?: true
    Pet_Exp?: true
  }

  export type T_PetItem_InfoCountAggregateInputType = {
    ItemSerial?: true
    Pet_Level?: true
    Pet_Exp?: true
    _all?: true
  }

  export type T_PetItem_InfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which T_PetItem_Info to aggregate.
     */
    where?: T_PetItem_InfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_PetItem_Infos to fetch.
     */
    orderBy?: T_PetItem_InfoOrderByWithRelationInput | T_PetItem_InfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: T_PetItem_InfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_PetItem_Infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_PetItem_Infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned T_PetItem_Infos
    **/
    _count?: true | T_PetItem_InfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: T_PetItem_InfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: T_PetItem_InfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_PetItem_InfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_PetItem_InfoMaxAggregateInputType
  }

  export type GetT_PetItem_InfoAggregateType<T extends T_PetItem_InfoAggregateArgs> = {
        [P in keyof T & keyof AggregateT_PetItem_Info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_PetItem_Info[P]>
      : GetScalarType<T[P], AggregateT_PetItem_Info[P]>
  }




  export type T_PetItem_InfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: T_PetItem_InfoWhereInput
    orderBy?: T_PetItem_InfoOrderByWithAggregationInput | T_PetItem_InfoOrderByWithAggregationInput[]
    by: T_PetItem_InfoScalarFieldEnum[] | T_PetItem_InfoScalarFieldEnum
    having?: T_PetItem_InfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_PetItem_InfoCountAggregateInputType | true
    _avg?: T_PetItem_InfoAvgAggregateInputType
    _sum?: T_PetItem_InfoSumAggregateInputType
    _min?: T_PetItem_InfoMinAggregateInputType
    _max?: T_PetItem_InfoMaxAggregateInputType
  }

  export type T_PetItem_InfoGroupByOutputType = {
    ItemSerial: number
    Pet_Level: number | null
    Pet_Exp: number | null
    _count: T_PetItem_InfoCountAggregateOutputType | null
    _avg: T_PetItem_InfoAvgAggregateOutputType | null
    _sum: T_PetItem_InfoSumAggregateOutputType | null
    _min: T_PetItem_InfoMinAggregateOutputType | null
    _max: T_PetItem_InfoMaxAggregateOutputType | null
  }

  type GetT_PetItem_InfoGroupByPayload<T extends T_PetItem_InfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_PetItem_InfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_PetItem_InfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_PetItem_InfoGroupByOutputType[P]>
            : GetScalarType<T[P], T_PetItem_InfoGroupByOutputType[P]>
        }
      >
    >


  export type T_PetItem_InfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ItemSerial?: boolean
    Pet_Level?: boolean
    Pet_Exp?: boolean
  }, ExtArgs["result"]["t_PetItem_Info"]>

  export type T_PetItem_InfoSelectScalar = {
    ItemSerial?: boolean
    Pet_Level?: boolean
    Pet_Exp?: boolean
  }


  export type $T_PetItem_InfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "T_PetItem_Info"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ItemSerial: number
      Pet_Level: number | null
      Pet_Exp: number | null
    }, ExtArgs["result"]["t_PetItem_Info"]>
    composites: {}
  }


  type T_PetItem_InfoGetPayload<S extends boolean | null | undefined | T_PetItem_InfoDefaultArgs> = $Result.GetResult<Prisma.$T_PetItem_InfoPayload, S>

  type T_PetItem_InfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<T_PetItem_InfoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: T_PetItem_InfoCountAggregateInputType | true
    }

  export interface T_PetItem_InfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['T_PetItem_Info'], meta: { name: 'T_PetItem_Info' } }
    /**
     * Find zero or one T_PetItem_Info that matches the filter.
     * @param {T_PetItem_InfoFindUniqueArgs} args - Arguments to find a T_PetItem_Info
     * @example
     * // Get one T_PetItem_Info
     * const t_PetItem_Info = await prisma.t_PetItem_Info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends T_PetItem_InfoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, T_PetItem_InfoFindUniqueArgs<ExtArgs>>
    ): Prisma__T_PetItem_InfoClient<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one T_PetItem_Info that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {T_PetItem_InfoFindUniqueOrThrowArgs} args - Arguments to find a T_PetItem_Info
     * @example
     * // Get one T_PetItem_Info
     * const t_PetItem_Info = await prisma.t_PetItem_Info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends T_PetItem_InfoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, T_PetItem_InfoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__T_PetItem_InfoClient<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first T_PetItem_Info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_PetItem_InfoFindFirstArgs} args - Arguments to find a T_PetItem_Info
     * @example
     * // Get one T_PetItem_Info
     * const t_PetItem_Info = await prisma.t_PetItem_Info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends T_PetItem_InfoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, T_PetItem_InfoFindFirstArgs<ExtArgs>>
    ): Prisma__T_PetItem_InfoClient<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first T_PetItem_Info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_PetItem_InfoFindFirstOrThrowArgs} args - Arguments to find a T_PetItem_Info
     * @example
     * // Get one T_PetItem_Info
     * const t_PetItem_Info = await prisma.t_PetItem_Info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends T_PetItem_InfoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, T_PetItem_InfoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__T_PetItem_InfoClient<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more T_PetItem_Infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_PetItem_InfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_PetItem_Infos
     * const t_PetItem_Infos = await prisma.t_PetItem_Info.findMany()
     * 
     * // Get first 10 T_PetItem_Infos
     * const t_PetItem_Infos = await prisma.t_PetItem_Info.findMany({ take: 10 })
     * 
     * // Only select the `ItemSerial`
     * const t_PetItem_InfoWithItemSerialOnly = await prisma.t_PetItem_Info.findMany({ select: { ItemSerial: true } })
     * 
    **/
    findMany<T extends T_PetItem_InfoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_PetItem_InfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a T_PetItem_Info.
     * @param {T_PetItem_InfoCreateArgs} args - Arguments to create a T_PetItem_Info.
     * @example
     * // Create one T_PetItem_Info
     * const T_PetItem_Info = await prisma.t_PetItem_Info.create({
     *   data: {
     *     // ... data to create a T_PetItem_Info
     *   }
     * })
     * 
    **/
    create<T extends T_PetItem_InfoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, T_PetItem_InfoCreateArgs<ExtArgs>>
    ): Prisma__T_PetItem_InfoClient<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many T_PetItem_Infos.
     *     @param {T_PetItem_InfoCreateManyArgs} args - Arguments to create many T_PetItem_Infos.
     *     @example
     *     // Create many T_PetItem_Infos
     *     const t_PetItem_Info = await prisma.t_PetItem_Info.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends T_PetItem_InfoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_PetItem_InfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a T_PetItem_Info.
     * @param {T_PetItem_InfoDeleteArgs} args - Arguments to delete one T_PetItem_Info.
     * @example
     * // Delete one T_PetItem_Info
     * const T_PetItem_Info = await prisma.t_PetItem_Info.delete({
     *   where: {
     *     // ... filter to delete one T_PetItem_Info
     *   }
     * })
     * 
    **/
    delete<T extends T_PetItem_InfoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, T_PetItem_InfoDeleteArgs<ExtArgs>>
    ): Prisma__T_PetItem_InfoClient<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one T_PetItem_Info.
     * @param {T_PetItem_InfoUpdateArgs} args - Arguments to update one T_PetItem_Info.
     * @example
     * // Update one T_PetItem_Info
     * const t_PetItem_Info = await prisma.t_PetItem_Info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends T_PetItem_InfoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, T_PetItem_InfoUpdateArgs<ExtArgs>>
    ): Prisma__T_PetItem_InfoClient<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more T_PetItem_Infos.
     * @param {T_PetItem_InfoDeleteManyArgs} args - Arguments to filter T_PetItem_Infos to delete.
     * @example
     * // Delete a few T_PetItem_Infos
     * const { count } = await prisma.t_PetItem_Info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends T_PetItem_InfoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, T_PetItem_InfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_PetItem_Infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_PetItem_InfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_PetItem_Infos
     * const t_PetItem_Info = await prisma.t_PetItem_Info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends T_PetItem_InfoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, T_PetItem_InfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one T_PetItem_Info.
     * @param {T_PetItem_InfoUpsertArgs} args - Arguments to update or create a T_PetItem_Info.
     * @example
     * // Update or create a T_PetItem_Info
     * const t_PetItem_Info = await prisma.t_PetItem_Info.upsert({
     *   create: {
     *     // ... data to create a T_PetItem_Info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_PetItem_Info we want to update
     *   }
     * })
    **/
    upsert<T extends T_PetItem_InfoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, T_PetItem_InfoUpsertArgs<ExtArgs>>
    ): Prisma__T_PetItem_InfoClient<$Result.GetResult<Prisma.$T_PetItem_InfoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of T_PetItem_Infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_PetItem_InfoCountArgs} args - Arguments to filter T_PetItem_Infos to count.
     * @example
     * // Count the number of T_PetItem_Infos
     * const count = await prisma.t_PetItem_Info.count({
     *   where: {
     *     // ... the filter for the T_PetItem_Infos we want to count
     *   }
     * })
    **/
    count<T extends T_PetItem_InfoCountArgs>(
      args?: Subset<T, T_PetItem_InfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_PetItem_InfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_PetItem_Info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_PetItem_InfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_PetItem_InfoAggregateArgs>(args: Subset<T, T_PetItem_InfoAggregateArgs>): Prisma.PrismaPromise<GetT_PetItem_InfoAggregateType<T>>

    /**
     * Group by T_PetItem_Info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_PetItem_InfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends T_PetItem_InfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: T_PetItem_InfoGroupByArgs['orderBy'] }
        : { orderBy?: T_PetItem_InfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, T_PetItem_InfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_PetItem_InfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the T_PetItem_Info model
   */
  readonly fields: T_PetItem_InfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for T_PetItem_Info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__T_PetItem_InfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the T_PetItem_Info model
   */ 
  interface T_PetItem_InfoFieldRefs {
    readonly ItemSerial: FieldRef<"T_PetItem_Info", 'Int'>
    readonly Pet_Level: FieldRef<"T_PetItem_Info", 'Int'>
    readonly Pet_Exp: FieldRef<"T_PetItem_Info", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * T_PetItem_Info findUnique
   */
  export type T_PetItem_InfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * Filter, which T_PetItem_Info to fetch.
     */
    where: T_PetItem_InfoWhereUniqueInput
  }


  /**
   * T_PetItem_Info findUniqueOrThrow
   */
  export type T_PetItem_InfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * Filter, which T_PetItem_Info to fetch.
     */
    where: T_PetItem_InfoWhereUniqueInput
  }


  /**
   * T_PetItem_Info findFirst
   */
  export type T_PetItem_InfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * Filter, which T_PetItem_Info to fetch.
     */
    where?: T_PetItem_InfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_PetItem_Infos to fetch.
     */
    orderBy?: T_PetItem_InfoOrderByWithRelationInput | T_PetItem_InfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for T_PetItem_Infos.
     */
    cursor?: T_PetItem_InfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_PetItem_Infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_PetItem_Infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of T_PetItem_Infos.
     */
    distinct?: T_PetItem_InfoScalarFieldEnum | T_PetItem_InfoScalarFieldEnum[]
  }


  /**
   * T_PetItem_Info findFirstOrThrow
   */
  export type T_PetItem_InfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * Filter, which T_PetItem_Info to fetch.
     */
    where?: T_PetItem_InfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_PetItem_Infos to fetch.
     */
    orderBy?: T_PetItem_InfoOrderByWithRelationInput | T_PetItem_InfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for T_PetItem_Infos.
     */
    cursor?: T_PetItem_InfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_PetItem_Infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_PetItem_Infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of T_PetItem_Infos.
     */
    distinct?: T_PetItem_InfoScalarFieldEnum | T_PetItem_InfoScalarFieldEnum[]
  }


  /**
   * T_PetItem_Info findMany
   */
  export type T_PetItem_InfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * Filter, which T_PetItem_Infos to fetch.
     */
    where?: T_PetItem_InfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of T_PetItem_Infos to fetch.
     */
    orderBy?: T_PetItem_InfoOrderByWithRelationInput | T_PetItem_InfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing T_PetItem_Infos.
     */
    cursor?: T_PetItem_InfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` T_PetItem_Infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` T_PetItem_Infos.
     */
    skip?: number
    distinct?: T_PetItem_InfoScalarFieldEnum | T_PetItem_InfoScalarFieldEnum[]
  }


  /**
   * T_PetItem_Info create
   */
  export type T_PetItem_InfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * The data needed to create a T_PetItem_Info.
     */
    data: XOR<T_PetItem_InfoCreateInput, T_PetItem_InfoUncheckedCreateInput>
  }


  /**
   * T_PetItem_Info createMany
   */
  export type T_PetItem_InfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many T_PetItem_Infos.
     */
    data: T_PetItem_InfoCreateManyInput | T_PetItem_InfoCreateManyInput[]
  }


  /**
   * T_PetItem_Info update
   */
  export type T_PetItem_InfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * The data needed to update a T_PetItem_Info.
     */
    data: XOR<T_PetItem_InfoUpdateInput, T_PetItem_InfoUncheckedUpdateInput>
    /**
     * Choose, which T_PetItem_Info to update.
     */
    where: T_PetItem_InfoWhereUniqueInput
  }


  /**
   * T_PetItem_Info updateMany
   */
  export type T_PetItem_InfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update T_PetItem_Infos.
     */
    data: XOR<T_PetItem_InfoUpdateManyMutationInput, T_PetItem_InfoUncheckedUpdateManyInput>
    /**
     * Filter which T_PetItem_Infos to update
     */
    where?: T_PetItem_InfoWhereInput
  }


  /**
   * T_PetItem_Info upsert
   */
  export type T_PetItem_InfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * The filter to search for the T_PetItem_Info to update in case it exists.
     */
    where: T_PetItem_InfoWhereUniqueInput
    /**
     * In case the T_PetItem_Info found by the `where` argument doesn't exist, create a new T_PetItem_Info with this data.
     */
    create: XOR<T_PetItem_InfoCreateInput, T_PetItem_InfoUncheckedCreateInput>
    /**
     * In case the T_PetItem_Info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<T_PetItem_InfoUpdateInput, T_PetItem_InfoUncheckedUpdateInput>
  }


  /**
   * T_PetItem_Info delete
   */
  export type T_PetItem_InfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
    /**
     * Filter which T_PetItem_Info to delete.
     */
    where: T_PetItem_InfoWhereUniqueInput
  }


  /**
   * T_PetItem_Info deleteMany
   */
  export type T_PetItem_InfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which T_PetItem_Infos to delete
     */
    where?: T_PetItem_InfoWhereInput
  }


  /**
   * T_PetItem_Info without action
   */
  export type T_PetItem_InfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_PetItem_Info
     */
    select?: T_PetItem_InfoSelect<ExtArgs> | null
  }



  /**
   * Model warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseAvgAggregateOutputType = {
    Money: number | null
    DbVersion: number | null
    pw: number | null
    VaultCounts: number | null
    LastVaultID: number | null
  }

  export type WarehouseSumAggregateOutputType = {
    Money: number | null
    DbVersion: number | null
    pw: number | null
    VaultCounts: number | null
    LastVaultID: number | null
  }

  export type WarehouseMinAggregateOutputType = {
    AccountID: string | null
    Items: Buffer | null
    Money: number | null
    EndUseDate: Date | null
    DbVersion: number | null
    pw: number | null
    VaultCounts: number | null
    LastVaultID: number | null
  }

  export type WarehouseMaxAggregateOutputType = {
    AccountID: string | null
    Items: Buffer | null
    Money: number | null
    EndUseDate: Date | null
    DbVersion: number | null
    pw: number | null
    VaultCounts: number | null
    LastVaultID: number | null
  }

  export type WarehouseCountAggregateOutputType = {
    AccountID: number
    Items: number
    Money: number
    EndUseDate: number
    DbVersion: number
    pw: number
    VaultCounts: number
    LastVaultID: number
    _all: number
  }


  export type WarehouseAvgAggregateInputType = {
    Money?: true
    DbVersion?: true
    pw?: true
    VaultCounts?: true
    LastVaultID?: true
  }

  export type WarehouseSumAggregateInputType = {
    Money?: true
    DbVersion?: true
    pw?: true
    VaultCounts?: true
    LastVaultID?: true
  }

  export type WarehouseMinAggregateInputType = {
    AccountID?: true
    Items?: true
    Money?: true
    EndUseDate?: true
    DbVersion?: true
    pw?: true
    VaultCounts?: true
    LastVaultID?: true
  }

  export type WarehouseMaxAggregateInputType = {
    AccountID?: true
    Items?: true
    Money?: true
    EndUseDate?: true
    DbVersion?: true
    pw?: true
    VaultCounts?: true
    LastVaultID?: true
  }

  export type WarehouseCountAggregateInputType = {
    AccountID?: true
    Items?: true
    Money?: true
    EndUseDate?: true
    DbVersion?: true
    pw?: true
    VaultCounts?: true
    LastVaultID?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which warehouse to aggregate.
     */
    where?: warehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouses to fetch.
     */
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: warehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type warehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: warehouseWhereInput
    orderBy?: warehouseOrderByWithAggregationInput | warehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: warehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _avg?: WarehouseAvgAggregateInputType
    _sum?: WarehouseSumAggregateInputType
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    AccountID: string
    Items: Buffer | null
    Money: number | null
    EndUseDate: Date | null
    DbVersion: number | null
    pw: number | null
    VaultCounts: number
    LastVaultID: number
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends warehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type warehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AccountID?: boolean
    Items?: boolean
    Money?: boolean
    EndUseDate?: boolean
    DbVersion?: boolean
    pw?: boolean
    VaultCounts?: boolean
    LastVaultID?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type warehouseSelectScalar = {
    AccountID?: boolean
    Items?: boolean
    Money?: boolean
    EndUseDate?: boolean
    DbVersion?: boolean
    pw?: boolean
    VaultCounts?: boolean
    LastVaultID?: boolean
  }


  export type $warehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "warehouse"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AccountID: string
      Items: Buffer | null
      Money: number | null
      EndUseDate: Date | null
      DbVersion: number | null
      pw: number | null
      VaultCounts: number
      LastVaultID: number
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }


  type warehouseGetPayload<S extends boolean | null | undefined | warehouseDefaultArgs> = $Result.GetResult<Prisma.$warehousePayload, S>

  type warehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<warehouseFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface warehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['warehouse'], meta: { name: 'warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {warehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends warehouseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, warehouseFindUniqueArgs<ExtArgs>>
    ): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Warehouse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {warehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends warehouseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, warehouseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends warehouseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, warehouseFindFirstArgs<ExtArgs>>
    ): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends warehouseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, warehouseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `AccountID`
     * const warehouseWithAccountIDOnly = await prisma.warehouse.findMany({ select: { AccountID: true } })
     * 
    **/
    findMany<T extends warehouseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warehouseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Warehouse.
     * @param {warehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
    **/
    create<T extends warehouseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, warehouseCreateArgs<ExtArgs>>
    ): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Warehouses.
     *     @param {warehouseCreateManyArgs} args - Arguments to create many Warehouses.
     *     @example
     *     // Create many Warehouses
     *     const warehouse = await prisma.warehouse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends warehouseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warehouseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Warehouse.
     * @param {warehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
    **/
    delete<T extends warehouseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, warehouseDeleteArgs<ExtArgs>>
    ): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Warehouse.
     * @param {warehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends warehouseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, warehouseUpdateArgs<ExtArgs>>
    ): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Warehouses.
     * @param {warehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends warehouseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, warehouseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends warehouseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, warehouseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Warehouse.
     * @param {warehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
    **/
    upsert<T extends warehouseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, warehouseUpsertArgs<ExtArgs>>
    ): Prisma__warehouseClient<$Result.GetResult<Prisma.$warehousePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends warehouseCountArgs>(
      args?: Subset<T, warehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends warehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: warehouseGroupByArgs['orderBy'] }
        : { orderBy?: warehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, warehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the warehouse model
   */
  readonly fields: warehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__warehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the warehouse model
   */ 
  interface warehouseFieldRefs {
    readonly AccountID: FieldRef<"warehouse", 'String'>
    readonly Items: FieldRef<"warehouse", 'Bytes'>
    readonly Money: FieldRef<"warehouse", 'Int'>
    readonly EndUseDate: FieldRef<"warehouse", 'DateTime'>
    readonly DbVersion: FieldRef<"warehouse", 'Int'>
    readonly pw: FieldRef<"warehouse", 'Int'>
    readonly VaultCounts: FieldRef<"warehouse", 'Int'>
    readonly LastVaultID: FieldRef<"warehouse", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * warehouse findUnique
   */
  export type warehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Filter, which warehouse to fetch.
     */
    where: warehouseWhereUniqueInput
  }


  /**
   * warehouse findUniqueOrThrow
   */
  export type warehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Filter, which warehouse to fetch.
     */
    where: warehouseWhereUniqueInput
  }


  /**
   * warehouse findFirst
   */
  export type warehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Filter, which warehouse to fetch.
     */
    where?: warehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouses to fetch.
     */
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warehouses.
     */
    cursor?: warehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }


  /**
   * warehouse findFirstOrThrow
   */
  export type warehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Filter, which warehouse to fetch.
     */
    where?: warehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouses to fetch.
     */
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warehouses.
     */
    cursor?: warehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }


  /**
   * warehouse findMany
   */
  export type warehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Filter, which warehouses to fetch.
     */
    where?: warehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warehouses to fetch.
     */
    orderBy?: warehouseOrderByWithRelationInput | warehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing warehouses.
     */
    cursor?: warehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }


  /**
   * warehouse create
   */
  export type warehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * The data needed to create a warehouse.
     */
    data: XOR<warehouseCreateInput, warehouseUncheckedCreateInput>
  }


  /**
   * warehouse createMany
   */
  export type warehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many warehouses.
     */
    data: warehouseCreateManyInput | warehouseCreateManyInput[]
  }


  /**
   * warehouse update
   */
  export type warehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * The data needed to update a warehouse.
     */
    data: XOR<warehouseUpdateInput, warehouseUncheckedUpdateInput>
    /**
     * Choose, which warehouse to update.
     */
    where: warehouseWhereUniqueInput
  }


  /**
   * warehouse updateMany
   */
  export type warehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update warehouses.
     */
    data: XOR<warehouseUpdateManyMutationInput, warehouseUncheckedUpdateManyInput>
    /**
     * Filter which warehouses to update
     */
    where?: warehouseWhereInput
  }


  /**
   * warehouse upsert
   */
  export type warehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * The filter to search for the warehouse to update in case it exists.
     */
    where: warehouseWhereUniqueInput
    /**
     * In case the warehouse found by the `where` argument doesn't exist, create a new warehouse with this data.
     */
    create: XOR<warehouseCreateInput, warehouseUncheckedCreateInput>
    /**
     * In case the warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<warehouseUpdateInput, warehouseUncheckedUpdateInput>
  }


  /**
   * warehouse delete
   */
  export type warehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
    /**
     * Filter which warehouse to delete.
     */
    where: warehouseWhereUniqueInput
  }


  /**
   * warehouse deleteMany
   */
  export type warehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which warehouses to delete
     */
    where?: warehouseWhereInput
  }


  /**
   * warehouse without action
   */
  export type warehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warehouse
     */
    select?: warehouseSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MEMB_INFOScalarFieldEnum: {
    memb_guid: 'memb_guid',
    memb___id: 'memb___id',
    memb__pwd: 'memb__pwd',
    memb_name: 'memb_name',
    sno__numb: 'sno__numb',
    post_code: 'post_code',
    addr_info: 'addr_info',
    addr_deta: 'addr_deta',
    tel__numb: 'tel__numb',
    phon_numb: 'phon_numb',
    mail_addr: 'mail_addr',
    fpas_ques: 'fpas_ques',
    fpas_answ: 'fpas_answ',
    job__code: 'job__code',
    appl_days: 'appl_days',
    modi_days: 'modi_days',
    out__days: 'out__days',
    true_days: 'true_days',
    mail_chek: 'mail_chek',
    bloc_code: 'bloc_code',
    ctl1_code: 'ctl1_code',
    AccountLevel: 'AccountLevel',
    AccountExpireDate: 'AccountExpireDate',
    vip: 'vip',
    cash: 'cash',
    RewardPlayer: 'RewardPlayer',
    ChaosPoints: 'ChaosPoints',
    BlessPoints: 'BlessPoints',
    SoulPoints: 'SoulPoints',
    LifePoints: 'LifePoints',
    CreationPoints: 'CreationPoints',
    GuardianPoints: 'GuardianPoints',
    GemstonePoints: 'GemstonePoints',
    HarmonyPoints: 'HarmonyPoints',
    LRefiningPoints: 'LRefiningPoints',
    HRefiningPoints: 'HRefiningPoints',
    LockPassword: 'LockPassword'
  };

  export type MEMB_INFOScalarFieldEnum = (typeof MEMB_INFOScalarFieldEnum)[keyof typeof MEMB_INFOScalarFieldEnum]


  export const AccountCharacterScalarFieldEnum: {
    Number: 'Number',
    Id: 'Id',
    GameID1: 'GameID1',
    GameID2: 'GameID2',
    GameID3: 'GameID3',
    GameID4: 'GameID4',
    GameID5: 'GameID5',
    GameIDC: 'GameIDC',
    MoveCnt: 'MoveCnt',
    ExtClass: 'ExtClass',
    ExtWarehouse: 'ExtWarehouse',
    GameID6: 'GameID6',
    GameID7: 'GameID7',
    GameID8: 'GameID8',
    GameID9: 'GameID9',
    GameID10: 'GameID10',
    MaxCharacter: 'MaxCharacter'
  };

  export type AccountCharacterScalarFieldEnum = (typeof AccountCharacterScalarFieldEnum)[keyof typeof AccountCharacterScalarFieldEnum]


  export const CashShopDataScalarFieldEnum: {
    AccountID: 'AccountID',
    WCoinC: 'WCoinC',
    WCoinP: 'WCoinP',
    GoblinPoint: 'GoblinPoint'
  };

  export type CashShopDataScalarFieldEnum = (typeof CashShopDataScalarFieldEnum)[keyof typeof CashShopDataScalarFieldEnum]


  export const CashShopInventoryScalarFieldEnum: {
    BaseItemCode: 'BaseItemCode',
    MainItemCode: 'MainItemCode',
    AccountID: 'AccountID',
    InventoryType: 'InventoryType',
    PackageMainIndex: 'PackageMainIndex',
    ProductBaseIndex: 'ProductBaseIndex',
    ProductMainIndex: 'ProductMainIndex',
    CoinValue: 'CoinValue',
    ProductType: 'ProductType',
    GiftName: 'GiftName',
    GiftText: 'GiftText'
  };

  export type CashShopInventoryScalarFieldEnum = (typeof CashShopInventoryScalarFieldEnum)[keyof typeof CashShopInventoryScalarFieldEnum]


  export const CashShopPeriodicItemScalarFieldEnum: {
    ItemSerial: 'ItemSerial',
    Time: 'Time'
  };

  export type CashShopPeriodicItemScalarFieldEnum = (typeof CashShopPeriodicItemScalarFieldEnum)[keyof typeof CashShopPeriodicItemScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    AccountID: 'AccountID',
    Name: 'Name',
    cLevel: 'cLevel',
    LevelUpPoint: 'LevelUpPoint',
    Class: 'Class',
    Experience: 'Experience',
    Strength: 'Strength',
    Dexterity: 'Dexterity',
    Vitality: 'Vitality',
    Energy: 'Energy',
    Leadership: 'Leadership',
    Inventory: 'Inventory',
    MagicList: 'MagicList',
    Money: 'Money',
    Life: 'Life',
    MaxLife: 'MaxLife',
    Mana: 'Mana',
    MaxMana: 'MaxMana',
    BP: 'BP',
    MaxBP: 'MaxBP',
    Shield: 'Shield',
    MaxShield: 'MaxShield',
    MapNumber: 'MapNumber',
    MapPosX: 'MapPosX',
    MapPosY: 'MapPosY',
    MapDir: 'MapDir',
    PkCount: 'PkCount',
    PkLevel: 'PkLevel',
    PkTime: 'PkTime',
    MDate: 'MDate',
    LDate: 'LDate',
    CtlCode: 'CtlCode',
    DbVersion: 'DbVersion',
    Quest: 'Quest',
    ChatLimitTime: 'ChatLimitTime',
    FruitPoint: 'FruitPoint',
    EffectList: 'EffectList',
    FruitAddPoint: 'FruitAddPoint',
    FruitSubPoint: 'FruitSubPoint',
    ResetCount: 'ResetCount',
    MasterResetCount: 'MasterResetCount',
    ExtInventory: 'ExtInventory',
    Resets: 'Resets',
    ResetsDay: 'ResetsDay',
    ResetsWeek: 'ResetsWeek',
    ResetsMonth: 'ResetsMonth',
    MResets: 'MResets',
    MResetsDay: 'MResetsDay',
    MResetsWeek: 'MResetsWeek',
    MResetsMonth: 'MResetsMonth',
    PKTotal: 'PKTotal',
    PKDay: 'PKDay',
    PKWeek: 'PKWeek',
    PKMonth: 'PKMonth',
    HeroTotal: 'HeroTotal',
    HeroDay: 'HeroDay',
    HeroWeek: 'HeroWeek',
    HeroMonth: 'HeroMonth',
    tradewins: 'tradewins',
    matamata: 'matamata',
    duel_total: 'duel_total',
    duel_semanal: 'duel_semanal',
    duel_mensal: 'duel_mensal'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const DefaultClassTypeScalarFieldEnum: {
    Class: 'Class',
    Level: 'Level',
    LevelUpPoint: 'LevelUpPoint',
    Strength: 'Strength',
    Dexterity: 'Dexterity',
    Vitality: 'Vitality',
    Energy: 'Energy',
    Leadership: 'Leadership',
    Inventory: 'Inventory',
    MagicList: 'MagicList',
    Life: 'Life',
    MaxLife: 'MaxLife',
    Mana: 'Mana',
    MaxMana: 'MaxMana',
    MapNumber: 'MapNumber',
    MapPosX: 'MapPosX',
    MapPosY: 'MapPosY',
    Quest: 'Quest',
    DbVersion: 'DbVersion',
    EffectList: 'EffectList'
  };

  export type DefaultClassTypeScalarFieldEnum = (typeof DefaultClassTypeScalarFieldEnum)[keyof typeof DefaultClassTypeScalarFieldEnum]


  export const EventLeoTheHelperScalarFieldEnum: {
    Name: 'Name',
    Status: 'Status'
  };

  export type EventLeoTheHelperScalarFieldEnum = (typeof EventLeoTheHelperScalarFieldEnum)[keyof typeof EventLeoTheHelperScalarFieldEnum]


  export const EventSantaClausScalarFieldEnum: {
    Name: 'Name',
    Status: 'Status'
  };

  export type EventSantaClausScalarFieldEnum = (typeof EventSantaClausScalarFieldEnum)[keyof typeof EventSantaClausScalarFieldEnum]


  export const GameServerInfoScalarFieldEnum: {
    Number: 'Number',
    ItemCount: 'ItemCount',
    ZenCount: 'ZenCount',
    AceItemCount: 'AceItemCount'
  };

  export type GameServerInfoScalarFieldEnum = (typeof GameServerInfoScalarFieldEnum)[keyof typeof GameServerInfoScalarFieldEnum]


  export const Gens_RankScalarFieldEnum: {
    Name: 'Name',
    Family: 'Family',
    Contribution: 'Contribution'
  };

  export type Gens_RankScalarFieldEnum = (typeof Gens_RankScalarFieldEnum)[keyof typeof Gens_RankScalarFieldEnum]


  export const Gens_RewardScalarFieldEnum: {
    Name: 'Name',
    Rank: 'Rank',
    Status: 'Status'
  };

  export type Gens_RewardScalarFieldEnum = (typeof Gens_RewardScalarFieldEnum)[keyof typeof Gens_RewardScalarFieldEnum]


  export const GuildScalarFieldEnum: {
    G_Name: 'G_Name',
    G_Mark: 'G_Mark',
    G_Score: 'G_Score',
    G_Master: 'G_Master',
    G_Count: 'G_Count',
    G_Notice: 'G_Notice',
    Number: 'Number',
    G_Type: 'G_Type',
    G_Rival: 'G_Rival',
    G_Union: 'G_Union',
    MemberCount: 'MemberCount'
  };

  export type GuildScalarFieldEnum = (typeof GuildScalarFieldEnum)[keyof typeof GuildScalarFieldEnum]


  export const GuildMemberScalarFieldEnum: {
    Name: 'Name',
    G_Name: 'G_Name',
    G_Level: 'G_Level',
    G_Status: 'G_Status'
  };

  export type GuildMemberScalarFieldEnum = (typeof GuildMemberScalarFieldEnum)[keyof typeof GuildMemberScalarFieldEnum]


  export const HelperDataScalarFieldEnum: {
    Name: 'Name',
    Data: 'Data'
  };

  export type HelperDataScalarFieldEnum = (typeof HelperDataScalarFieldEnum)[keyof typeof HelperDataScalarFieldEnum]


  export const LuckyCoinScalarFieldEnum: {
    AccountID: 'AccountID',
    LuckyCoin: 'LuckyCoin'
  };

  export type LuckyCoinScalarFieldEnum = (typeof LuckyCoinScalarFieldEnum)[keyof typeof LuckyCoinScalarFieldEnum]


  export const LuckyItemScalarFieldEnum: {
    ItemSerial: 'ItemSerial',
    DurabilitySmall: 'DurabilitySmall'
  };

  export type LuckyItemScalarFieldEnum = (typeof LuckyItemScalarFieldEnum)[keyof typeof LuckyItemScalarFieldEnum]


  export const MEMB_STATScalarFieldEnum: {
    memb___id: 'memb___id',
    ConnectStat: 'ConnectStat',
    ServerName: 'ServerName',
    IP: 'IP',
    ConnectTM: 'ConnectTM',
    DisConnectTM: 'DisConnectTM',
    OnlineHours: 'OnlineHours',
    HWID: 'HWID'
  };

  export type MEMB_STATScalarFieldEnum = (typeof MEMB_STATScalarFieldEnum)[keyof typeof MEMB_STATScalarFieldEnum]


  export const MasterSkillTreeScalarFieldEnum: {
    Name: 'Name',
    MasterLevel: 'MasterLevel',
    MasterPoint: 'MasterPoint',
    MasterExperience: 'MasterExperience',
    MasterSkill: 'MasterSkill'
  };

  export type MasterSkillTreeScalarFieldEnum = (typeof MasterSkillTreeScalarFieldEnum)[keyof typeof MasterSkillTreeScalarFieldEnum]


  export const MuCastle_DATAScalarFieldEnum: {
    MAP_SVR_GROUP: 'MAP_SVR_GROUP',
    SIEGE_START_DATE: 'SIEGE_START_DATE',
    SIEGE_END_DATE: 'SIEGE_END_DATE',
    SIEGE_GUILDLIST_SETTED: 'SIEGE_GUILDLIST_SETTED',
    SIEGE_ENDED: 'SIEGE_ENDED',
    CASTLE_OCCUPY: 'CASTLE_OCCUPY',
    OWNER_GUILD: 'OWNER_GUILD',
    MONEY: 'MONEY',
    TAX_RATE_CHAOS: 'TAX_RATE_CHAOS',
    TAX_RATE_STORE: 'TAX_RATE_STORE',
    TAX_HUNT_ZONE: 'TAX_HUNT_ZONE'
  };

  export type MuCastle_DATAScalarFieldEnum = (typeof MuCastle_DATAScalarFieldEnum)[keyof typeof MuCastle_DATAScalarFieldEnum]


  export const MuCastle_NPCScalarFieldEnum: {
    MAP_SVR_GROUP: 'MAP_SVR_GROUP',
    NPC_NUMBER: 'NPC_NUMBER',
    NPC_INDEX: 'NPC_INDEX',
    NPC_DF_LEVEL: 'NPC_DF_LEVEL',
    NPC_RG_LEVEL: 'NPC_RG_LEVEL',
    NPC_MAXHP: 'NPC_MAXHP',
    NPC_HP: 'NPC_HP',
    NPC_X: 'NPC_X',
    NPC_Y: 'NPC_Y',
    NPC_DIR: 'NPC_DIR',
    NPC_CREATEDATE: 'NPC_CREATEDATE'
  };

  export type MuCastle_NPCScalarFieldEnum = (typeof MuCastle_NPCScalarFieldEnum)[keyof typeof MuCastle_NPCScalarFieldEnum]


  export const MuCastle_REG_SIEGEScalarFieldEnum: {
    MAP_SVR_GROUP: 'MAP_SVR_GROUP',
    REG_SIEGE_GUILD: 'REG_SIEGE_GUILD',
    REG_MARKS: 'REG_MARKS',
    IS_GIVEUP: 'IS_GIVEUP',
    SEQ_NUM: 'SEQ_NUM'
  };

  export type MuCastle_REG_SIEGEScalarFieldEnum = (typeof MuCastle_REG_SIEGEScalarFieldEnum)[keyof typeof MuCastle_REG_SIEGEScalarFieldEnum]


  export const OptionDataScalarFieldEnum: {
    Name: 'Name',
    SkillKey: 'SkillKey',
    GameOption: 'GameOption',
    Qkey: 'Qkey',
    Wkey: 'Wkey',
    Ekey: 'Ekey',
    ChatWindow: 'ChatWindow',
    Rkey: 'Rkey',
    QWERLevel: 'QWERLevel'
  };

  export type OptionDataScalarFieldEnum = (typeof OptionDataScalarFieldEnum)[keyof typeof OptionDataScalarFieldEnum]


  export const QuestKillCountScalarFieldEnum: {
    Name: 'Name',
    QuestIndex: 'QuestIndex',
    MonsterClass1: 'MonsterClass1',
    KillCount1: 'KillCount1',
    MonsterClass2: 'MonsterClass2',
    KillCount2: 'KillCount2',
    MonsterClass3: 'MonsterClass3',
    KillCount3: 'KillCount3',
    MonsterClass4: 'MonsterClass4',
    KillCount4: 'KillCount4',
    MonsterClass5: 'MonsterClass5',
    KillCount5: 'KillCount5'
  };

  export type QuestKillCountScalarFieldEnum = (typeof QuestKillCountScalarFieldEnum)[keyof typeof QuestKillCountScalarFieldEnum]


  export const QuestWorldScalarFieldEnum: {
    Name: 'Name',
    QuestWorldList: 'QuestWorldList'
  };

  export type QuestWorldScalarFieldEnum = (typeof QuestWorldScalarFieldEnum)[keyof typeof QuestWorldScalarFieldEnum]


  export const RankingBloodCastleScalarFieldEnum: {
    Name: 'Name',
    Score: 'Score'
  };

  export type RankingBloodCastleScalarFieldEnum = (typeof RankingBloodCastleScalarFieldEnum)[keyof typeof RankingBloodCastleScalarFieldEnum]


  export const RankingChaosCastleScalarFieldEnum: {
    Name: 'Name',
    Score: 'Score'
  };

  export type RankingChaosCastleScalarFieldEnum = (typeof RankingChaosCastleScalarFieldEnum)[keyof typeof RankingChaosCastleScalarFieldEnum]


  export const RankingDevilSquareScalarFieldEnum: {
    Name: 'Name',
    Score: 'Score'
  };

  export type RankingDevilSquareScalarFieldEnum = (typeof RankingDevilSquareScalarFieldEnum)[keyof typeof RankingDevilSquareScalarFieldEnum]


  export const RankingDuelScalarFieldEnum: {
    Name: 'Name',
    WinScore: 'WinScore',
    LoseScore: 'LoseScore'
  };

  export type RankingDuelScalarFieldEnum = (typeof RankingDuelScalarFieldEnum)[keyof typeof RankingDuelScalarFieldEnum]


  export const RankingIllusionTempleScalarFieldEnum: {
    Name: 'Name',
    Score: 'Score'
  };

  export type RankingIllusionTempleScalarFieldEnum = (typeof RankingIllusionTempleScalarFieldEnum)[keyof typeof RankingIllusionTempleScalarFieldEnum]


  export const T_CGuidScalarFieldEnum: {
    GUID: 'GUID',
    Name: 'Name'
  };

  export type T_CGuidScalarFieldEnum = (typeof T_CGuidScalarFieldEnum)[keyof typeof T_CGuidScalarFieldEnum]


  export const T_FriendMailScalarFieldEnum: {
    MemoIndex: 'MemoIndex',
    GUID: 'GUID',
    FriendName: 'FriendName',
    wDate: 'wDate',
    Subject: 'Subject',
    bRead: 'bRead',
    Memo: 'Memo',
    Photo: 'Photo',
    Dir: 'Dir',
    Act: 'Act'
  };

  export type T_FriendMailScalarFieldEnum = (typeof T_FriendMailScalarFieldEnum)[keyof typeof T_FriendMailScalarFieldEnum]


  export const T_FriendMainScalarFieldEnum: {
    GUID: 'GUID',
    Name: 'Name',
    FriendCount: 'FriendCount',
    MemoCount: 'MemoCount',
    MemoTotal: 'MemoTotal'
  };

  export type T_FriendMainScalarFieldEnum = (typeof T_FriendMainScalarFieldEnum)[keyof typeof T_FriendMainScalarFieldEnum]


  export const T_PetItem_InfoScalarFieldEnum: {
    ItemSerial: 'ItemSerial',
    Pet_Level: 'Pet_Level',
    Pet_Exp: 'Pet_Exp'
  };

  export type T_PetItem_InfoScalarFieldEnum = (typeof T_PetItem_InfoScalarFieldEnum)[keyof typeof T_PetItem_InfoScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    AccountID: 'AccountID',
    Items: 'Items',
    Money: 'Money',
    EndUseDate: 'EndUseDate',
    DbVersion: 'DbVersion',
    pw: 'pw',
    VaultCounts: 'VaultCounts',
    LastVaultID: 'LastVaultID'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
  }

  export type MEMB_INFOWhereInput = {
    AND?: MEMB_INFOWhereInput | MEMB_INFOWhereInput[]
    OR?: MEMB_INFOWhereInput[]
    NOT?: MEMB_INFOWhereInput | MEMB_INFOWhereInput[]
    memb_guid?: IntFilter<"MEMB_INFO"> | number
    memb___id?: StringFilter<"MEMB_INFO"> | string
    memb__pwd?: StringFilter<"MEMB_INFO"> | string
    memb_name?: StringFilter<"MEMB_INFO"> | string
    sno__numb?: StringFilter<"MEMB_INFO"> | string
    post_code?: StringNullableFilter<"MEMB_INFO"> | string | null
    addr_info?: StringNullableFilter<"MEMB_INFO"> | string | null
    addr_deta?: StringNullableFilter<"MEMB_INFO"> | string | null
    tel__numb?: StringNullableFilter<"MEMB_INFO"> | string | null
    phon_numb?: StringNullableFilter<"MEMB_INFO"> | string | null
    mail_addr?: StringNullableFilter<"MEMB_INFO"> | string | null
    fpas_ques?: StringNullableFilter<"MEMB_INFO"> | string | null
    fpas_answ?: StringNullableFilter<"MEMB_INFO"> | string | null
    job__code?: StringNullableFilter<"MEMB_INFO"> | string | null
    appl_days?: DateTimeNullableFilter<"MEMB_INFO"> | Date | string | null
    modi_days?: DateTimeNullableFilter<"MEMB_INFO"> | Date | string | null
    out__days?: DateTimeNullableFilter<"MEMB_INFO"> | Date | string | null
    true_days?: DateTimeNullableFilter<"MEMB_INFO"> | Date | string | null
    mail_chek?: StringNullableFilter<"MEMB_INFO"> | string | null
    bloc_code?: StringFilter<"MEMB_INFO"> | string
    ctl1_code?: StringFilter<"MEMB_INFO"> | string
    AccountLevel?: IntFilter<"MEMB_INFO"> | number
    AccountExpireDate?: DateTimeFilter<"MEMB_INFO"> | Date | string
    vip?: IntFilter<"MEMB_INFO"> | number
    cash?: IntFilter<"MEMB_INFO"> | number
    RewardPlayer?: IntFilter<"MEMB_INFO"> | number
    ChaosPoints?: IntFilter<"MEMB_INFO"> | number
    BlessPoints?: IntFilter<"MEMB_INFO"> | number
    SoulPoints?: IntFilter<"MEMB_INFO"> | number
    LifePoints?: IntFilter<"MEMB_INFO"> | number
    CreationPoints?: IntFilter<"MEMB_INFO"> | number
    GuardianPoints?: IntFilter<"MEMB_INFO"> | number
    GemstonePoints?: IntFilter<"MEMB_INFO"> | number
    HarmonyPoints?: IntFilter<"MEMB_INFO"> | number
    LRefiningPoints?: IntFilter<"MEMB_INFO"> | number
    HRefiningPoints?: IntFilter<"MEMB_INFO"> | number
    LockPassword?: IntFilter<"MEMB_INFO"> | number
  }

  export type MEMB_INFOOrderByWithRelationInput = {
    memb_guid?: SortOrder
    memb___id?: SortOrder
    memb__pwd?: SortOrder
    memb_name?: SortOrder
    sno__numb?: SortOrder
    post_code?: SortOrderInput | SortOrder
    addr_info?: SortOrderInput | SortOrder
    addr_deta?: SortOrderInput | SortOrder
    tel__numb?: SortOrderInput | SortOrder
    phon_numb?: SortOrderInput | SortOrder
    mail_addr?: SortOrderInput | SortOrder
    fpas_ques?: SortOrderInput | SortOrder
    fpas_answ?: SortOrderInput | SortOrder
    job__code?: SortOrderInput | SortOrder
    appl_days?: SortOrderInput | SortOrder
    modi_days?: SortOrderInput | SortOrder
    out__days?: SortOrderInput | SortOrder
    true_days?: SortOrderInput | SortOrder
    mail_chek?: SortOrderInput | SortOrder
    bloc_code?: SortOrder
    ctl1_code?: SortOrder
    AccountLevel?: SortOrder
    AccountExpireDate?: SortOrder
    vip?: SortOrder
    cash?: SortOrder
    RewardPlayer?: SortOrder
    ChaosPoints?: SortOrder
    BlessPoints?: SortOrder
    SoulPoints?: SortOrder
    LifePoints?: SortOrder
    CreationPoints?: SortOrder
    GuardianPoints?: SortOrder
    GemstonePoints?: SortOrder
    HarmonyPoints?: SortOrder
    LRefiningPoints?: SortOrder
    HRefiningPoints?: SortOrder
    LockPassword?: SortOrder
  }

  export type MEMB_INFOWhereUniqueInput = Prisma.AtLeast<{
    memb_guid?: number
    AND?: MEMB_INFOWhereInput | MEMB_INFOWhereInput[]
    OR?: MEMB_INFOWhereInput[]
    NOT?: MEMB_INFOWhereInput | MEMB_INFOWhereInput[]
    memb___id?: StringFilter<"MEMB_INFO"> | string
    memb__pwd?: StringFilter<"MEMB_INFO"> | string
    memb_name?: StringFilter<"MEMB_INFO"> | string
    sno__numb?: StringFilter<"MEMB_INFO"> | string
    post_code?: StringNullableFilter<"MEMB_INFO"> | string | null
    addr_info?: StringNullableFilter<"MEMB_INFO"> | string | null
    addr_deta?: StringNullableFilter<"MEMB_INFO"> | string | null
    tel__numb?: StringNullableFilter<"MEMB_INFO"> | string | null
    phon_numb?: StringNullableFilter<"MEMB_INFO"> | string | null
    mail_addr?: StringNullableFilter<"MEMB_INFO"> | string | null
    fpas_ques?: StringNullableFilter<"MEMB_INFO"> | string | null
    fpas_answ?: StringNullableFilter<"MEMB_INFO"> | string | null
    job__code?: StringNullableFilter<"MEMB_INFO"> | string | null
    appl_days?: DateTimeNullableFilter<"MEMB_INFO"> | Date | string | null
    modi_days?: DateTimeNullableFilter<"MEMB_INFO"> | Date | string | null
    out__days?: DateTimeNullableFilter<"MEMB_INFO"> | Date | string | null
    true_days?: DateTimeNullableFilter<"MEMB_INFO"> | Date | string | null
    mail_chek?: StringNullableFilter<"MEMB_INFO"> | string | null
    bloc_code?: StringFilter<"MEMB_INFO"> | string
    ctl1_code?: StringFilter<"MEMB_INFO"> | string
    AccountLevel?: IntFilter<"MEMB_INFO"> | number
    AccountExpireDate?: DateTimeFilter<"MEMB_INFO"> | Date | string
    vip?: IntFilter<"MEMB_INFO"> | number
    cash?: IntFilter<"MEMB_INFO"> | number
    RewardPlayer?: IntFilter<"MEMB_INFO"> | number
    ChaosPoints?: IntFilter<"MEMB_INFO"> | number
    BlessPoints?: IntFilter<"MEMB_INFO"> | number
    SoulPoints?: IntFilter<"MEMB_INFO"> | number
    LifePoints?: IntFilter<"MEMB_INFO"> | number
    CreationPoints?: IntFilter<"MEMB_INFO"> | number
    GuardianPoints?: IntFilter<"MEMB_INFO"> | number
    GemstonePoints?: IntFilter<"MEMB_INFO"> | number
    HarmonyPoints?: IntFilter<"MEMB_INFO"> | number
    LRefiningPoints?: IntFilter<"MEMB_INFO"> | number
    HRefiningPoints?: IntFilter<"MEMB_INFO"> | number
    LockPassword?: IntFilter<"MEMB_INFO"> | number
  }, "memb_guid">

  export type MEMB_INFOOrderByWithAggregationInput = {
    memb_guid?: SortOrder
    memb___id?: SortOrder
    memb__pwd?: SortOrder
    memb_name?: SortOrder
    sno__numb?: SortOrder
    post_code?: SortOrderInput | SortOrder
    addr_info?: SortOrderInput | SortOrder
    addr_deta?: SortOrderInput | SortOrder
    tel__numb?: SortOrderInput | SortOrder
    phon_numb?: SortOrderInput | SortOrder
    mail_addr?: SortOrderInput | SortOrder
    fpas_ques?: SortOrderInput | SortOrder
    fpas_answ?: SortOrderInput | SortOrder
    job__code?: SortOrderInput | SortOrder
    appl_days?: SortOrderInput | SortOrder
    modi_days?: SortOrderInput | SortOrder
    out__days?: SortOrderInput | SortOrder
    true_days?: SortOrderInput | SortOrder
    mail_chek?: SortOrderInput | SortOrder
    bloc_code?: SortOrder
    ctl1_code?: SortOrder
    AccountLevel?: SortOrder
    AccountExpireDate?: SortOrder
    vip?: SortOrder
    cash?: SortOrder
    RewardPlayer?: SortOrder
    ChaosPoints?: SortOrder
    BlessPoints?: SortOrder
    SoulPoints?: SortOrder
    LifePoints?: SortOrder
    CreationPoints?: SortOrder
    GuardianPoints?: SortOrder
    GemstonePoints?: SortOrder
    HarmonyPoints?: SortOrder
    LRefiningPoints?: SortOrder
    HRefiningPoints?: SortOrder
    LockPassword?: SortOrder
    _count?: MEMB_INFOCountOrderByAggregateInput
    _avg?: MEMB_INFOAvgOrderByAggregateInput
    _max?: MEMB_INFOMaxOrderByAggregateInput
    _min?: MEMB_INFOMinOrderByAggregateInput
    _sum?: MEMB_INFOSumOrderByAggregateInput
  }

  export type MEMB_INFOScalarWhereWithAggregatesInput = {
    AND?: MEMB_INFOScalarWhereWithAggregatesInput | MEMB_INFOScalarWhereWithAggregatesInput[]
    OR?: MEMB_INFOScalarWhereWithAggregatesInput[]
    NOT?: MEMB_INFOScalarWhereWithAggregatesInput | MEMB_INFOScalarWhereWithAggregatesInput[]
    memb_guid?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    memb___id?: StringWithAggregatesFilter<"MEMB_INFO"> | string
    memb__pwd?: StringWithAggregatesFilter<"MEMB_INFO"> | string
    memb_name?: StringWithAggregatesFilter<"MEMB_INFO"> | string
    sno__numb?: StringWithAggregatesFilter<"MEMB_INFO"> | string
    post_code?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    addr_info?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    addr_deta?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    tel__numb?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    phon_numb?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    mail_addr?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    fpas_ques?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    fpas_answ?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    job__code?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    appl_days?: DateTimeNullableWithAggregatesFilter<"MEMB_INFO"> | Date | string | null
    modi_days?: DateTimeNullableWithAggregatesFilter<"MEMB_INFO"> | Date | string | null
    out__days?: DateTimeNullableWithAggregatesFilter<"MEMB_INFO"> | Date | string | null
    true_days?: DateTimeNullableWithAggregatesFilter<"MEMB_INFO"> | Date | string | null
    mail_chek?: StringNullableWithAggregatesFilter<"MEMB_INFO"> | string | null
    bloc_code?: StringWithAggregatesFilter<"MEMB_INFO"> | string
    ctl1_code?: StringWithAggregatesFilter<"MEMB_INFO"> | string
    AccountLevel?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    AccountExpireDate?: DateTimeWithAggregatesFilter<"MEMB_INFO"> | Date | string
    vip?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    cash?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    RewardPlayer?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    ChaosPoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    BlessPoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    SoulPoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    LifePoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    CreationPoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    GuardianPoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    GemstonePoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    HarmonyPoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    LRefiningPoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    HRefiningPoints?: IntWithAggregatesFilter<"MEMB_INFO"> | number
    LockPassword?: IntWithAggregatesFilter<"MEMB_INFO"> | number
  }

  export type AccountCharacterWhereInput = {
    AND?: AccountCharacterWhereInput | AccountCharacterWhereInput[]
    OR?: AccountCharacterWhereInput[]
    NOT?: AccountCharacterWhereInput | AccountCharacterWhereInput[]
    Number?: IntFilter<"AccountCharacter"> | number
    Id?: StringFilter<"AccountCharacter"> | string
    GameID1?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID2?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID3?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID4?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID5?: StringNullableFilter<"AccountCharacter"> | string | null
    GameIDC?: StringNullableFilter<"AccountCharacter"> | string | null
    MoveCnt?: IntNullableFilter<"AccountCharacter"> | number | null
    ExtClass?: IntFilter<"AccountCharacter"> | number
    ExtWarehouse?: IntFilter<"AccountCharacter"> | number
    GameID6?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID7?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID8?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID9?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID10?: StringNullableFilter<"AccountCharacter"> | string | null
    MaxCharacter?: IntFilter<"AccountCharacter"> | number
  }

  export type AccountCharacterOrderByWithRelationInput = {
    Number?: SortOrder
    Id?: SortOrder
    GameID1?: SortOrderInput | SortOrder
    GameID2?: SortOrderInput | SortOrder
    GameID3?: SortOrderInput | SortOrder
    GameID4?: SortOrderInput | SortOrder
    GameID5?: SortOrderInput | SortOrder
    GameIDC?: SortOrderInput | SortOrder
    MoveCnt?: SortOrderInput | SortOrder
    ExtClass?: SortOrder
    ExtWarehouse?: SortOrder
    GameID6?: SortOrderInput | SortOrder
    GameID7?: SortOrderInput | SortOrder
    GameID8?: SortOrderInput | SortOrder
    GameID9?: SortOrderInput | SortOrder
    GameID10?: SortOrderInput | SortOrder
    MaxCharacter?: SortOrder
  }

  export type AccountCharacterWhereUniqueInput = Prisma.AtLeast<{
    Id?: string
    AND?: AccountCharacterWhereInput | AccountCharacterWhereInput[]
    OR?: AccountCharacterWhereInput[]
    NOT?: AccountCharacterWhereInput | AccountCharacterWhereInput[]
    Number?: IntFilter<"AccountCharacter"> | number
    GameID1?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID2?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID3?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID4?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID5?: StringNullableFilter<"AccountCharacter"> | string | null
    GameIDC?: StringNullableFilter<"AccountCharacter"> | string | null
    MoveCnt?: IntNullableFilter<"AccountCharacter"> | number | null
    ExtClass?: IntFilter<"AccountCharacter"> | number
    ExtWarehouse?: IntFilter<"AccountCharacter"> | number
    GameID6?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID7?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID8?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID9?: StringNullableFilter<"AccountCharacter"> | string | null
    GameID10?: StringNullableFilter<"AccountCharacter"> | string | null
    MaxCharacter?: IntFilter<"AccountCharacter"> | number
  }, "Id">

  export type AccountCharacterOrderByWithAggregationInput = {
    Number?: SortOrder
    Id?: SortOrder
    GameID1?: SortOrderInput | SortOrder
    GameID2?: SortOrderInput | SortOrder
    GameID3?: SortOrderInput | SortOrder
    GameID4?: SortOrderInput | SortOrder
    GameID5?: SortOrderInput | SortOrder
    GameIDC?: SortOrderInput | SortOrder
    MoveCnt?: SortOrderInput | SortOrder
    ExtClass?: SortOrder
    ExtWarehouse?: SortOrder
    GameID6?: SortOrderInput | SortOrder
    GameID7?: SortOrderInput | SortOrder
    GameID8?: SortOrderInput | SortOrder
    GameID9?: SortOrderInput | SortOrder
    GameID10?: SortOrderInput | SortOrder
    MaxCharacter?: SortOrder
    _count?: AccountCharacterCountOrderByAggregateInput
    _avg?: AccountCharacterAvgOrderByAggregateInput
    _max?: AccountCharacterMaxOrderByAggregateInput
    _min?: AccountCharacterMinOrderByAggregateInput
    _sum?: AccountCharacterSumOrderByAggregateInput
  }

  export type AccountCharacterScalarWhereWithAggregatesInput = {
    AND?: AccountCharacterScalarWhereWithAggregatesInput | AccountCharacterScalarWhereWithAggregatesInput[]
    OR?: AccountCharacterScalarWhereWithAggregatesInput[]
    NOT?: AccountCharacterScalarWhereWithAggregatesInput | AccountCharacterScalarWhereWithAggregatesInput[]
    Number?: IntWithAggregatesFilter<"AccountCharacter"> | number
    Id?: StringWithAggregatesFilter<"AccountCharacter"> | string
    GameID1?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameID2?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameID3?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameID4?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameID5?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameIDC?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    MoveCnt?: IntNullableWithAggregatesFilter<"AccountCharacter"> | number | null
    ExtClass?: IntWithAggregatesFilter<"AccountCharacter"> | number
    ExtWarehouse?: IntWithAggregatesFilter<"AccountCharacter"> | number
    GameID6?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameID7?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameID8?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameID9?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    GameID10?: StringNullableWithAggregatesFilter<"AccountCharacter"> | string | null
    MaxCharacter?: IntWithAggregatesFilter<"AccountCharacter"> | number
  }

  export type CashShopDataWhereInput = {
    AND?: CashShopDataWhereInput | CashShopDataWhereInput[]
    OR?: CashShopDataWhereInput[]
    NOT?: CashShopDataWhereInput | CashShopDataWhereInput[]
    AccountID?: StringFilter<"CashShopData"> | string
    WCoinC?: IntNullableFilter<"CashShopData"> | number | null
    WCoinP?: IntNullableFilter<"CashShopData"> | number | null
    GoblinPoint?: IntNullableFilter<"CashShopData"> | number | null
  }

  export type CashShopDataOrderByWithRelationInput = {
    AccountID?: SortOrder
    WCoinC?: SortOrderInput | SortOrder
    WCoinP?: SortOrderInput | SortOrder
    GoblinPoint?: SortOrderInput | SortOrder
  }

  export type CashShopDataWhereUniqueInput = Prisma.AtLeast<{
    AccountID?: string
    AND?: CashShopDataWhereInput | CashShopDataWhereInput[]
    OR?: CashShopDataWhereInput[]
    NOT?: CashShopDataWhereInput | CashShopDataWhereInput[]
    WCoinC?: IntNullableFilter<"CashShopData"> | number | null
    WCoinP?: IntNullableFilter<"CashShopData"> | number | null
    GoblinPoint?: IntNullableFilter<"CashShopData"> | number | null
  }, "AccountID">

  export type CashShopDataOrderByWithAggregationInput = {
    AccountID?: SortOrder
    WCoinC?: SortOrderInput | SortOrder
    WCoinP?: SortOrderInput | SortOrder
    GoblinPoint?: SortOrderInput | SortOrder
    _count?: CashShopDataCountOrderByAggregateInput
    _avg?: CashShopDataAvgOrderByAggregateInput
    _max?: CashShopDataMaxOrderByAggregateInput
    _min?: CashShopDataMinOrderByAggregateInput
    _sum?: CashShopDataSumOrderByAggregateInput
  }

  export type CashShopDataScalarWhereWithAggregatesInput = {
    AND?: CashShopDataScalarWhereWithAggregatesInput | CashShopDataScalarWhereWithAggregatesInput[]
    OR?: CashShopDataScalarWhereWithAggregatesInput[]
    NOT?: CashShopDataScalarWhereWithAggregatesInput | CashShopDataScalarWhereWithAggregatesInput[]
    AccountID?: StringWithAggregatesFilter<"CashShopData"> | string
    WCoinC?: IntNullableWithAggregatesFilter<"CashShopData"> | number | null
    WCoinP?: IntNullableWithAggregatesFilter<"CashShopData"> | number | null
    GoblinPoint?: IntNullableWithAggregatesFilter<"CashShopData"> | number | null
  }

  export type CashShopInventoryWhereInput = {
    AND?: CashShopInventoryWhereInput | CashShopInventoryWhereInput[]
    OR?: CashShopInventoryWhereInput[]
    NOT?: CashShopInventoryWhereInput | CashShopInventoryWhereInput[]
    BaseItemCode?: IntFilter<"CashShopInventory"> | number
    MainItemCode?: IntNullableFilter<"CashShopInventory"> | number | null
    AccountID?: StringNullableFilter<"CashShopInventory"> | string | null
    InventoryType?: IntNullableFilter<"CashShopInventory"> | number | null
    PackageMainIndex?: IntNullableFilter<"CashShopInventory"> | number | null
    ProductBaseIndex?: IntNullableFilter<"CashShopInventory"> | number | null
    ProductMainIndex?: IntNullableFilter<"CashShopInventory"> | number | null
    CoinValue?: FloatNullableFilter<"CashShopInventory"> | number | null
    ProductType?: IntNullableFilter<"CashShopInventory"> | number | null
    GiftName?: StringNullableFilter<"CashShopInventory"> | string | null
    GiftText?: StringNullableFilter<"CashShopInventory"> | string | null
  }

  export type CashShopInventoryOrderByWithRelationInput = {
    BaseItemCode?: SortOrder
    MainItemCode?: SortOrderInput | SortOrder
    AccountID?: SortOrderInput | SortOrder
    InventoryType?: SortOrderInput | SortOrder
    PackageMainIndex?: SortOrderInput | SortOrder
    ProductBaseIndex?: SortOrderInput | SortOrder
    ProductMainIndex?: SortOrderInput | SortOrder
    CoinValue?: SortOrderInput | SortOrder
    ProductType?: SortOrderInput | SortOrder
    GiftName?: SortOrderInput | SortOrder
    GiftText?: SortOrderInput | SortOrder
  }

  export type CashShopInventoryWhereUniqueInput = Prisma.AtLeast<{
    BaseItemCode?: number
    AND?: CashShopInventoryWhereInput | CashShopInventoryWhereInput[]
    OR?: CashShopInventoryWhereInput[]
    NOT?: CashShopInventoryWhereInput | CashShopInventoryWhereInput[]
    MainItemCode?: IntNullableFilter<"CashShopInventory"> | number | null
    AccountID?: StringNullableFilter<"CashShopInventory"> | string | null
    InventoryType?: IntNullableFilter<"CashShopInventory"> | number | null
    PackageMainIndex?: IntNullableFilter<"CashShopInventory"> | number | null
    ProductBaseIndex?: IntNullableFilter<"CashShopInventory"> | number | null
    ProductMainIndex?: IntNullableFilter<"CashShopInventory"> | number | null
    CoinValue?: FloatNullableFilter<"CashShopInventory"> | number | null
    ProductType?: IntNullableFilter<"CashShopInventory"> | number | null
    GiftName?: StringNullableFilter<"CashShopInventory"> | string | null
    GiftText?: StringNullableFilter<"CashShopInventory"> | string | null
  }, "BaseItemCode">

  export type CashShopInventoryOrderByWithAggregationInput = {
    BaseItemCode?: SortOrder
    MainItemCode?: SortOrderInput | SortOrder
    AccountID?: SortOrderInput | SortOrder
    InventoryType?: SortOrderInput | SortOrder
    PackageMainIndex?: SortOrderInput | SortOrder
    ProductBaseIndex?: SortOrderInput | SortOrder
    ProductMainIndex?: SortOrderInput | SortOrder
    CoinValue?: SortOrderInput | SortOrder
    ProductType?: SortOrderInput | SortOrder
    GiftName?: SortOrderInput | SortOrder
    GiftText?: SortOrderInput | SortOrder
    _count?: CashShopInventoryCountOrderByAggregateInput
    _avg?: CashShopInventoryAvgOrderByAggregateInput
    _max?: CashShopInventoryMaxOrderByAggregateInput
    _min?: CashShopInventoryMinOrderByAggregateInput
    _sum?: CashShopInventorySumOrderByAggregateInput
  }

  export type CashShopInventoryScalarWhereWithAggregatesInput = {
    AND?: CashShopInventoryScalarWhereWithAggregatesInput | CashShopInventoryScalarWhereWithAggregatesInput[]
    OR?: CashShopInventoryScalarWhereWithAggregatesInput[]
    NOT?: CashShopInventoryScalarWhereWithAggregatesInput | CashShopInventoryScalarWhereWithAggregatesInput[]
    BaseItemCode?: IntWithAggregatesFilter<"CashShopInventory"> | number
    MainItemCode?: IntNullableWithAggregatesFilter<"CashShopInventory"> | number | null
    AccountID?: StringNullableWithAggregatesFilter<"CashShopInventory"> | string | null
    InventoryType?: IntNullableWithAggregatesFilter<"CashShopInventory"> | number | null
    PackageMainIndex?: IntNullableWithAggregatesFilter<"CashShopInventory"> | number | null
    ProductBaseIndex?: IntNullableWithAggregatesFilter<"CashShopInventory"> | number | null
    ProductMainIndex?: IntNullableWithAggregatesFilter<"CashShopInventory"> | number | null
    CoinValue?: FloatNullableWithAggregatesFilter<"CashShopInventory"> | number | null
    ProductType?: IntNullableWithAggregatesFilter<"CashShopInventory"> | number | null
    GiftName?: StringNullableWithAggregatesFilter<"CashShopInventory"> | string | null
    GiftText?: StringNullableWithAggregatesFilter<"CashShopInventory"> | string | null
  }

  export type CashShopPeriodicItemWhereInput = {
    AND?: CashShopPeriodicItemWhereInput | CashShopPeriodicItemWhereInput[]
    OR?: CashShopPeriodicItemWhereInput[]
    NOT?: CashShopPeriodicItemWhereInput | CashShopPeriodicItemWhereInput[]
    ItemSerial?: IntFilter<"CashShopPeriodicItem"> | number
    Time?: IntNullableFilter<"CashShopPeriodicItem"> | number | null
  }

  export type CashShopPeriodicItemOrderByWithRelationInput = {
    ItemSerial?: SortOrder
    Time?: SortOrderInput | SortOrder
  }

  export type CashShopPeriodicItemWhereUniqueInput = Prisma.AtLeast<{
    ItemSerial?: number
    AND?: CashShopPeriodicItemWhereInput | CashShopPeriodicItemWhereInput[]
    OR?: CashShopPeriodicItemWhereInput[]
    NOT?: CashShopPeriodicItemWhereInput | CashShopPeriodicItemWhereInput[]
    Time?: IntNullableFilter<"CashShopPeriodicItem"> | number | null
  }, "ItemSerial">

  export type CashShopPeriodicItemOrderByWithAggregationInput = {
    ItemSerial?: SortOrder
    Time?: SortOrderInput | SortOrder
    _count?: CashShopPeriodicItemCountOrderByAggregateInput
    _avg?: CashShopPeriodicItemAvgOrderByAggregateInput
    _max?: CashShopPeriodicItemMaxOrderByAggregateInput
    _min?: CashShopPeriodicItemMinOrderByAggregateInput
    _sum?: CashShopPeriodicItemSumOrderByAggregateInput
  }

  export type CashShopPeriodicItemScalarWhereWithAggregatesInput = {
    AND?: CashShopPeriodicItemScalarWhereWithAggregatesInput | CashShopPeriodicItemScalarWhereWithAggregatesInput[]
    OR?: CashShopPeriodicItemScalarWhereWithAggregatesInput[]
    NOT?: CashShopPeriodicItemScalarWhereWithAggregatesInput | CashShopPeriodicItemScalarWhereWithAggregatesInput[]
    ItemSerial?: IntWithAggregatesFilter<"CashShopPeriodicItem"> | number
    Time?: IntNullableWithAggregatesFilter<"CashShopPeriodicItem"> | number | null
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    AccountID?: StringFilter<"Character"> | string
    Name?: StringFilter<"Character"> | string
    cLevel?: IntNullableFilter<"Character"> | number | null
    LevelUpPoint?: IntNullableFilter<"Character"> | number | null
    Class?: IntNullableFilter<"Character"> | number | null
    Experience?: IntNullableFilter<"Character"> | number | null
    Strength?: IntNullableFilter<"Character"> | number | null
    Dexterity?: IntNullableFilter<"Character"> | number | null
    Vitality?: IntNullableFilter<"Character"> | number | null
    Energy?: IntNullableFilter<"Character"> | number | null
    Leadership?: IntNullableFilter<"Character"> | number | null
    Inventory?: BytesNullableFilter<"Character"> | Buffer | null
    MagicList?: BytesNullableFilter<"Character"> | Buffer | null
    Money?: IntNullableFilter<"Character"> | number | null
    Life?: FloatNullableFilter<"Character"> | number | null
    MaxLife?: FloatNullableFilter<"Character"> | number | null
    Mana?: FloatNullableFilter<"Character"> | number | null
    MaxMana?: FloatNullableFilter<"Character"> | number | null
    BP?: FloatNullableFilter<"Character"> | number | null
    MaxBP?: FloatNullableFilter<"Character"> | number | null
    Shield?: FloatNullableFilter<"Character"> | number | null
    MaxShield?: FloatNullableFilter<"Character"> | number | null
    MapNumber?: IntNullableFilter<"Character"> | number | null
    MapPosX?: IntNullableFilter<"Character"> | number | null
    MapPosY?: IntNullableFilter<"Character"> | number | null
    MapDir?: IntNullableFilter<"Character"> | number | null
    PkCount?: IntNullableFilter<"Character"> | number | null
    PkLevel?: IntNullableFilter<"Character"> | number | null
    PkTime?: IntNullableFilter<"Character"> | number | null
    MDate?: DateTimeNullableFilter<"Character"> | Date | string | null
    LDate?: DateTimeNullableFilter<"Character"> | Date | string | null
    CtlCode?: IntNullableFilter<"Character"> | number | null
    DbVersion?: IntNullableFilter<"Character"> | number | null
    Quest?: BytesNullableFilter<"Character"> | Buffer | null
    ChatLimitTime?: IntNullableFilter<"Character"> | number | null
    FruitPoint?: IntNullableFilter<"Character"> | number | null
    EffectList?: BytesNullableFilter<"Character"> | Buffer | null
    FruitAddPoint?: IntFilter<"Character"> | number
    FruitSubPoint?: IntFilter<"Character"> | number
    ResetCount?: IntFilter<"Character"> | number
    MasterResetCount?: IntFilter<"Character"> | number
    ExtInventory?: IntFilter<"Character"> | number
    Resets?: IntFilter<"Character"> | number
    ResetsDay?: IntFilter<"Character"> | number
    ResetsWeek?: IntFilter<"Character"> | number
    ResetsMonth?: IntFilter<"Character"> | number
    MResets?: IntFilter<"Character"> | number
    MResetsDay?: IntFilter<"Character"> | number
    MResetsWeek?: IntFilter<"Character"> | number
    MResetsMonth?: IntFilter<"Character"> | number
    PKTotal?: IntFilter<"Character"> | number
    PKDay?: IntFilter<"Character"> | number
    PKWeek?: IntFilter<"Character"> | number
    PKMonth?: IntFilter<"Character"> | number
    HeroTotal?: IntFilter<"Character"> | number
    HeroDay?: IntFilter<"Character"> | number
    HeroWeek?: IntFilter<"Character"> | number
    HeroMonth?: IntFilter<"Character"> | number
    tradewins?: IntFilter<"Character"> | number
    matamata?: IntFilter<"Character"> | number
    duel_total?: IntFilter<"Character"> | number
    duel_semanal?: IntFilter<"Character"> | number
    duel_mensal?: IntFilter<"Character"> | number
  }

  export type CharacterOrderByWithRelationInput = {
    AccountID?: SortOrder
    Name?: SortOrder
    cLevel?: SortOrderInput | SortOrder
    LevelUpPoint?: SortOrderInput | SortOrder
    Class?: SortOrderInput | SortOrder
    Experience?: SortOrderInput | SortOrder
    Strength?: SortOrderInput | SortOrder
    Dexterity?: SortOrderInput | SortOrder
    Vitality?: SortOrderInput | SortOrder
    Energy?: SortOrderInput | SortOrder
    Leadership?: SortOrderInput | SortOrder
    Inventory?: SortOrderInput | SortOrder
    MagicList?: SortOrderInput | SortOrder
    Money?: SortOrderInput | SortOrder
    Life?: SortOrderInput | SortOrder
    MaxLife?: SortOrderInput | SortOrder
    Mana?: SortOrderInput | SortOrder
    MaxMana?: SortOrderInput | SortOrder
    BP?: SortOrderInput | SortOrder
    MaxBP?: SortOrderInput | SortOrder
    Shield?: SortOrderInput | SortOrder
    MaxShield?: SortOrderInput | SortOrder
    MapNumber?: SortOrderInput | SortOrder
    MapPosX?: SortOrderInput | SortOrder
    MapPosY?: SortOrderInput | SortOrder
    MapDir?: SortOrderInput | SortOrder
    PkCount?: SortOrderInput | SortOrder
    PkLevel?: SortOrderInput | SortOrder
    PkTime?: SortOrderInput | SortOrder
    MDate?: SortOrderInput | SortOrder
    LDate?: SortOrderInput | SortOrder
    CtlCode?: SortOrderInput | SortOrder
    DbVersion?: SortOrderInput | SortOrder
    Quest?: SortOrderInput | SortOrder
    ChatLimitTime?: SortOrderInput | SortOrder
    FruitPoint?: SortOrderInput | SortOrder
    EffectList?: SortOrderInput | SortOrder
    FruitAddPoint?: SortOrder
    FruitSubPoint?: SortOrder
    ResetCount?: SortOrder
    MasterResetCount?: SortOrder
    ExtInventory?: SortOrder
    Resets?: SortOrder
    ResetsDay?: SortOrder
    ResetsWeek?: SortOrder
    ResetsMonth?: SortOrder
    MResets?: SortOrder
    MResetsDay?: SortOrder
    MResetsWeek?: SortOrder
    MResetsMonth?: SortOrder
    PKTotal?: SortOrder
    PKDay?: SortOrder
    PKWeek?: SortOrder
    PKMonth?: SortOrder
    HeroTotal?: SortOrder
    HeroDay?: SortOrder
    HeroWeek?: SortOrder
    HeroMonth?: SortOrder
    tradewins?: SortOrder
    matamata?: SortOrder
    duel_total?: SortOrder
    duel_semanal?: SortOrder
    duel_mensal?: SortOrder
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    AccountID?: StringFilter<"Character"> | string
    cLevel?: IntNullableFilter<"Character"> | number | null
    LevelUpPoint?: IntNullableFilter<"Character"> | number | null
    Class?: IntNullableFilter<"Character"> | number | null
    Experience?: IntNullableFilter<"Character"> | number | null
    Strength?: IntNullableFilter<"Character"> | number | null
    Dexterity?: IntNullableFilter<"Character"> | number | null
    Vitality?: IntNullableFilter<"Character"> | number | null
    Energy?: IntNullableFilter<"Character"> | number | null
    Leadership?: IntNullableFilter<"Character"> | number | null
    Inventory?: BytesNullableFilter<"Character"> | Buffer | null
    MagicList?: BytesNullableFilter<"Character"> | Buffer | null
    Money?: IntNullableFilter<"Character"> | number | null
    Life?: FloatNullableFilter<"Character"> | number | null
    MaxLife?: FloatNullableFilter<"Character"> | number | null
    Mana?: FloatNullableFilter<"Character"> | number | null
    MaxMana?: FloatNullableFilter<"Character"> | number | null
    BP?: FloatNullableFilter<"Character"> | number | null
    MaxBP?: FloatNullableFilter<"Character"> | number | null
    Shield?: FloatNullableFilter<"Character"> | number | null
    MaxShield?: FloatNullableFilter<"Character"> | number | null
    MapNumber?: IntNullableFilter<"Character"> | number | null
    MapPosX?: IntNullableFilter<"Character"> | number | null
    MapPosY?: IntNullableFilter<"Character"> | number | null
    MapDir?: IntNullableFilter<"Character"> | number | null
    PkCount?: IntNullableFilter<"Character"> | number | null
    PkLevel?: IntNullableFilter<"Character"> | number | null
    PkTime?: IntNullableFilter<"Character"> | number | null
    MDate?: DateTimeNullableFilter<"Character"> | Date | string | null
    LDate?: DateTimeNullableFilter<"Character"> | Date | string | null
    CtlCode?: IntNullableFilter<"Character"> | number | null
    DbVersion?: IntNullableFilter<"Character"> | number | null
    Quest?: BytesNullableFilter<"Character"> | Buffer | null
    ChatLimitTime?: IntNullableFilter<"Character"> | number | null
    FruitPoint?: IntNullableFilter<"Character"> | number | null
    EffectList?: BytesNullableFilter<"Character"> | Buffer | null
    FruitAddPoint?: IntFilter<"Character"> | number
    FruitSubPoint?: IntFilter<"Character"> | number
    ResetCount?: IntFilter<"Character"> | number
    MasterResetCount?: IntFilter<"Character"> | number
    ExtInventory?: IntFilter<"Character"> | number
    Resets?: IntFilter<"Character"> | number
    ResetsDay?: IntFilter<"Character"> | number
    ResetsWeek?: IntFilter<"Character"> | number
    ResetsMonth?: IntFilter<"Character"> | number
    MResets?: IntFilter<"Character"> | number
    MResetsDay?: IntFilter<"Character"> | number
    MResetsWeek?: IntFilter<"Character"> | number
    MResetsMonth?: IntFilter<"Character"> | number
    PKTotal?: IntFilter<"Character"> | number
    PKDay?: IntFilter<"Character"> | number
    PKWeek?: IntFilter<"Character"> | number
    PKMonth?: IntFilter<"Character"> | number
    HeroTotal?: IntFilter<"Character"> | number
    HeroDay?: IntFilter<"Character"> | number
    HeroWeek?: IntFilter<"Character"> | number
    HeroMonth?: IntFilter<"Character"> | number
    tradewins?: IntFilter<"Character"> | number
    matamata?: IntFilter<"Character"> | number
    duel_total?: IntFilter<"Character"> | number
    duel_semanal?: IntFilter<"Character"> | number
    duel_mensal?: IntFilter<"Character"> | number
  }, "Name">

  export type CharacterOrderByWithAggregationInput = {
    AccountID?: SortOrder
    Name?: SortOrder
    cLevel?: SortOrderInput | SortOrder
    LevelUpPoint?: SortOrderInput | SortOrder
    Class?: SortOrderInput | SortOrder
    Experience?: SortOrderInput | SortOrder
    Strength?: SortOrderInput | SortOrder
    Dexterity?: SortOrderInput | SortOrder
    Vitality?: SortOrderInput | SortOrder
    Energy?: SortOrderInput | SortOrder
    Leadership?: SortOrderInput | SortOrder
    Inventory?: SortOrderInput | SortOrder
    MagicList?: SortOrderInput | SortOrder
    Money?: SortOrderInput | SortOrder
    Life?: SortOrderInput | SortOrder
    MaxLife?: SortOrderInput | SortOrder
    Mana?: SortOrderInput | SortOrder
    MaxMana?: SortOrderInput | SortOrder
    BP?: SortOrderInput | SortOrder
    MaxBP?: SortOrderInput | SortOrder
    Shield?: SortOrderInput | SortOrder
    MaxShield?: SortOrderInput | SortOrder
    MapNumber?: SortOrderInput | SortOrder
    MapPosX?: SortOrderInput | SortOrder
    MapPosY?: SortOrderInput | SortOrder
    MapDir?: SortOrderInput | SortOrder
    PkCount?: SortOrderInput | SortOrder
    PkLevel?: SortOrderInput | SortOrder
    PkTime?: SortOrderInput | SortOrder
    MDate?: SortOrderInput | SortOrder
    LDate?: SortOrderInput | SortOrder
    CtlCode?: SortOrderInput | SortOrder
    DbVersion?: SortOrderInput | SortOrder
    Quest?: SortOrderInput | SortOrder
    ChatLimitTime?: SortOrderInput | SortOrder
    FruitPoint?: SortOrderInput | SortOrder
    EffectList?: SortOrderInput | SortOrder
    FruitAddPoint?: SortOrder
    FruitSubPoint?: SortOrder
    ResetCount?: SortOrder
    MasterResetCount?: SortOrder
    ExtInventory?: SortOrder
    Resets?: SortOrder
    ResetsDay?: SortOrder
    ResetsWeek?: SortOrder
    ResetsMonth?: SortOrder
    MResets?: SortOrder
    MResetsDay?: SortOrder
    MResetsWeek?: SortOrder
    MResetsMonth?: SortOrder
    PKTotal?: SortOrder
    PKDay?: SortOrder
    PKWeek?: SortOrder
    PKMonth?: SortOrder
    HeroTotal?: SortOrder
    HeroDay?: SortOrder
    HeroWeek?: SortOrder
    HeroMonth?: SortOrder
    tradewins?: SortOrder
    matamata?: SortOrder
    duel_total?: SortOrder
    duel_semanal?: SortOrder
    duel_mensal?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    AccountID?: StringWithAggregatesFilter<"Character"> | string
    Name?: StringWithAggregatesFilter<"Character"> | string
    cLevel?: IntNullableWithAggregatesFilter<"Character"> | number | null
    LevelUpPoint?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Class?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Experience?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Strength?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Dexterity?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Vitality?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Energy?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Leadership?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Inventory?: BytesNullableWithAggregatesFilter<"Character"> | Buffer | null
    MagicList?: BytesNullableWithAggregatesFilter<"Character"> | Buffer | null
    Money?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Life?: FloatNullableWithAggregatesFilter<"Character"> | number | null
    MaxLife?: FloatNullableWithAggregatesFilter<"Character"> | number | null
    Mana?: FloatNullableWithAggregatesFilter<"Character"> | number | null
    MaxMana?: FloatNullableWithAggregatesFilter<"Character"> | number | null
    BP?: FloatNullableWithAggregatesFilter<"Character"> | number | null
    MaxBP?: FloatNullableWithAggregatesFilter<"Character"> | number | null
    Shield?: FloatNullableWithAggregatesFilter<"Character"> | number | null
    MaxShield?: FloatNullableWithAggregatesFilter<"Character"> | number | null
    MapNumber?: IntNullableWithAggregatesFilter<"Character"> | number | null
    MapPosX?: IntNullableWithAggregatesFilter<"Character"> | number | null
    MapPosY?: IntNullableWithAggregatesFilter<"Character"> | number | null
    MapDir?: IntNullableWithAggregatesFilter<"Character"> | number | null
    PkCount?: IntNullableWithAggregatesFilter<"Character"> | number | null
    PkLevel?: IntNullableWithAggregatesFilter<"Character"> | number | null
    PkTime?: IntNullableWithAggregatesFilter<"Character"> | number | null
    MDate?: DateTimeNullableWithAggregatesFilter<"Character"> | Date | string | null
    LDate?: DateTimeNullableWithAggregatesFilter<"Character"> | Date | string | null
    CtlCode?: IntNullableWithAggregatesFilter<"Character"> | number | null
    DbVersion?: IntNullableWithAggregatesFilter<"Character"> | number | null
    Quest?: BytesNullableWithAggregatesFilter<"Character"> | Buffer | null
    ChatLimitTime?: IntNullableWithAggregatesFilter<"Character"> | number | null
    FruitPoint?: IntNullableWithAggregatesFilter<"Character"> | number | null
    EffectList?: BytesNullableWithAggregatesFilter<"Character"> | Buffer | null
    FruitAddPoint?: IntWithAggregatesFilter<"Character"> | number
    FruitSubPoint?: IntWithAggregatesFilter<"Character"> | number
    ResetCount?: IntWithAggregatesFilter<"Character"> | number
    MasterResetCount?: IntWithAggregatesFilter<"Character"> | number
    ExtInventory?: IntWithAggregatesFilter<"Character"> | number
    Resets?: IntWithAggregatesFilter<"Character"> | number
    ResetsDay?: IntWithAggregatesFilter<"Character"> | number
    ResetsWeek?: IntWithAggregatesFilter<"Character"> | number
    ResetsMonth?: IntWithAggregatesFilter<"Character"> | number
    MResets?: IntWithAggregatesFilter<"Character"> | number
    MResetsDay?: IntWithAggregatesFilter<"Character"> | number
    MResetsWeek?: IntWithAggregatesFilter<"Character"> | number
    MResetsMonth?: IntWithAggregatesFilter<"Character"> | number
    PKTotal?: IntWithAggregatesFilter<"Character"> | number
    PKDay?: IntWithAggregatesFilter<"Character"> | number
    PKWeek?: IntWithAggregatesFilter<"Character"> | number
    PKMonth?: IntWithAggregatesFilter<"Character"> | number
    HeroTotal?: IntWithAggregatesFilter<"Character"> | number
    HeroDay?: IntWithAggregatesFilter<"Character"> | number
    HeroWeek?: IntWithAggregatesFilter<"Character"> | number
    HeroMonth?: IntWithAggregatesFilter<"Character"> | number
    tradewins?: IntWithAggregatesFilter<"Character"> | number
    matamata?: IntWithAggregatesFilter<"Character"> | number
    duel_total?: IntWithAggregatesFilter<"Character"> | number
    duel_semanal?: IntWithAggregatesFilter<"Character"> | number
    duel_mensal?: IntWithAggregatesFilter<"Character"> | number
  }

  export type DefaultClassTypeWhereInput = {
    AND?: DefaultClassTypeWhereInput | DefaultClassTypeWhereInput[]
    OR?: DefaultClassTypeWhereInput[]
    NOT?: DefaultClassTypeWhereInput | DefaultClassTypeWhereInput[]
    Class?: IntFilter<"DefaultClassType"> | number
    Level?: IntNullableFilter<"DefaultClassType"> | number | null
    LevelUpPoint?: IntNullableFilter<"DefaultClassType"> | number | null
    Strength?: IntNullableFilter<"DefaultClassType"> | number | null
    Dexterity?: IntNullableFilter<"DefaultClassType"> | number | null
    Vitality?: IntNullableFilter<"DefaultClassType"> | number | null
    Energy?: IntNullableFilter<"DefaultClassType"> | number | null
    Leadership?: IntNullableFilter<"DefaultClassType"> | number | null
    Inventory?: BytesNullableFilter<"DefaultClassType"> | Buffer | null
    MagicList?: BytesNullableFilter<"DefaultClassType"> | Buffer | null
    Life?: FloatNullableFilter<"DefaultClassType"> | number | null
    MaxLife?: FloatNullableFilter<"DefaultClassType"> | number | null
    Mana?: FloatNullableFilter<"DefaultClassType"> | number | null
    MaxMana?: FloatNullableFilter<"DefaultClassType"> | number | null
    MapNumber?: IntNullableFilter<"DefaultClassType"> | number | null
    MapPosX?: IntNullableFilter<"DefaultClassType"> | number | null
    MapPosY?: IntNullableFilter<"DefaultClassType"> | number | null
    Quest?: BytesNullableFilter<"DefaultClassType"> | Buffer | null
    DbVersion?: IntNullableFilter<"DefaultClassType"> | number | null
    EffectList?: BytesNullableFilter<"DefaultClassType"> | Buffer | null
  }

  export type DefaultClassTypeOrderByWithRelationInput = {
    Class?: SortOrder
    Level?: SortOrderInput | SortOrder
    LevelUpPoint?: SortOrderInput | SortOrder
    Strength?: SortOrderInput | SortOrder
    Dexterity?: SortOrderInput | SortOrder
    Vitality?: SortOrderInput | SortOrder
    Energy?: SortOrderInput | SortOrder
    Leadership?: SortOrderInput | SortOrder
    Inventory?: SortOrderInput | SortOrder
    MagicList?: SortOrderInput | SortOrder
    Life?: SortOrderInput | SortOrder
    MaxLife?: SortOrderInput | SortOrder
    Mana?: SortOrderInput | SortOrder
    MaxMana?: SortOrderInput | SortOrder
    MapNumber?: SortOrderInput | SortOrder
    MapPosX?: SortOrderInput | SortOrder
    MapPosY?: SortOrderInput | SortOrder
    Quest?: SortOrderInput | SortOrder
    DbVersion?: SortOrderInput | SortOrder
    EffectList?: SortOrderInput | SortOrder
  }

  export type DefaultClassTypeWhereUniqueInput = Prisma.AtLeast<{
    Class?: number
    AND?: DefaultClassTypeWhereInput | DefaultClassTypeWhereInput[]
    OR?: DefaultClassTypeWhereInput[]
    NOT?: DefaultClassTypeWhereInput | DefaultClassTypeWhereInput[]
    Level?: IntNullableFilter<"DefaultClassType"> | number | null
    LevelUpPoint?: IntNullableFilter<"DefaultClassType"> | number | null
    Strength?: IntNullableFilter<"DefaultClassType"> | number | null
    Dexterity?: IntNullableFilter<"DefaultClassType"> | number | null
    Vitality?: IntNullableFilter<"DefaultClassType"> | number | null
    Energy?: IntNullableFilter<"DefaultClassType"> | number | null
    Leadership?: IntNullableFilter<"DefaultClassType"> | number | null
    Inventory?: BytesNullableFilter<"DefaultClassType"> | Buffer | null
    MagicList?: BytesNullableFilter<"DefaultClassType"> | Buffer | null
    Life?: FloatNullableFilter<"DefaultClassType"> | number | null
    MaxLife?: FloatNullableFilter<"DefaultClassType"> | number | null
    Mana?: FloatNullableFilter<"DefaultClassType"> | number | null
    MaxMana?: FloatNullableFilter<"DefaultClassType"> | number | null
    MapNumber?: IntNullableFilter<"DefaultClassType"> | number | null
    MapPosX?: IntNullableFilter<"DefaultClassType"> | number | null
    MapPosY?: IntNullableFilter<"DefaultClassType"> | number | null
    Quest?: BytesNullableFilter<"DefaultClassType"> | Buffer | null
    DbVersion?: IntNullableFilter<"DefaultClassType"> | number | null
    EffectList?: BytesNullableFilter<"DefaultClassType"> | Buffer | null
  }, "Class">

  export type DefaultClassTypeOrderByWithAggregationInput = {
    Class?: SortOrder
    Level?: SortOrderInput | SortOrder
    LevelUpPoint?: SortOrderInput | SortOrder
    Strength?: SortOrderInput | SortOrder
    Dexterity?: SortOrderInput | SortOrder
    Vitality?: SortOrderInput | SortOrder
    Energy?: SortOrderInput | SortOrder
    Leadership?: SortOrderInput | SortOrder
    Inventory?: SortOrderInput | SortOrder
    MagicList?: SortOrderInput | SortOrder
    Life?: SortOrderInput | SortOrder
    MaxLife?: SortOrderInput | SortOrder
    Mana?: SortOrderInput | SortOrder
    MaxMana?: SortOrderInput | SortOrder
    MapNumber?: SortOrderInput | SortOrder
    MapPosX?: SortOrderInput | SortOrder
    MapPosY?: SortOrderInput | SortOrder
    Quest?: SortOrderInput | SortOrder
    DbVersion?: SortOrderInput | SortOrder
    EffectList?: SortOrderInput | SortOrder
    _count?: DefaultClassTypeCountOrderByAggregateInput
    _avg?: DefaultClassTypeAvgOrderByAggregateInput
    _max?: DefaultClassTypeMaxOrderByAggregateInput
    _min?: DefaultClassTypeMinOrderByAggregateInput
    _sum?: DefaultClassTypeSumOrderByAggregateInput
  }

  export type DefaultClassTypeScalarWhereWithAggregatesInput = {
    AND?: DefaultClassTypeScalarWhereWithAggregatesInput | DefaultClassTypeScalarWhereWithAggregatesInput[]
    OR?: DefaultClassTypeScalarWhereWithAggregatesInput[]
    NOT?: DefaultClassTypeScalarWhereWithAggregatesInput | DefaultClassTypeScalarWhereWithAggregatesInput[]
    Class?: IntWithAggregatesFilter<"DefaultClassType"> | number
    Level?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    LevelUpPoint?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    Strength?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    Dexterity?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    Vitality?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    Energy?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    Leadership?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    Inventory?: BytesNullableWithAggregatesFilter<"DefaultClassType"> | Buffer | null
    MagicList?: BytesNullableWithAggregatesFilter<"DefaultClassType"> | Buffer | null
    Life?: FloatNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    MaxLife?: FloatNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    Mana?: FloatNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    MaxMana?: FloatNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    MapNumber?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    MapPosX?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    MapPosY?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    Quest?: BytesNullableWithAggregatesFilter<"DefaultClassType"> | Buffer | null
    DbVersion?: IntNullableWithAggregatesFilter<"DefaultClassType"> | number | null
    EffectList?: BytesNullableWithAggregatesFilter<"DefaultClassType"> | Buffer | null
  }

  export type EventLeoTheHelperWhereInput = {
    AND?: EventLeoTheHelperWhereInput | EventLeoTheHelperWhereInput[]
    OR?: EventLeoTheHelperWhereInput[]
    NOT?: EventLeoTheHelperWhereInput | EventLeoTheHelperWhereInput[]
    Name?: StringFilter<"EventLeoTheHelper"> | string
    Status?: IntNullableFilter<"EventLeoTheHelper"> | number | null
  }

  export type EventLeoTheHelperOrderByWithRelationInput = {
    Name?: SortOrder
    Status?: SortOrderInput | SortOrder
  }

  export type EventLeoTheHelperWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: EventLeoTheHelperWhereInput | EventLeoTheHelperWhereInput[]
    OR?: EventLeoTheHelperWhereInput[]
    NOT?: EventLeoTheHelperWhereInput | EventLeoTheHelperWhereInput[]
    Status?: IntNullableFilter<"EventLeoTheHelper"> | number | null
  }, "Name">

  export type EventLeoTheHelperOrderByWithAggregationInput = {
    Name?: SortOrder
    Status?: SortOrderInput | SortOrder
    _count?: EventLeoTheHelperCountOrderByAggregateInput
    _avg?: EventLeoTheHelperAvgOrderByAggregateInput
    _max?: EventLeoTheHelperMaxOrderByAggregateInput
    _min?: EventLeoTheHelperMinOrderByAggregateInput
    _sum?: EventLeoTheHelperSumOrderByAggregateInput
  }

  export type EventLeoTheHelperScalarWhereWithAggregatesInput = {
    AND?: EventLeoTheHelperScalarWhereWithAggregatesInput | EventLeoTheHelperScalarWhereWithAggregatesInput[]
    OR?: EventLeoTheHelperScalarWhereWithAggregatesInput[]
    NOT?: EventLeoTheHelperScalarWhereWithAggregatesInput | EventLeoTheHelperScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"EventLeoTheHelper"> | string
    Status?: IntNullableWithAggregatesFilter<"EventLeoTheHelper"> | number | null
  }

  export type EventSantaClausWhereInput = {
    AND?: EventSantaClausWhereInput | EventSantaClausWhereInput[]
    OR?: EventSantaClausWhereInput[]
    NOT?: EventSantaClausWhereInput | EventSantaClausWhereInput[]
    Name?: StringFilter<"EventSantaClaus"> | string
    Status?: IntNullableFilter<"EventSantaClaus"> | number | null
  }

  export type EventSantaClausOrderByWithRelationInput = {
    Name?: SortOrder
    Status?: SortOrderInput | SortOrder
  }

  export type EventSantaClausWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: EventSantaClausWhereInput | EventSantaClausWhereInput[]
    OR?: EventSantaClausWhereInput[]
    NOT?: EventSantaClausWhereInput | EventSantaClausWhereInput[]
    Status?: IntNullableFilter<"EventSantaClaus"> | number | null
  }, "Name">

  export type EventSantaClausOrderByWithAggregationInput = {
    Name?: SortOrder
    Status?: SortOrderInput | SortOrder
    _count?: EventSantaClausCountOrderByAggregateInput
    _avg?: EventSantaClausAvgOrderByAggregateInput
    _max?: EventSantaClausMaxOrderByAggregateInput
    _min?: EventSantaClausMinOrderByAggregateInput
    _sum?: EventSantaClausSumOrderByAggregateInput
  }

  export type EventSantaClausScalarWhereWithAggregatesInput = {
    AND?: EventSantaClausScalarWhereWithAggregatesInput | EventSantaClausScalarWhereWithAggregatesInput[]
    OR?: EventSantaClausScalarWhereWithAggregatesInput[]
    NOT?: EventSantaClausScalarWhereWithAggregatesInput | EventSantaClausScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"EventSantaClaus"> | string
    Status?: IntNullableWithAggregatesFilter<"EventSantaClaus"> | number | null
  }

  export type GameServerInfoWhereInput = {
    AND?: GameServerInfoWhereInput | GameServerInfoWhereInput[]
    OR?: GameServerInfoWhereInput[]
    NOT?: GameServerInfoWhereInput | GameServerInfoWhereInput[]
    Number?: IntFilter<"GameServerInfo"> | number
    ItemCount?: IntFilter<"GameServerInfo"> | number
    ZenCount?: IntNullableFilter<"GameServerInfo"> | number | null
    AceItemCount?: IntNullableFilter<"GameServerInfo"> | number | null
  }

  export type GameServerInfoOrderByWithRelationInput = {
    Number?: SortOrder
    ItemCount?: SortOrder
    ZenCount?: SortOrderInput | SortOrder
    AceItemCount?: SortOrderInput | SortOrder
  }

  export type GameServerInfoWhereUniqueInput = Prisma.AtLeast<{
    Number?: number
    AND?: GameServerInfoWhereInput | GameServerInfoWhereInput[]
    OR?: GameServerInfoWhereInput[]
    NOT?: GameServerInfoWhereInput | GameServerInfoWhereInput[]
    ItemCount?: IntFilter<"GameServerInfo"> | number
    ZenCount?: IntNullableFilter<"GameServerInfo"> | number | null
    AceItemCount?: IntNullableFilter<"GameServerInfo"> | number | null
  }, "Number">

  export type GameServerInfoOrderByWithAggregationInput = {
    Number?: SortOrder
    ItemCount?: SortOrder
    ZenCount?: SortOrderInput | SortOrder
    AceItemCount?: SortOrderInput | SortOrder
    _count?: GameServerInfoCountOrderByAggregateInput
    _avg?: GameServerInfoAvgOrderByAggregateInput
    _max?: GameServerInfoMaxOrderByAggregateInput
    _min?: GameServerInfoMinOrderByAggregateInput
    _sum?: GameServerInfoSumOrderByAggregateInput
  }

  export type GameServerInfoScalarWhereWithAggregatesInput = {
    AND?: GameServerInfoScalarWhereWithAggregatesInput | GameServerInfoScalarWhereWithAggregatesInput[]
    OR?: GameServerInfoScalarWhereWithAggregatesInput[]
    NOT?: GameServerInfoScalarWhereWithAggregatesInput | GameServerInfoScalarWhereWithAggregatesInput[]
    Number?: IntWithAggregatesFilter<"GameServerInfo"> | number
    ItemCount?: IntWithAggregatesFilter<"GameServerInfo"> | number
    ZenCount?: IntNullableWithAggregatesFilter<"GameServerInfo"> | number | null
    AceItemCount?: IntNullableWithAggregatesFilter<"GameServerInfo"> | number | null
  }

  export type Gens_RankWhereInput = {
    AND?: Gens_RankWhereInput | Gens_RankWhereInput[]
    OR?: Gens_RankWhereInput[]
    NOT?: Gens_RankWhereInput | Gens_RankWhereInput[]
    Name?: StringFilter<"Gens_Rank"> | string
    Family?: IntNullableFilter<"Gens_Rank"> | number | null
    Contribution?: IntNullableFilter<"Gens_Rank"> | number | null
  }

  export type Gens_RankOrderByWithRelationInput = {
    Name?: SortOrder
    Family?: SortOrderInput | SortOrder
    Contribution?: SortOrderInput | SortOrder
  }

  export type Gens_RankWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: Gens_RankWhereInput | Gens_RankWhereInput[]
    OR?: Gens_RankWhereInput[]
    NOT?: Gens_RankWhereInput | Gens_RankWhereInput[]
    Family?: IntNullableFilter<"Gens_Rank"> | number | null
    Contribution?: IntNullableFilter<"Gens_Rank"> | number | null
  }, "Name">

  export type Gens_RankOrderByWithAggregationInput = {
    Name?: SortOrder
    Family?: SortOrderInput | SortOrder
    Contribution?: SortOrderInput | SortOrder
    _count?: Gens_RankCountOrderByAggregateInput
    _avg?: Gens_RankAvgOrderByAggregateInput
    _max?: Gens_RankMaxOrderByAggregateInput
    _min?: Gens_RankMinOrderByAggregateInput
    _sum?: Gens_RankSumOrderByAggregateInput
  }

  export type Gens_RankScalarWhereWithAggregatesInput = {
    AND?: Gens_RankScalarWhereWithAggregatesInput | Gens_RankScalarWhereWithAggregatesInput[]
    OR?: Gens_RankScalarWhereWithAggregatesInput[]
    NOT?: Gens_RankScalarWhereWithAggregatesInput | Gens_RankScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"Gens_Rank"> | string
    Family?: IntNullableWithAggregatesFilter<"Gens_Rank"> | number | null
    Contribution?: IntNullableWithAggregatesFilter<"Gens_Rank"> | number | null
  }

  export type Gens_RewardWhereInput = {
    AND?: Gens_RewardWhereInput | Gens_RewardWhereInput[]
    OR?: Gens_RewardWhereInput[]
    NOT?: Gens_RewardWhereInput | Gens_RewardWhereInput[]
    Name?: StringFilter<"Gens_Reward"> | string
    Rank?: IntNullableFilter<"Gens_Reward"> | number | null
    Status?: IntNullableFilter<"Gens_Reward"> | number | null
  }

  export type Gens_RewardOrderByWithRelationInput = {
    Name?: SortOrder
    Rank?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
  }

  export type Gens_RewardWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: Gens_RewardWhereInput | Gens_RewardWhereInput[]
    OR?: Gens_RewardWhereInput[]
    NOT?: Gens_RewardWhereInput | Gens_RewardWhereInput[]
    Rank?: IntNullableFilter<"Gens_Reward"> | number | null
    Status?: IntNullableFilter<"Gens_Reward"> | number | null
  }, "Name">

  export type Gens_RewardOrderByWithAggregationInput = {
    Name?: SortOrder
    Rank?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    _count?: Gens_RewardCountOrderByAggregateInput
    _avg?: Gens_RewardAvgOrderByAggregateInput
    _max?: Gens_RewardMaxOrderByAggregateInput
    _min?: Gens_RewardMinOrderByAggregateInput
    _sum?: Gens_RewardSumOrderByAggregateInput
  }

  export type Gens_RewardScalarWhereWithAggregatesInput = {
    AND?: Gens_RewardScalarWhereWithAggregatesInput | Gens_RewardScalarWhereWithAggregatesInput[]
    OR?: Gens_RewardScalarWhereWithAggregatesInput[]
    NOT?: Gens_RewardScalarWhereWithAggregatesInput | Gens_RewardScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"Gens_Reward"> | string
    Rank?: IntNullableWithAggregatesFilter<"Gens_Reward"> | number | null
    Status?: IntNullableWithAggregatesFilter<"Gens_Reward"> | number | null
  }

  export type GuildWhereInput = {
    AND?: GuildWhereInput | GuildWhereInput[]
    OR?: GuildWhereInput[]
    NOT?: GuildWhereInput | GuildWhereInput[]
    G_Name?: StringFilter<"Guild"> | string
    G_Mark?: BytesNullableFilter<"Guild"> | Buffer | null
    G_Score?: IntNullableFilter<"Guild"> | number | null
    G_Master?: StringNullableFilter<"Guild"> | string | null
    G_Count?: IntNullableFilter<"Guild"> | number | null
    G_Notice?: StringNullableFilter<"Guild"> | string | null
    Number?: IntFilter<"Guild"> | number
    G_Type?: IntFilter<"Guild"> | number
    G_Rival?: IntFilter<"Guild"> | number
    G_Union?: IntFilter<"Guild"> | number
    MemberCount?: IntNullableFilter<"Guild"> | number | null
  }

  export type GuildOrderByWithRelationInput = {
    G_Name?: SortOrder
    G_Mark?: SortOrderInput | SortOrder
    G_Score?: SortOrderInput | SortOrder
    G_Master?: SortOrderInput | SortOrder
    G_Count?: SortOrderInput | SortOrder
    G_Notice?: SortOrderInput | SortOrder
    Number?: SortOrder
    G_Type?: SortOrder
    G_Rival?: SortOrder
    G_Union?: SortOrder
    MemberCount?: SortOrderInput | SortOrder
  }

  export type GuildWhereUniqueInput = Prisma.AtLeast<{
    G_Name?: string
    AND?: GuildWhereInput | GuildWhereInput[]
    OR?: GuildWhereInput[]
    NOT?: GuildWhereInput | GuildWhereInput[]
    G_Mark?: BytesNullableFilter<"Guild"> | Buffer | null
    G_Score?: IntNullableFilter<"Guild"> | number | null
    G_Master?: StringNullableFilter<"Guild"> | string | null
    G_Count?: IntNullableFilter<"Guild"> | number | null
    G_Notice?: StringNullableFilter<"Guild"> | string | null
    Number?: IntFilter<"Guild"> | number
    G_Type?: IntFilter<"Guild"> | number
    G_Rival?: IntFilter<"Guild"> | number
    G_Union?: IntFilter<"Guild"> | number
    MemberCount?: IntNullableFilter<"Guild"> | number | null
  }, "G_Name">

  export type GuildOrderByWithAggregationInput = {
    G_Name?: SortOrder
    G_Mark?: SortOrderInput | SortOrder
    G_Score?: SortOrderInput | SortOrder
    G_Master?: SortOrderInput | SortOrder
    G_Count?: SortOrderInput | SortOrder
    G_Notice?: SortOrderInput | SortOrder
    Number?: SortOrder
    G_Type?: SortOrder
    G_Rival?: SortOrder
    G_Union?: SortOrder
    MemberCount?: SortOrderInput | SortOrder
    _count?: GuildCountOrderByAggregateInput
    _avg?: GuildAvgOrderByAggregateInput
    _max?: GuildMaxOrderByAggregateInput
    _min?: GuildMinOrderByAggregateInput
    _sum?: GuildSumOrderByAggregateInput
  }

  export type GuildScalarWhereWithAggregatesInput = {
    AND?: GuildScalarWhereWithAggregatesInput | GuildScalarWhereWithAggregatesInput[]
    OR?: GuildScalarWhereWithAggregatesInput[]
    NOT?: GuildScalarWhereWithAggregatesInput | GuildScalarWhereWithAggregatesInput[]
    G_Name?: StringWithAggregatesFilter<"Guild"> | string
    G_Mark?: BytesNullableWithAggregatesFilter<"Guild"> | Buffer | null
    G_Score?: IntNullableWithAggregatesFilter<"Guild"> | number | null
    G_Master?: StringNullableWithAggregatesFilter<"Guild"> | string | null
    G_Count?: IntNullableWithAggregatesFilter<"Guild"> | number | null
    G_Notice?: StringNullableWithAggregatesFilter<"Guild"> | string | null
    Number?: IntWithAggregatesFilter<"Guild"> | number
    G_Type?: IntWithAggregatesFilter<"Guild"> | number
    G_Rival?: IntWithAggregatesFilter<"Guild"> | number
    G_Union?: IntWithAggregatesFilter<"Guild"> | number
    MemberCount?: IntNullableWithAggregatesFilter<"Guild"> | number | null
  }

  export type GuildMemberWhereInput = {
    AND?: GuildMemberWhereInput | GuildMemberWhereInput[]
    OR?: GuildMemberWhereInput[]
    NOT?: GuildMemberWhereInput | GuildMemberWhereInput[]
    Name?: StringFilter<"GuildMember"> | string
    G_Name?: StringFilter<"GuildMember"> | string
    G_Level?: IntNullableFilter<"GuildMember"> | number | null
    G_Status?: IntFilter<"GuildMember"> | number
  }

  export type GuildMemberOrderByWithRelationInput = {
    Name?: SortOrder
    G_Name?: SortOrder
    G_Level?: SortOrderInput | SortOrder
    G_Status?: SortOrder
  }

  export type GuildMemberWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: GuildMemberWhereInput | GuildMemberWhereInput[]
    OR?: GuildMemberWhereInput[]
    NOT?: GuildMemberWhereInput | GuildMemberWhereInput[]
    G_Name?: StringFilter<"GuildMember"> | string
    G_Level?: IntNullableFilter<"GuildMember"> | number | null
    G_Status?: IntFilter<"GuildMember"> | number
  }, "Name">

  export type GuildMemberOrderByWithAggregationInput = {
    Name?: SortOrder
    G_Name?: SortOrder
    G_Level?: SortOrderInput | SortOrder
    G_Status?: SortOrder
    _count?: GuildMemberCountOrderByAggregateInput
    _avg?: GuildMemberAvgOrderByAggregateInput
    _max?: GuildMemberMaxOrderByAggregateInput
    _min?: GuildMemberMinOrderByAggregateInput
    _sum?: GuildMemberSumOrderByAggregateInput
  }

  export type GuildMemberScalarWhereWithAggregatesInput = {
    AND?: GuildMemberScalarWhereWithAggregatesInput | GuildMemberScalarWhereWithAggregatesInput[]
    OR?: GuildMemberScalarWhereWithAggregatesInput[]
    NOT?: GuildMemberScalarWhereWithAggregatesInput | GuildMemberScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"GuildMember"> | string
    G_Name?: StringWithAggregatesFilter<"GuildMember"> | string
    G_Level?: IntNullableWithAggregatesFilter<"GuildMember"> | number | null
    G_Status?: IntWithAggregatesFilter<"GuildMember"> | number
  }

  export type HelperDataWhereInput = {
    AND?: HelperDataWhereInput | HelperDataWhereInput[]
    OR?: HelperDataWhereInput[]
    NOT?: HelperDataWhereInput | HelperDataWhereInput[]
    Name?: StringFilter<"HelperData"> | string
    Data?: BytesNullableFilter<"HelperData"> | Buffer | null
  }

  export type HelperDataOrderByWithRelationInput = {
    Name?: SortOrder
    Data?: SortOrderInput | SortOrder
  }

  export type HelperDataWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: HelperDataWhereInput | HelperDataWhereInput[]
    OR?: HelperDataWhereInput[]
    NOT?: HelperDataWhereInput | HelperDataWhereInput[]
    Data?: BytesNullableFilter<"HelperData"> | Buffer | null
  }, "Name">

  export type HelperDataOrderByWithAggregationInput = {
    Name?: SortOrder
    Data?: SortOrderInput | SortOrder
    _count?: HelperDataCountOrderByAggregateInput
    _max?: HelperDataMaxOrderByAggregateInput
    _min?: HelperDataMinOrderByAggregateInput
  }

  export type HelperDataScalarWhereWithAggregatesInput = {
    AND?: HelperDataScalarWhereWithAggregatesInput | HelperDataScalarWhereWithAggregatesInput[]
    OR?: HelperDataScalarWhereWithAggregatesInput[]
    NOT?: HelperDataScalarWhereWithAggregatesInput | HelperDataScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"HelperData"> | string
    Data?: BytesNullableWithAggregatesFilter<"HelperData"> | Buffer | null
  }

  export type LuckyCoinWhereInput = {
    AND?: LuckyCoinWhereInput | LuckyCoinWhereInput[]
    OR?: LuckyCoinWhereInput[]
    NOT?: LuckyCoinWhereInput | LuckyCoinWhereInput[]
    AccountID?: StringFilter<"LuckyCoin"> | string
    LuckyCoin?: IntNullableFilter<"LuckyCoin"> | number | null
  }

  export type LuckyCoinOrderByWithRelationInput = {
    AccountID?: SortOrder
    LuckyCoin?: SortOrderInput | SortOrder
  }

  export type LuckyCoinWhereUniqueInput = Prisma.AtLeast<{
    AccountID?: string
    AND?: LuckyCoinWhereInput | LuckyCoinWhereInput[]
    OR?: LuckyCoinWhereInput[]
    NOT?: LuckyCoinWhereInput | LuckyCoinWhereInput[]
    LuckyCoin?: IntNullableFilter<"LuckyCoin"> | number | null
  }, "AccountID">

  export type LuckyCoinOrderByWithAggregationInput = {
    AccountID?: SortOrder
    LuckyCoin?: SortOrderInput | SortOrder
    _count?: LuckyCoinCountOrderByAggregateInput
    _avg?: LuckyCoinAvgOrderByAggregateInput
    _max?: LuckyCoinMaxOrderByAggregateInput
    _min?: LuckyCoinMinOrderByAggregateInput
    _sum?: LuckyCoinSumOrderByAggregateInput
  }

  export type LuckyCoinScalarWhereWithAggregatesInput = {
    AND?: LuckyCoinScalarWhereWithAggregatesInput | LuckyCoinScalarWhereWithAggregatesInput[]
    OR?: LuckyCoinScalarWhereWithAggregatesInput[]
    NOT?: LuckyCoinScalarWhereWithAggregatesInput | LuckyCoinScalarWhereWithAggregatesInput[]
    AccountID?: StringWithAggregatesFilter<"LuckyCoin"> | string
    LuckyCoin?: IntNullableWithAggregatesFilter<"LuckyCoin"> | number | null
  }

  export type LuckyItemWhereInput = {
    AND?: LuckyItemWhereInput | LuckyItemWhereInput[]
    OR?: LuckyItemWhereInput[]
    NOT?: LuckyItemWhereInput | LuckyItemWhereInput[]
    ItemSerial?: IntFilter<"LuckyItem"> | number
    DurabilitySmall?: IntNullableFilter<"LuckyItem"> | number | null
  }

  export type LuckyItemOrderByWithRelationInput = {
    ItemSerial?: SortOrder
    DurabilitySmall?: SortOrderInput | SortOrder
  }

  export type LuckyItemWhereUniqueInput = Prisma.AtLeast<{
    ItemSerial?: number
    AND?: LuckyItemWhereInput | LuckyItemWhereInput[]
    OR?: LuckyItemWhereInput[]
    NOT?: LuckyItemWhereInput | LuckyItemWhereInput[]
    DurabilitySmall?: IntNullableFilter<"LuckyItem"> | number | null
  }, "ItemSerial">

  export type LuckyItemOrderByWithAggregationInput = {
    ItemSerial?: SortOrder
    DurabilitySmall?: SortOrderInput | SortOrder
    _count?: LuckyItemCountOrderByAggregateInput
    _avg?: LuckyItemAvgOrderByAggregateInput
    _max?: LuckyItemMaxOrderByAggregateInput
    _min?: LuckyItemMinOrderByAggregateInput
    _sum?: LuckyItemSumOrderByAggregateInput
  }

  export type LuckyItemScalarWhereWithAggregatesInput = {
    AND?: LuckyItemScalarWhereWithAggregatesInput | LuckyItemScalarWhereWithAggregatesInput[]
    OR?: LuckyItemScalarWhereWithAggregatesInput[]
    NOT?: LuckyItemScalarWhereWithAggregatesInput | LuckyItemScalarWhereWithAggregatesInput[]
    ItemSerial?: IntWithAggregatesFilter<"LuckyItem"> | number
    DurabilitySmall?: IntNullableWithAggregatesFilter<"LuckyItem"> | number | null
  }

  export type MEMB_STATWhereInput = {
    AND?: MEMB_STATWhereInput | MEMB_STATWhereInput[]
    OR?: MEMB_STATWhereInput[]
    NOT?: MEMB_STATWhereInput | MEMB_STATWhereInput[]
    memb___id?: StringFilter<"MEMB_STAT"> | string
    ConnectStat?: IntNullableFilter<"MEMB_STAT"> | number | null
    ServerName?: StringNullableFilter<"MEMB_STAT"> | string | null
    IP?: StringNullableFilter<"MEMB_STAT"> | string | null
    ConnectTM?: DateTimeNullableFilter<"MEMB_STAT"> | Date | string | null
    DisConnectTM?: DateTimeNullableFilter<"MEMB_STAT"> | Date | string | null
    OnlineHours?: IntNullableFilter<"MEMB_STAT"> | number | null
    HWID?: StringNullableFilter<"MEMB_STAT"> | string | null
  }

  export type MEMB_STATOrderByWithRelationInput = {
    memb___id?: SortOrder
    ConnectStat?: SortOrderInput | SortOrder
    ServerName?: SortOrderInput | SortOrder
    IP?: SortOrderInput | SortOrder
    ConnectTM?: SortOrderInput | SortOrder
    DisConnectTM?: SortOrderInput | SortOrder
    OnlineHours?: SortOrderInput | SortOrder
    HWID?: SortOrderInput | SortOrder
  }

  export type MEMB_STATWhereUniqueInput = Prisma.AtLeast<{
    memb___id?: string
    AND?: MEMB_STATWhereInput | MEMB_STATWhereInput[]
    OR?: MEMB_STATWhereInput[]
    NOT?: MEMB_STATWhereInput | MEMB_STATWhereInput[]
    ConnectStat?: IntNullableFilter<"MEMB_STAT"> | number | null
    ServerName?: StringNullableFilter<"MEMB_STAT"> | string | null
    IP?: StringNullableFilter<"MEMB_STAT"> | string | null
    ConnectTM?: DateTimeNullableFilter<"MEMB_STAT"> | Date | string | null
    DisConnectTM?: DateTimeNullableFilter<"MEMB_STAT"> | Date | string | null
    OnlineHours?: IntNullableFilter<"MEMB_STAT"> | number | null
    HWID?: StringNullableFilter<"MEMB_STAT"> | string | null
  }, "memb___id">

  export type MEMB_STATOrderByWithAggregationInput = {
    memb___id?: SortOrder
    ConnectStat?: SortOrderInput | SortOrder
    ServerName?: SortOrderInput | SortOrder
    IP?: SortOrderInput | SortOrder
    ConnectTM?: SortOrderInput | SortOrder
    DisConnectTM?: SortOrderInput | SortOrder
    OnlineHours?: SortOrderInput | SortOrder
    HWID?: SortOrderInput | SortOrder
    _count?: MEMB_STATCountOrderByAggregateInput
    _avg?: MEMB_STATAvgOrderByAggregateInput
    _max?: MEMB_STATMaxOrderByAggregateInput
    _min?: MEMB_STATMinOrderByAggregateInput
    _sum?: MEMB_STATSumOrderByAggregateInput
  }

  export type MEMB_STATScalarWhereWithAggregatesInput = {
    AND?: MEMB_STATScalarWhereWithAggregatesInput | MEMB_STATScalarWhereWithAggregatesInput[]
    OR?: MEMB_STATScalarWhereWithAggregatesInput[]
    NOT?: MEMB_STATScalarWhereWithAggregatesInput | MEMB_STATScalarWhereWithAggregatesInput[]
    memb___id?: StringWithAggregatesFilter<"MEMB_STAT"> | string
    ConnectStat?: IntNullableWithAggregatesFilter<"MEMB_STAT"> | number | null
    ServerName?: StringNullableWithAggregatesFilter<"MEMB_STAT"> | string | null
    IP?: StringNullableWithAggregatesFilter<"MEMB_STAT"> | string | null
    ConnectTM?: DateTimeNullableWithAggregatesFilter<"MEMB_STAT"> | Date | string | null
    DisConnectTM?: DateTimeNullableWithAggregatesFilter<"MEMB_STAT"> | Date | string | null
    OnlineHours?: IntNullableWithAggregatesFilter<"MEMB_STAT"> | number | null
    HWID?: StringNullableWithAggregatesFilter<"MEMB_STAT"> | string | null
  }

  export type MasterSkillTreeWhereInput = {
    AND?: MasterSkillTreeWhereInput | MasterSkillTreeWhereInput[]
    OR?: MasterSkillTreeWhereInput[]
    NOT?: MasterSkillTreeWhereInput | MasterSkillTreeWhereInput[]
    Name?: StringFilter<"MasterSkillTree"> | string
    MasterLevel?: IntNullableFilter<"MasterSkillTree"> | number | null
    MasterPoint?: IntNullableFilter<"MasterSkillTree"> | number | null
    MasterExperience?: BigIntNullableFilter<"MasterSkillTree"> | bigint | number | null
    MasterSkill?: BytesNullableFilter<"MasterSkillTree"> | Buffer | null
  }

  export type MasterSkillTreeOrderByWithRelationInput = {
    Name?: SortOrder
    MasterLevel?: SortOrderInput | SortOrder
    MasterPoint?: SortOrderInput | SortOrder
    MasterExperience?: SortOrderInput | SortOrder
    MasterSkill?: SortOrderInput | SortOrder
  }

  export type MasterSkillTreeWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: MasterSkillTreeWhereInput | MasterSkillTreeWhereInput[]
    OR?: MasterSkillTreeWhereInput[]
    NOT?: MasterSkillTreeWhereInput | MasterSkillTreeWhereInput[]
    MasterLevel?: IntNullableFilter<"MasterSkillTree"> | number | null
    MasterPoint?: IntNullableFilter<"MasterSkillTree"> | number | null
    MasterExperience?: BigIntNullableFilter<"MasterSkillTree"> | bigint | number | null
    MasterSkill?: BytesNullableFilter<"MasterSkillTree"> | Buffer | null
  }, "Name">

  export type MasterSkillTreeOrderByWithAggregationInput = {
    Name?: SortOrder
    MasterLevel?: SortOrderInput | SortOrder
    MasterPoint?: SortOrderInput | SortOrder
    MasterExperience?: SortOrderInput | SortOrder
    MasterSkill?: SortOrderInput | SortOrder
    _count?: MasterSkillTreeCountOrderByAggregateInput
    _avg?: MasterSkillTreeAvgOrderByAggregateInput
    _max?: MasterSkillTreeMaxOrderByAggregateInput
    _min?: MasterSkillTreeMinOrderByAggregateInput
    _sum?: MasterSkillTreeSumOrderByAggregateInput
  }

  export type MasterSkillTreeScalarWhereWithAggregatesInput = {
    AND?: MasterSkillTreeScalarWhereWithAggregatesInput | MasterSkillTreeScalarWhereWithAggregatesInput[]
    OR?: MasterSkillTreeScalarWhereWithAggregatesInput[]
    NOT?: MasterSkillTreeScalarWhereWithAggregatesInput | MasterSkillTreeScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"MasterSkillTree"> | string
    MasterLevel?: IntNullableWithAggregatesFilter<"MasterSkillTree"> | number | null
    MasterPoint?: IntNullableWithAggregatesFilter<"MasterSkillTree"> | number | null
    MasterExperience?: BigIntNullableWithAggregatesFilter<"MasterSkillTree"> | bigint | number | null
    MasterSkill?: BytesNullableWithAggregatesFilter<"MasterSkillTree"> | Buffer | null
  }

  export type MuCastle_DATAWhereInput = {
    AND?: MuCastle_DATAWhereInput | MuCastle_DATAWhereInput[]
    OR?: MuCastle_DATAWhereInput[]
    NOT?: MuCastle_DATAWhereInput | MuCastle_DATAWhereInput[]
    MAP_SVR_GROUP?: IntFilter<"MuCastle_DATA"> | number
    SIEGE_START_DATE?: DateTimeFilter<"MuCastle_DATA"> | Date | string
    SIEGE_END_DATE?: DateTimeFilter<"MuCastle_DATA"> | Date | string
    SIEGE_GUILDLIST_SETTED?: BoolFilter<"MuCastle_DATA"> | boolean
    SIEGE_ENDED?: BoolFilter<"MuCastle_DATA"> | boolean
    CASTLE_OCCUPY?: BoolFilter<"MuCastle_DATA"> | boolean
    OWNER_GUILD?: StringFilter<"MuCastle_DATA"> | string
    MONEY?: FloatFilter<"MuCastle_DATA"> | number
    TAX_RATE_CHAOS?: IntFilter<"MuCastle_DATA"> | number
    TAX_RATE_STORE?: IntFilter<"MuCastle_DATA"> | number
    TAX_HUNT_ZONE?: IntFilter<"MuCastle_DATA"> | number
  }

  export type MuCastle_DATAOrderByWithRelationInput = {
    MAP_SVR_GROUP?: SortOrder
    SIEGE_START_DATE?: SortOrder
    SIEGE_END_DATE?: SortOrder
    SIEGE_GUILDLIST_SETTED?: SortOrder
    SIEGE_ENDED?: SortOrder
    CASTLE_OCCUPY?: SortOrder
    OWNER_GUILD?: SortOrder
    MONEY?: SortOrder
    TAX_RATE_CHAOS?: SortOrder
    TAX_RATE_STORE?: SortOrder
    TAX_HUNT_ZONE?: SortOrder
  }

  export type MuCastle_DATAWhereUniqueInput = Prisma.AtLeast<{
    MAP_SVR_GROUP?: number
    AND?: MuCastle_DATAWhereInput | MuCastle_DATAWhereInput[]
    OR?: MuCastle_DATAWhereInput[]
    NOT?: MuCastle_DATAWhereInput | MuCastle_DATAWhereInput[]
    SIEGE_START_DATE?: DateTimeFilter<"MuCastle_DATA"> | Date | string
    SIEGE_END_DATE?: DateTimeFilter<"MuCastle_DATA"> | Date | string
    SIEGE_GUILDLIST_SETTED?: BoolFilter<"MuCastle_DATA"> | boolean
    SIEGE_ENDED?: BoolFilter<"MuCastle_DATA"> | boolean
    CASTLE_OCCUPY?: BoolFilter<"MuCastle_DATA"> | boolean
    OWNER_GUILD?: StringFilter<"MuCastle_DATA"> | string
    MONEY?: FloatFilter<"MuCastle_DATA"> | number
    TAX_RATE_CHAOS?: IntFilter<"MuCastle_DATA"> | number
    TAX_RATE_STORE?: IntFilter<"MuCastle_DATA"> | number
    TAX_HUNT_ZONE?: IntFilter<"MuCastle_DATA"> | number
  }, "MAP_SVR_GROUP">

  export type MuCastle_DATAOrderByWithAggregationInput = {
    MAP_SVR_GROUP?: SortOrder
    SIEGE_START_DATE?: SortOrder
    SIEGE_END_DATE?: SortOrder
    SIEGE_GUILDLIST_SETTED?: SortOrder
    SIEGE_ENDED?: SortOrder
    CASTLE_OCCUPY?: SortOrder
    OWNER_GUILD?: SortOrder
    MONEY?: SortOrder
    TAX_RATE_CHAOS?: SortOrder
    TAX_RATE_STORE?: SortOrder
    TAX_HUNT_ZONE?: SortOrder
    _count?: MuCastle_DATACountOrderByAggregateInput
    _avg?: MuCastle_DATAAvgOrderByAggregateInput
    _max?: MuCastle_DATAMaxOrderByAggregateInput
    _min?: MuCastle_DATAMinOrderByAggregateInput
    _sum?: MuCastle_DATASumOrderByAggregateInput
  }

  export type MuCastle_DATAScalarWhereWithAggregatesInput = {
    AND?: MuCastle_DATAScalarWhereWithAggregatesInput | MuCastle_DATAScalarWhereWithAggregatesInput[]
    OR?: MuCastle_DATAScalarWhereWithAggregatesInput[]
    NOT?: MuCastle_DATAScalarWhereWithAggregatesInput | MuCastle_DATAScalarWhereWithAggregatesInput[]
    MAP_SVR_GROUP?: IntWithAggregatesFilter<"MuCastle_DATA"> | number
    SIEGE_START_DATE?: DateTimeWithAggregatesFilter<"MuCastle_DATA"> | Date | string
    SIEGE_END_DATE?: DateTimeWithAggregatesFilter<"MuCastle_DATA"> | Date | string
    SIEGE_GUILDLIST_SETTED?: BoolWithAggregatesFilter<"MuCastle_DATA"> | boolean
    SIEGE_ENDED?: BoolWithAggregatesFilter<"MuCastle_DATA"> | boolean
    CASTLE_OCCUPY?: BoolWithAggregatesFilter<"MuCastle_DATA"> | boolean
    OWNER_GUILD?: StringWithAggregatesFilter<"MuCastle_DATA"> | string
    MONEY?: FloatWithAggregatesFilter<"MuCastle_DATA"> | number
    TAX_RATE_CHAOS?: IntWithAggregatesFilter<"MuCastle_DATA"> | number
    TAX_RATE_STORE?: IntWithAggregatesFilter<"MuCastle_DATA"> | number
    TAX_HUNT_ZONE?: IntWithAggregatesFilter<"MuCastle_DATA"> | number
  }

  export type MuCastle_NPCWhereInput = {
    AND?: MuCastle_NPCWhereInput | MuCastle_NPCWhereInput[]
    OR?: MuCastle_NPCWhereInput[]
    NOT?: MuCastle_NPCWhereInput | MuCastle_NPCWhereInput[]
    MAP_SVR_GROUP?: IntFilter<"MuCastle_NPC"> | number
    NPC_NUMBER?: IntFilter<"MuCastle_NPC"> | number
    NPC_INDEX?: IntFilter<"MuCastle_NPC"> | number
    NPC_DF_LEVEL?: IntFilter<"MuCastle_NPC"> | number
    NPC_RG_LEVEL?: IntFilter<"MuCastle_NPC"> | number
    NPC_MAXHP?: IntFilter<"MuCastle_NPC"> | number
    NPC_HP?: IntFilter<"MuCastle_NPC"> | number
    NPC_X?: IntFilter<"MuCastle_NPC"> | number
    NPC_Y?: IntFilter<"MuCastle_NPC"> | number
    NPC_DIR?: IntFilter<"MuCastle_NPC"> | number
    NPC_CREATEDATE?: DateTimeFilter<"MuCastle_NPC"> | Date | string
  }

  export type MuCastle_NPCOrderByWithRelationInput = {
    MAP_SVR_GROUP?: SortOrder
    NPC_NUMBER?: SortOrder
    NPC_INDEX?: SortOrder
    NPC_DF_LEVEL?: SortOrder
    NPC_RG_LEVEL?: SortOrder
    NPC_MAXHP?: SortOrder
    NPC_HP?: SortOrder
    NPC_X?: SortOrder
    NPC_Y?: SortOrder
    NPC_DIR?: SortOrder
    NPC_CREATEDATE?: SortOrder
  }

  export type MuCastle_NPCWhereUniqueInput = Prisma.AtLeast<{
    MAP_SVR_GROUP_NPC_NUMBER_NPC_INDEX?: MuCastle_NPCMAP_SVR_GROUPNPC_NUMBERNPC_INDEXCompoundUniqueInput
    AND?: MuCastle_NPCWhereInput | MuCastle_NPCWhereInput[]
    OR?: MuCastle_NPCWhereInput[]
    NOT?: MuCastle_NPCWhereInput | MuCastle_NPCWhereInput[]
    MAP_SVR_GROUP?: IntFilter<"MuCastle_NPC"> | number
    NPC_NUMBER?: IntFilter<"MuCastle_NPC"> | number
    NPC_INDEX?: IntFilter<"MuCastle_NPC"> | number
    NPC_DF_LEVEL?: IntFilter<"MuCastle_NPC"> | number
    NPC_RG_LEVEL?: IntFilter<"MuCastle_NPC"> | number
    NPC_MAXHP?: IntFilter<"MuCastle_NPC"> | number
    NPC_HP?: IntFilter<"MuCastle_NPC"> | number
    NPC_X?: IntFilter<"MuCastle_NPC"> | number
    NPC_Y?: IntFilter<"MuCastle_NPC"> | number
    NPC_DIR?: IntFilter<"MuCastle_NPC"> | number
    NPC_CREATEDATE?: DateTimeFilter<"MuCastle_NPC"> | Date | string
  }, "MAP_SVR_GROUP_NPC_NUMBER_NPC_INDEX">

  export type MuCastle_NPCOrderByWithAggregationInput = {
    MAP_SVR_GROUP?: SortOrder
    NPC_NUMBER?: SortOrder
    NPC_INDEX?: SortOrder
    NPC_DF_LEVEL?: SortOrder
    NPC_RG_LEVEL?: SortOrder
    NPC_MAXHP?: SortOrder
    NPC_HP?: SortOrder
    NPC_X?: SortOrder
    NPC_Y?: SortOrder
    NPC_DIR?: SortOrder
    NPC_CREATEDATE?: SortOrder
    _count?: MuCastle_NPCCountOrderByAggregateInput
    _avg?: MuCastle_NPCAvgOrderByAggregateInput
    _max?: MuCastle_NPCMaxOrderByAggregateInput
    _min?: MuCastle_NPCMinOrderByAggregateInput
    _sum?: MuCastle_NPCSumOrderByAggregateInput
  }

  export type MuCastle_NPCScalarWhereWithAggregatesInput = {
    AND?: MuCastle_NPCScalarWhereWithAggregatesInput | MuCastle_NPCScalarWhereWithAggregatesInput[]
    OR?: MuCastle_NPCScalarWhereWithAggregatesInput[]
    NOT?: MuCastle_NPCScalarWhereWithAggregatesInput | MuCastle_NPCScalarWhereWithAggregatesInput[]
    MAP_SVR_GROUP?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_NUMBER?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_INDEX?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_DF_LEVEL?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_RG_LEVEL?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_MAXHP?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_HP?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_X?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_Y?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_DIR?: IntWithAggregatesFilter<"MuCastle_NPC"> | number
    NPC_CREATEDATE?: DateTimeWithAggregatesFilter<"MuCastle_NPC"> | Date | string
  }

  export type MuCastle_REG_SIEGEWhereInput = {
    AND?: MuCastle_REG_SIEGEWhereInput | MuCastle_REG_SIEGEWhereInput[]
    OR?: MuCastle_REG_SIEGEWhereInput[]
    NOT?: MuCastle_REG_SIEGEWhereInput | MuCastle_REG_SIEGEWhereInput[]
    MAP_SVR_GROUP?: IntFilter<"MuCastle_REG_SIEGE"> | number
    REG_SIEGE_GUILD?: StringFilter<"MuCastle_REG_SIEGE"> | string
    REG_MARKS?: IntFilter<"MuCastle_REG_SIEGE"> | number
    IS_GIVEUP?: IntFilter<"MuCastle_REG_SIEGE"> | number
    SEQ_NUM?: IntFilter<"MuCastle_REG_SIEGE"> | number
  }

  export type MuCastle_REG_SIEGEOrderByWithRelationInput = {
    MAP_SVR_GROUP?: SortOrder
    REG_SIEGE_GUILD?: SortOrder
    REG_MARKS?: SortOrder
    IS_GIVEUP?: SortOrder
    SEQ_NUM?: SortOrder
  }

  export type MuCastle_REG_SIEGEWhereUniqueInput = Prisma.AtLeast<{
    MAP_SVR_GROUP_REG_SIEGE_GUILD?: MuCastle_REG_SIEGEMAP_SVR_GROUPREG_SIEGE_GUILDCompoundUniqueInput
    AND?: MuCastle_REG_SIEGEWhereInput | MuCastle_REG_SIEGEWhereInput[]
    OR?: MuCastle_REG_SIEGEWhereInput[]
    NOT?: MuCastle_REG_SIEGEWhereInput | MuCastle_REG_SIEGEWhereInput[]
    MAP_SVR_GROUP?: IntFilter<"MuCastle_REG_SIEGE"> | number
    REG_SIEGE_GUILD?: StringFilter<"MuCastle_REG_SIEGE"> | string
    REG_MARKS?: IntFilter<"MuCastle_REG_SIEGE"> | number
    IS_GIVEUP?: IntFilter<"MuCastle_REG_SIEGE"> | number
    SEQ_NUM?: IntFilter<"MuCastle_REG_SIEGE"> | number
  }, "MAP_SVR_GROUP_REG_SIEGE_GUILD">

  export type MuCastle_REG_SIEGEOrderByWithAggregationInput = {
    MAP_SVR_GROUP?: SortOrder
    REG_SIEGE_GUILD?: SortOrder
    REG_MARKS?: SortOrder
    IS_GIVEUP?: SortOrder
    SEQ_NUM?: SortOrder
    _count?: MuCastle_REG_SIEGECountOrderByAggregateInput
    _avg?: MuCastle_REG_SIEGEAvgOrderByAggregateInput
    _max?: MuCastle_REG_SIEGEMaxOrderByAggregateInput
    _min?: MuCastle_REG_SIEGEMinOrderByAggregateInput
    _sum?: MuCastle_REG_SIEGESumOrderByAggregateInput
  }

  export type MuCastle_REG_SIEGEScalarWhereWithAggregatesInput = {
    AND?: MuCastle_REG_SIEGEScalarWhereWithAggregatesInput | MuCastle_REG_SIEGEScalarWhereWithAggregatesInput[]
    OR?: MuCastle_REG_SIEGEScalarWhereWithAggregatesInput[]
    NOT?: MuCastle_REG_SIEGEScalarWhereWithAggregatesInput | MuCastle_REG_SIEGEScalarWhereWithAggregatesInput[]
    MAP_SVR_GROUP?: IntWithAggregatesFilter<"MuCastle_REG_SIEGE"> | number
    REG_SIEGE_GUILD?: StringWithAggregatesFilter<"MuCastle_REG_SIEGE"> | string
    REG_MARKS?: IntWithAggregatesFilter<"MuCastle_REG_SIEGE"> | number
    IS_GIVEUP?: IntWithAggregatesFilter<"MuCastle_REG_SIEGE"> | number
    SEQ_NUM?: IntWithAggregatesFilter<"MuCastle_REG_SIEGE"> | number
  }

  export type OptionDataWhereInput = {
    AND?: OptionDataWhereInput | OptionDataWhereInput[]
    OR?: OptionDataWhereInput[]
    NOT?: OptionDataWhereInput | OptionDataWhereInput[]
    Name?: StringFilter<"OptionData"> | string
    SkillKey?: BytesNullableFilter<"OptionData"> | Buffer | null
    GameOption?: IntNullableFilter<"OptionData"> | number | null
    Qkey?: IntNullableFilter<"OptionData"> | number | null
    Wkey?: IntNullableFilter<"OptionData"> | number | null
    Ekey?: IntNullableFilter<"OptionData"> | number | null
    ChatWindow?: IntNullableFilter<"OptionData"> | number | null
    Rkey?: IntNullableFilter<"OptionData"> | number | null
    QWERLevel?: IntNullableFilter<"OptionData"> | number | null
  }

  export type OptionDataOrderByWithRelationInput = {
    Name?: SortOrder
    SkillKey?: SortOrderInput | SortOrder
    GameOption?: SortOrderInput | SortOrder
    Qkey?: SortOrderInput | SortOrder
    Wkey?: SortOrderInput | SortOrder
    Ekey?: SortOrderInput | SortOrder
    ChatWindow?: SortOrderInput | SortOrder
    Rkey?: SortOrderInput | SortOrder
    QWERLevel?: SortOrderInput | SortOrder
  }

  export type OptionDataWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: OptionDataWhereInput | OptionDataWhereInput[]
    OR?: OptionDataWhereInput[]
    NOT?: OptionDataWhereInput | OptionDataWhereInput[]
    SkillKey?: BytesNullableFilter<"OptionData"> | Buffer | null
    GameOption?: IntNullableFilter<"OptionData"> | number | null
    Qkey?: IntNullableFilter<"OptionData"> | number | null
    Wkey?: IntNullableFilter<"OptionData"> | number | null
    Ekey?: IntNullableFilter<"OptionData"> | number | null
    ChatWindow?: IntNullableFilter<"OptionData"> | number | null
    Rkey?: IntNullableFilter<"OptionData"> | number | null
    QWERLevel?: IntNullableFilter<"OptionData"> | number | null
  }, "Name">

  export type OptionDataOrderByWithAggregationInput = {
    Name?: SortOrder
    SkillKey?: SortOrderInput | SortOrder
    GameOption?: SortOrderInput | SortOrder
    Qkey?: SortOrderInput | SortOrder
    Wkey?: SortOrderInput | SortOrder
    Ekey?: SortOrderInput | SortOrder
    ChatWindow?: SortOrderInput | SortOrder
    Rkey?: SortOrderInput | SortOrder
    QWERLevel?: SortOrderInput | SortOrder
    _count?: OptionDataCountOrderByAggregateInput
    _avg?: OptionDataAvgOrderByAggregateInput
    _max?: OptionDataMaxOrderByAggregateInput
    _min?: OptionDataMinOrderByAggregateInput
    _sum?: OptionDataSumOrderByAggregateInput
  }

  export type OptionDataScalarWhereWithAggregatesInput = {
    AND?: OptionDataScalarWhereWithAggregatesInput | OptionDataScalarWhereWithAggregatesInput[]
    OR?: OptionDataScalarWhereWithAggregatesInput[]
    NOT?: OptionDataScalarWhereWithAggregatesInput | OptionDataScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"OptionData"> | string
    SkillKey?: BytesNullableWithAggregatesFilter<"OptionData"> | Buffer | null
    GameOption?: IntNullableWithAggregatesFilter<"OptionData"> | number | null
    Qkey?: IntNullableWithAggregatesFilter<"OptionData"> | number | null
    Wkey?: IntNullableWithAggregatesFilter<"OptionData"> | number | null
    Ekey?: IntNullableWithAggregatesFilter<"OptionData"> | number | null
    ChatWindow?: IntNullableWithAggregatesFilter<"OptionData"> | number | null
    Rkey?: IntNullableWithAggregatesFilter<"OptionData"> | number | null
    QWERLevel?: IntNullableWithAggregatesFilter<"OptionData"> | number | null
  }

  export type QuestKillCountWhereInput = {
    AND?: QuestKillCountWhereInput | QuestKillCountWhereInput[]
    OR?: QuestKillCountWhereInput[]
    NOT?: QuestKillCountWhereInput | QuestKillCountWhereInput[]
    Name?: StringFilter<"QuestKillCount"> | string
    QuestIndex?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass1?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount1?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass2?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount2?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass3?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount3?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass4?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount4?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass5?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount5?: IntNullableFilter<"QuestKillCount"> | number | null
  }

  export type QuestKillCountOrderByWithRelationInput = {
    Name?: SortOrder
    QuestIndex?: SortOrderInput | SortOrder
    MonsterClass1?: SortOrderInput | SortOrder
    KillCount1?: SortOrderInput | SortOrder
    MonsterClass2?: SortOrderInput | SortOrder
    KillCount2?: SortOrderInput | SortOrder
    MonsterClass3?: SortOrderInput | SortOrder
    KillCount3?: SortOrderInput | SortOrder
    MonsterClass4?: SortOrderInput | SortOrder
    KillCount4?: SortOrderInput | SortOrder
    MonsterClass5?: SortOrderInput | SortOrder
    KillCount5?: SortOrderInput | SortOrder
  }

  export type QuestKillCountWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: QuestKillCountWhereInput | QuestKillCountWhereInput[]
    OR?: QuestKillCountWhereInput[]
    NOT?: QuestKillCountWhereInput | QuestKillCountWhereInput[]
    QuestIndex?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass1?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount1?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass2?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount2?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass3?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount3?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass4?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount4?: IntNullableFilter<"QuestKillCount"> | number | null
    MonsterClass5?: IntNullableFilter<"QuestKillCount"> | number | null
    KillCount5?: IntNullableFilter<"QuestKillCount"> | number | null
  }, "Name">

  export type QuestKillCountOrderByWithAggregationInput = {
    Name?: SortOrder
    QuestIndex?: SortOrderInput | SortOrder
    MonsterClass1?: SortOrderInput | SortOrder
    KillCount1?: SortOrderInput | SortOrder
    MonsterClass2?: SortOrderInput | SortOrder
    KillCount2?: SortOrderInput | SortOrder
    MonsterClass3?: SortOrderInput | SortOrder
    KillCount3?: SortOrderInput | SortOrder
    MonsterClass4?: SortOrderInput | SortOrder
    KillCount4?: SortOrderInput | SortOrder
    MonsterClass5?: SortOrderInput | SortOrder
    KillCount5?: SortOrderInput | SortOrder
    _count?: QuestKillCountCountOrderByAggregateInput
    _avg?: QuestKillCountAvgOrderByAggregateInput
    _max?: QuestKillCountMaxOrderByAggregateInput
    _min?: QuestKillCountMinOrderByAggregateInput
    _sum?: QuestKillCountSumOrderByAggregateInput
  }

  export type QuestKillCountScalarWhereWithAggregatesInput = {
    AND?: QuestKillCountScalarWhereWithAggregatesInput | QuestKillCountScalarWhereWithAggregatesInput[]
    OR?: QuestKillCountScalarWhereWithAggregatesInput[]
    NOT?: QuestKillCountScalarWhereWithAggregatesInput | QuestKillCountScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"QuestKillCount"> | string
    QuestIndex?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    MonsterClass1?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    KillCount1?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    MonsterClass2?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    KillCount2?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    MonsterClass3?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    KillCount3?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    MonsterClass4?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    KillCount4?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    MonsterClass5?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
    KillCount5?: IntNullableWithAggregatesFilter<"QuestKillCount"> | number | null
  }

  export type QuestWorldWhereInput = {
    AND?: QuestWorldWhereInput | QuestWorldWhereInput[]
    OR?: QuestWorldWhereInput[]
    NOT?: QuestWorldWhereInput | QuestWorldWhereInput[]
    Name?: StringFilter<"QuestWorld"> | string
    QuestWorldList?: BytesNullableFilter<"QuestWorld"> | Buffer | null
  }

  export type QuestWorldOrderByWithRelationInput = {
    Name?: SortOrder
    QuestWorldList?: SortOrderInput | SortOrder
  }

  export type QuestWorldWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: QuestWorldWhereInput | QuestWorldWhereInput[]
    OR?: QuestWorldWhereInput[]
    NOT?: QuestWorldWhereInput | QuestWorldWhereInput[]
    QuestWorldList?: BytesNullableFilter<"QuestWorld"> | Buffer | null
  }, "Name">

  export type QuestWorldOrderByWithAggregationInput = {
    Name?: SortOrder
    QuestWorldList?: SortOrderInput | SortOrder
    _count?: QuestWorldCountOrderByAggregateInput
    _max?: QuestWorldMaxOrderByAggregateInput
    _min?: QuestWorldMinOrderByAggregateInput
  }

  export type QuestWorldScalarWhereWithAggregatesInput = {
    AND?: QuestWorldScalarWhereWithAggregatesInput | QuestWorldScalarWhereWithAggregatesInput[]
    OR?: QuestWorldScalarWhereWithAggregatesInput[]
    NOT?: QuestWorldScalarWhereWithAggregatesInput | QuestWorldScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"QuestWorld"> | string
    QuestWorldList?: BytesNullableWithAggregatesFilter<"QuestWorld"> | Buffer | null
  }

  export type RankingBloodCastleWhereInput = {
    AND?: RankingBloodCastleWhereInput | RankingBloodCastleWhereInput[]
    OR?: RankingBloodCastleWhereInput[]
    NOT?: RankingBloodCastleWhereInput | RankingBloodCastleWhereInput[]
    Name?: StringFilter<"RankingBloodCastle"> | string
    Score?: IntNullableFilter<"RankingBloodCastle"> | number | null
  }

  export type RankingBloodCastleOrderByWithRelationInput = {
    Name?: SortOrder
    Score?: SortOrderInput | SortOrder
  }

  export type RankingBloodCastleWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: RankingBloodCastleWhereInput | RankingBloodCastleWhereInput[]
    OR?: RankingBloodCastleWhereInput[]
    NOT?: RankingBloodCastleWhereInput | RankingBloodCastleWhereInput[]
    Score?: IntNullableFilter<"RankingBloodCastle"> | number | null
  }, "Name">

  export type RankingBloodCastleOrderByWithAggregationInput = {
    Name?: SortOrder
    Score?: SortOrderInput | SortOrder
    _count?: RankingBloodCastleCountOrderByAggregateInput
    _avg?: RankingBloodCastleAvgOrderByAggregateInput
    _max?: RankingBloodCastleMaxOrderByAggregateInput
    _min?: RankingBloodCastleMinOrderByAggregateInput
    _sum?: RankingBloodCastleSumOrderByAggregateInput
  }

  export type RankingBloodCastleScalarWhereWithAggregatesInput = {
    AND?: RankingBloodCastleScalarWhereWithAggregatesInput | RankingBloodCastleScalarWhereWithAggregatesInput[]
    OR?: RankingBloodCastleScalarWhereWithAggregatesInput[]
    NOT?: RankingBloodCastleScalarWhereWithAggregatesInput | RankingBloodCastleScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"RankingBloodCastle"> | string
    Score?: IntNullableWithAggregatesFilter<"RankingBloodCastle"> | number | null
  }

  export type RankingChaosCastleWhereInput = {
    AND?: RankingChaosCastleWhereInput | RankingChaosCastleWhereInput[]
    OR?: RankingChaosCastleWhereInput[]
    NOT?: RankingChaosCastleWhereInput | RankingChaosCastleWhereInput[]
    Name?: StringFilter<"RankingChaosCastle"> | string
    Score?: IntNullableFilter<"RankingChaosCastle"> | number | null
  }

  export type RankingChaosCastleOrderByWithRelationInput = {
    Name?: SortOrder
    Score?: SortOrderInput | SortOrder
  }

  export type RankingChaosCastleWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: RankingChaosCastleWhereInput | RankingChaosCastleWhereInput[]
    OR?: RankingChaosCastleWhereInput[]
    NOT?: RankingChaosCastleWhereInput | RankingChaosCastleWhereInput[]
    Score?: IntNullableFilter<"RankingChaosCastle"> | number | null
  }, "Name">

  export type RankingChaosCastleOrderByWithAggregationInput = {
    Name?: SortOrder
    Score?: SortOrderInput | SortOrder
    _count?: RankingChaosCastleCountOrderByAggregateInput
    _avg?: RankingChaosCastleAvgOrderByAggregateInput
    _max?: RankingChaosCastleMaxOrderByAggregateInput
    _min?: RankingChaosCastleMinOrderByAggregateInput
    _sum?: RankingChaosCastleSumOrderByAggregateInput
  }

  export type RankingChaosCastleScalarWhereWithAggregatesInput = {
    AND?: RankingChaosCastleScalarWhereWithAggregatesInput | RankingChaosCastleScalarWhereWithAggregatesInput[]
    OR?: RankingChaosCastleScalarWhereWithAggregatesInput[]
    NOT?: RankingChaosCastleScalarWhereWithAggregatesInput | RankingChaosCastleScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"RankingChaosCastle"> | string
    Score?: IntNullableWithAggregatesFilter<"RankingChaosCastle"> | number | null
  }

  export type RankingDevilSquareWhereInput = {
    AND?: RankingDevilSquareWhereInput | RankingDevilSquareWhereInput[]
    OR?: RankingDevilSquareWhereInput[]
    NOT?: RankingDevilSquareWhereInput | RankingDevilSquareWhereInput[]
    Name?: StringFilter<"RankingDevilSquare"> | string
    Score?: IntNullableFilter<"RankingDevilSquare"> | number | null
  }

  export type RankingDevilSquareOrderByWithRelationInput = {
    Name?: SortOrder
    Score?: SortOrderInput | SortOrder
  }

  export type RankingDevilSquareWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: RankingDevilSquareWhereInput | RankingDevilSquareWhereInput[]
    OR?: RankingDevilSquareWhereInput[]
    NOT?: RankingDevilSquareWhereInput | RankingDevilSquareWhereInput[]
    Score?: IntNullableFilter<"RankingDevilSquare"> | number | null
  }, "Name">

  export type RankingDevilSquareOrderByWithAggregationInput = {
    Name?: SortOrder
    Score?: SortOrderInput | SortOrder
    _count?: RankingDevilSquareCountOrderByAggregateInput
    _avg?: RankingDevilSquareAvgOrderByAggregateInput
    _max?: RankingDevilSquareMaxOrderByAggregateInput
    _min?: RankingDevilSquareMinOrderByAggregateInput
    _sum?: RankingDevilSquareSumOrderByAggregateInput
  }

  export type RankingDevilSquareScalarWhereWithAggregatesInput = {
    AND?: RankingDevilSquareScalarWhereWithAggregatesInput | RankingDevilSquareScalarWhereWithAggregatesInput[]
    OR?: RankingDevilSquareScalarWhereWithAggregatesInput[]
    NOT?: RankingDevilSquareScalarWhereWithAggregatesInput | RankingDevilSquareScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"RankingDevilSquare"> | string
    Score?: IntNullableWithAggregatesFilter<"RankingDevilSquare"> | number | null
  }

  export type RankingDuelWhereInput = {
    AND?: RankingDuelWhereInput | RankingDuelWhereInput[]
    OR?: RankingDuelWhereInput[]
    NOT?: RankingDuelWhereInput | RankingDuelWhereInput[]
    Name?: StringFilter<"RankingDuel"> | string
    WinScore?: IntNullableFilter<"RankingDuel"> | number | null
    LoseScore?: IntNullableFilter<"RankingDuel"> | number | null
  }

  export type RankingDuelOrderByWithRelationInput = {
    Name?: SortOrder
    WinScore?: SortOrderInput | SortOrder
    LoseScore?: SortOrderInput | SortOrder
  }

  export type RankingDuelWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: RankingDuelWhereInput | RankingDuelWhereInput[]
    OR?: RankingDuelWhereInput[]
    NOT?: RankingDuelWhereInput | RankingDuelWhereInput[]
    WinScore?: IntNullableFilter<"RankingDuel"> | number | null
    LoseScore?: IntNullableFilter<"RankingDuel"> | number | null
  }, "Name">

  export type RankingDuelOrderByWithAggregationInput = {
    Name?: SortOrder
    WinScore?: SortOrderInput | SortOrder
    LoseScore?: SortOrderInput | SortOrder
    _count?: RankingDuelCountOrderByAggregateInput
    _avg?: RankingDuelAvgOrderByAggregateInput
    _max?: RankingDuelMaxOrderByAggregateInput
    _min?: RankingDuelMinOrderByAggregateInput
    _sum?: RankingDuelSumOrderByAggregateInput
  }

  export type RankingDuelScalarWhereWithAggregatesInput = {
    AND?: RankingDuelScalarWhereWithAggregatesInput | RankingDuelScalarWhereWithAggregatesInput[]
    OR?: RankingDuelScalarWhereWithAggregatesInput[]
    NOT?: RankingDuelScalarWhereWithAggregatesInput | RankingDuelScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"RankingDuel"> | string
    WinScore?: IntNullableWithAggregatesFilter<"RankingDuel"> | number | null
    LoseScore?: IntNullableWithAggregatesFilter<"RankingDuel"> | number | null
  }

  export type RankingIllusionTempleWhereInput = {
    AND?: RankingIllusionTempleWhereInput | RankingIllusionTempleWhereInput[]
    OR?: RankingIllusionTempleWhereInput[]
    NOT?: RankingIllusionTempleWhereInput | RankingIllusionTempleWhereInput[]
    Name?: StringFilter<"RankingIllusionTemple"> | string
    Score?: IntNullableFilter<"RankingIllusionTemple"> | number | null
  }

  export type RankingIllusionTempleOrderByWithRelationInput = {
    Name?: SortOrder
    Score?: SortOrderInput | SortOrder
  }

  export type RankingIllusionTempleWhereUniqueInput = Prisma.AtLeast<{
    Name?: string
    AND?: RankingIllusionTempleWhereInput | RankingIllusionTempleWhereInput[]
    OR?: RankingIllusionTempleWhereInput[]
    NOT?: RankingIllusionTempleWhereInput | RankingIllusionTempleWhereInput[]
    Score?: IntNullableFilter<"RankingIllusionTemple"> | number | null
  }, "Name">

  export type RankingIllusionTempleOrderByWithAggregationInput = {
    Name?: SortOrder
    Score?: SortOrderInput | SortOrder
    _count?: RankingIllusionTempleCountOrderByAggregateInput
    _avg?: RankingIllusionTempleAvgOrderByAggregateInput
    _max?: RankingIllusionTempleMaxOrderByAggregateInput
    _min?: RankingIllusionTempleMinOrderByAggregateInput
    _sum?: RankingIllusionTempleSumOrderByAggregateInput
  }

  export type RankingIllusionTempleScalarWhereWithAggregatesInput = {
    AND?: RankingIllusionTempleScalarWhereWithAggregatesInput | RankingIllusionTempleScalarWhereWithAggregatesInput[]
    OR?: RankingIllusionTempleScalarWhereWithAggregatesInput[]
    NOT?: RankingIllusionTempleScalarWhereWithAggregatesInput | RankingIllusionTempleScalarWhereWithAggregatesInput[]
    Name?: StringWithAggregatesFilter<"RankingIllusionTemple"> | string
    Score?: IntNullableWithAggregatesFilter<"RankingIllusionTemple"> | number | null
  }

  export type T_CGuidWhereInput = {
    AND?: T_CGuidWhereInput | T_CGuidWhereInput[]
    OR?: T_CGuidWhereInput[]
    NOT?: T_CGuidWhereInput | T_CGuidWhereInput[]
    GUID?: IntFilter<"T_CGuid"> | number
    Name?: StringFilter<"T_CGuid"> | string
  }

  export type T_CGuidOrderByWithRelationInput = {
    GUID?: SortOrder
    Name?: SortOrder
  }

  export type T_CGuidWhereUniqueInput = Prisma.AtLeast<{
    GUID?: number
    AND?: T_CGuidWhereInput | T_CGuidWhereInput[]
    OR?: T_CGuidWhereInput[]
    NOT?: T_CGuidWhereInput | T_CGuidWhereInput[]
    Name?: StringFilter<"T_CGuid"> | string
  }, "GUID">

  export type T_CGuidOrderByWithAggregationInput = {
    GUID?: SortOrder
    Name?: SortOrder
    _count?: T_CGuidCountOrderByAggregateInput
    _avg?: T_CGuidAvgOrderByAggregateInput
    _max?: T_CGuidMaxOrderByAggregateInput
    _min?: T_CGuidMinOrderByAggregateInput
    _sum?: T_CGuidSumOrderByAggregateInput
  }

  export type T_CGuidScalarWhereWithAggregatesInput = {
    AND?: T_CGuidScalarWhereWithAggregatesInput | T_CGuidScalarWhereWithAggregatesInput[]
    OR?: T_CGuidScalarWhereWithAggregatesInput[]
    NOT?: T_CGuidScalarWhereWithAggregatesInput | T_CGuidScalarWhereWithAggregatesInput[]
    GUID?: IntWithAggregatesFilter<"T_CGuid"> | number
    Name?: StringWithAggregatesFilter<"T_CGuid"> | string
  }

  export type T_FriendMailWhereInput = {
    AND?: T_FriendMailWhereInput | T_FriendMailWhereInput[]
    OR?: T_FriendMailWhereInput[]
    NOT?: T_FriendMailWhereInput | T_FriendMailWhereInput[]
    MemoIndex?: IntFilter<"T_FriendMail"> | number
    GUID?: IntFilter<"T_FriendMail"> | number
    FriendName?: StringNullableFilter<"T_FriendMail"> | string | null
    wDate?: DateTimeFilter<"T_FriendMail"> | Date | string
    Subject?: StringNullableFilter<"T_FriendMail"> | string | null
    bRead?: BoolFilter<"T_FriendMail"> | boolean
    Memo?: BytesNullableFilter<"T_FriendMail"> | Buffer | null
    Photo?: BytesNullableFilter<"T_FriendMail"> | Buffer | null
    Dir?: IntNullableFilter<"T_FriendMail"> | number | null
    Act?: IntNullableFilter<"T_FriendMail"> | number | null
  }

  export type T_FriendMailOrderByWithRelationInput = {
    MemoIndex?: SortOrder
    GUID?: SortOrder
    FriendName?: SortOrderInput | SortOrder
    wDate?: SortOrder
    Subject?: SortOrderInput | SortOrder
    bRead?: SortOrder
    Memo?: SortOrderInput | SortOrder
    Photo?: SortOrderInput | SortOrder
    Dir?: SortOrderInput | SortOrder
    Act?: SortOrderInput | SortOrder
  }

  export type T_FriendMailWhereUniqueInput = Prisma.AtLeast<{
    GUID_MemoIndex?: T_FriendMailGUIDMemoIndexCompoundUniqueInput
    AND?: T_FriendMailWhereInput | T_FriendMailWhereInput[]
    OR?: T_FriendMailWhereInput[]
    NOT?: T_FriendMailWhereInput | T_FriendMailWhereInput[]
    MemoIndex?: IntFilter<"T_FriendMail"> | number
    GUID?: IntFilter<"T_FriendMail"> | number
    FriendName?: StringNullableFilter<"T_FriendMail"> | string | null
    wDate?: DateTimeFilter<"T_FriendMail"> | Date | string
    Subject?: StringNullableFilter<"T_FriendMail"> | string | null
    bRead?: BoolFilter<"T_FriendMail"> | boolean
    Memo?: BytesNullableFilter<"T_FriendMail"> | Buffer | null
    Photo?: BytesNullableFilter<"T_FriendMail"> | Buffer | null
    Dir?: IntNullableFilter<"T_FriendMail"> | number | null
    Act?: IntNullableFilter<"T_FriendMail"> | number | null
  }, "GUID_MemoIndex">

  export type T_FriendMailOrderByWithAggregationInput = {
    MemoIndex?: SortOrder
    GUID?: SortOrder
    FriendName?: SortOrderInput | SortOrder
    wDate?: SortOrder
    Subject?: SortOrderInput | SortOrder
    bRead?: SortOrder
    Memo?: SortOrderInput | SortOrder
    Photo?: SortOrderInput | SortOrder
    Dir?: SortOrderInput | SortOrder
    Act?: SortOrderInput | SortOrder
    _count?: T_FriendMailCountOrderByAggregateInput
    _avg?: T_FriendMailAvgOrderByAggregateInput
    _max?: T_FriendMailMaxOrderByAggregateInput
    _min?: T_FriendMailMinOrderByAggregateInput
    _sum?: T_FriendMailSumOrderByAggregateInput
  }

  export type T_FriendMailScalarWhereWithAggregatesInput = {
    AND?: T_FriendMailScalarWhereWithAggregatesInput | T_FriendMailScalarWhereWithAggregatesInput[]
    OR?: T_FriendMailScalarWhereWithAggregatesInput[]
    NOT?: T_FriendMailScalarWhereWithAggregatesInput | T_FriendMailScalarWhereWithAggregatesInput[]
    MemoIndex?: IntWithAggregatesFilter<"T_FriendMail"> | number
    GUID?: IntWithAggregatesFilter<"T_FriendMail"> | number
    FriendName?: StringNullableWithAggregatesFilter<"T_FriendMail"> | string | null
    wDate?: DateTimeWithAggregatesFilter<"T_FriendMail"> | Date | string
    Subject?: StringNullableWithAggregatesFilter<"T_FriendMail"> | string | null
    bRead?: BoolWithAggregatesFilter<"T_FriendMail"> | boolean
    Memo?: BytesNullableWithAggregatesFilter<"T_FriendMail"> | Buffer | null
    Photo?: BytesNullableWithAggregatesFilter<"T_FriendMail"> | Buffer | null
    Dir?: IntNullableWithAggregatesFilter<"T_FriendMail"> | number | null
    Act?: IntNullableWithAggregatesFilter<"T_FriendMail"> | number | null
  }

  export type T_FriendMainWhereInput = {
    AND?: T_FriendMainWhereInput | T_FriendMainWhereInput[]
    OR?: T_FriendMainWhereInput[]
    NOT?: T_FriendMainWhereInput | T_FriendMainWhereInput[]
    GUID?: IntFilter<"T_FriendMain"> | number
    Name?: StringFilter<"T_FriendMain"> | string
    FriendCount?: IntNullableFilter<"T_FriendMain"> | number | null
    MemoCount?: IntNullableFilter<"T_FriendMain"> | number | null
    MemoTotal?: IntNullableFilter<"T_FriendMain"> | number | null
  }

  export type T_FriendMainOrderByWithRelationInput = {
    GUID?: SortOrder
    Name?: SortOrder
    FriendCount?: SortOrderInput | SortOrder
    MemoCount?: SortOrderInput | SortOrder
    MemoTotal?: SortOrderInput | SortOrder
  }

  export type T_FriendMainWhereUniqueInput = Prisma.AtLeast<{
    GUID?: number
    AND?: T_FriendMainWhereInput | T_FriendMainWhereInput[]
    OR?: T_FriendMainWhereInput[]
    NOT?: T_FriendMainWhereInput | T_FriendMainWhereInput[]
    Name?: StringFilter<"T_FriendMain"> | string
    FriendCount?: IntNullableFilter<"T_FriendMain"> | number | null
    MemoCount?: IntNullableFilter<"T_FriendMain"> | number | null
    MemoTotal?: IntNullableFilter<"T_FriendMain"> | number | null
  }, "GUID">

  export type T_FriendMainOrderByWithAggregationInput = {
    GUID?: SortOrder
    Name?: SortOrder
    FriendCount?: SortOrderInput | SortOrder
    MemoCount?: SortOrderInput | SortOrder
    MemoTotal?: SortOrderInput | SortOrder
    _count?: T_FriendMainCountOrderByAggregateInput
    _avg?: T_FriendMainAvgOrderByAggregateInput
    _max?: T_FriendMainMaxOrderByAggregateInput
    _min?: T_FriendMainMinOrderByAggregateInput
    _sum?: T_FriendMainSumOrderByAggregateInput
  }

  export type T_FriendMainScalarWhereWithAggregatesInput = {
    AND?: T_FriendMainScalarWhereWithAggregatesInput | T_FriendMainScalarWhereWithAggregatesInput[]
    OR?: T_FriendMainScalarWhereWithAggregatesInput[]
    NOT?: T_FriendMainScalarWhereWithAggregatesInput | T_FriendMainScalarWhereWithAggregatesInput[]
    GUID?: IntWithAggregatesFilter<"T_FriendMain"> | number
    Name?: StringWithAggregatesFilter<"T_FriendMain"> | string
    FriendCount?: IntNullableWithAggregatesFilter<"T_FriendMain"> | number | null
    MemoCount?: IntNullableWithAggregatesFilter<"T_FriendMain"> | number | null
    MemoTotal?: IntNullableWithAggregatesFilter<"T_FriendMain"> | number | null
  }

  export type T_PetItem_InfoWhereInput = {
    AND?: T_PetItem_InfoWhereInput | T_PetItem_InfoWhereInput[]
    OR?: T_PetItem_InfoWhereInput[]
    NOT?: T_PetItem_InfoWhereInput | T_PetItem_InfoWhereInput[]
    ItemSerial?: IntFilter<"T_PetItem_Info"> | number
    Pet_Level?: IntNullableFilter<"T_PetItem_Info"> | number | null
    Pet_Exp?: IntNullableFilter<"T_PetItem_Info"> | number | null
  }

  export type T_PetItem_InfoOrderByWithRelationInput = {
    ItemSerial?: SortOrder
    Pet_Level?: SortOrderInput | SortOrder
    Pet_Exp?: SortOrderInput | SortOrder
  }

  export type T_PetItem_InfoWhereUniqueInput = Prisma.AtLeast<{
    ItemSerial?: number
    AND?: T_PetItem_InfoWhereInput | T_PetItem_InfoWhereInput[]
    OR?: T_PetItem_InfoWhereInput[]
    NOT?: T_PetItem_InfoWhereInput | T_PetItem_InfoWhereInput[]
    Pet_Level?: IntNullableFilter<"T_PetItem_Info"> | number | null
    Pet_Exp?: IntNullableFilter<"T_PetItem_Info"> | number | null
  }, "ItemSerial">

  export type T_PetItem_InfoOrderByWithAggregationInput = {
    ItemSerial?: SortOrder
    Pet_Level?: SortOrderInput | SortOrder
    Pet_Exp?: SortOrderInput | SortOrder
    _count?: T_PetItem_InfoCountOrderByAggregateInput
    _avg?: T_PetItem_InfoAvgOrderByAggregateInput
    _max?: T_PetItem_InfoMaxOrderByAggregateInput
    _min?: T_PetItem_InfoMinOrderByAggregateInput
    _sum?: T_PetItem_InfoSumOrderByAggregateInput
  }

  export type T_PetItem_InfoScalarWhereWithAggregatesInput = {
    AND?: T_PetItem_InfoScalarWhereWithAggregatesInput | T_PetItem_InfoScalarWhereWithAggregatesInput[]
    OR?: T_PetItem_InfoScalarWhereWithAggregatesInput[]
    NOT?: T_PetItem_InfoScalarWhereWithAggregatesInput | T_PetItem_InfoScalarWhereWithAggregatesInput[]
    ItemSerial?: IntWithAggregatesFilter<"T_PetItem_Info"> | number
    Pet_Level?: IntNullableWithAggregatesFilter<"T_PetItem_Info"> | number | null
    Pet_Exp?: IntNullableWithAggregatesFilter<"T_PetItem_Info"> | number | null
  }

  export type warehouseWhereInput = {
    AND?: warehouseWhereInput | warehouseWhereInput[]
    OR?: warehouseWhereInput[]
    NOT?: warehouseWhereInput | warehouseWhereInput[]
    AccountID?: StringFilter<"warehouse"> | string
    Items?: BytesNullableFilter<"warehouse"> | Buffer | null
    Money?: IntNullableFilter<"warehouse"> | number | null
    EndUseDate?: DateTimeNullableFilter<"warehouse"> | Date | string | null
    DbVersion?: IntNullableFilter<"warehouse"> | number | null
    pw?: IntNullableFilter<"warehouse"> | number | null
    VaultCounts?: IntFilter<"warehouse"> | number
    LastVaultID?: IntFilter<"warehouse"> | number
  }

  export type warehouseOrderByWithRelationInput = {
    AccountID?: SortOrder
    Items?: SortOrderInput | SortOrder
    Money?: SortOrderInput | SortOrder
    EndUseDate?: SortOrderInput | SortOrder
    DbVersion?: SortOrderInput | SortOrder
    pw?: SortOrderInput | SortOrder
    VaultCounts?: SortOrder
    LastVaultID?: SortOrder
  }

  export type warehouseWhereUniqueInput = Prisma.AtLeast<{
    AccountID?: string
    AND?: warehouseWhereInput | warehouseWhereInput[]
    OR?: warehouseWhereInput[]
    NOT?: warehouseWhereInput | warehouseWhereInput[]
    Items?: BytesNullableFilter<"warehouse"> | Buffer | null
    Money?: IntNullableFilter<"warehouse"> | number | null
    EndUseDate?: DateTimeNullableFilter<"warehouse"> | Date | string | null
    DbVersion?: IntNullableFilter<"warehouse"> | number | null
    pw?: IntNullableFilter<"warehouse"> | number | null
    VaultCounts?: IntFilter<"warehouse"> | number
    LastVaultID?: IntFilter<"warehouse"> | number
  }, "AccountID">

  export type warehouseOrderByWithAggregationInput = {
    AccountID?: SortOrder
    Items?: SortOrderInput | SortOrder
    Money?: SortOrderInput | SortOrder
    EndUseDate?: SortOrderInput | SortOrder
    DbVersion?: SortOrderInput | SortOrder
    pw?: SortOrderInput | SortOrder
    VaultCounts?: SortOrder
    LastVaultID?: SortOrder
    _count?: warehouseCountOrderByAggregateInput
    _avg?: warehouseAvgOrderByAggregateInput
    _max?: warehouseMaxOrderByAggregateInput
    _min?: warehouseMinOrderByAggregateInput
    _sum?: warehouseSumOrderByAggregateInput
  }

  export type warehouseScalarWhereWithAggregatesInput = {
    AND?: warehouseScalarWhereWithAggregatesInput | warehouseScalarWhereWithAggregatesInput[]
    OR?: warehouseScalarWhereWithAggregatesInput[]
    NOT?: warehouseScalarWhereWithAggregatesInput | warehouseScalarWhereWithAggregatesInput[]
    AccountID?: StringWithAggregatesFilter<"warehouse"> | string
    Items?: BytesNullableWithAggregatesFilter<"warehouse"> | Buffer | null
    Money?: IntNullableWithAggregatesFilter<"warehouse"> | number | null
    EndUseDate?: DateTimeNullableWithAggregatesFilter<"warehouse"> | Date | string | null
    DbVersion?: IntNullableWithAggregatesFilter<"warehouse"> | number | null
    pw?: IntNullableWithAggregatesFilter<"warehouse"> | number | null
    VaultCounts?: IntWithAggregatesFilter<"warehouse"> | number
    LastVaultID?: IntWithAggregatesFilter<"warehouse"> | number
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type MEMB_INFOCreateInput = {
    memb___id: string
    memb__pwd: string
    memb_name: string
    sno__numb: string
    post_code?: string | null
    addr_info?: string | null
    addr_deta?: string | null
    tel__numb?: string | null
    phon_numb?: string | null
    mail_addr?: string | null
    fpas_ques?: string | null
    fpas_answ?: string | null
    job__code?: string | null
    appl_days?: Date | string | null
    modi_days?: Date | string | null
    out__days?: Date | string | null
    true_days?: Date | string | null
    mail_chek?: string | null
    bloc_code: string
    ctl1_code: string
    AccountLevel?: number
    AccountExpireDate?: Date | string
    vip?: number
    cash?: number
    RewardPlayer?: number
    ChaosPoints?: number
    BlessPoints?: number
    SoulPoints?: number
    LifePoints?: number
    CreationPoints?: number
    GuardianPoints?: number
    GemstonePoints?: number
    HarmonyPoints?: number
    LRefiningPoints?: number
    HRefiningPoints?: number
    LockPassword?: number
  }

  export type MEMB_INFOUncheckedCreateInput = {
    memb_guid?: number
    memb___id: string
    memb__pwd: string
    memb_name: string
    sno__numb: string
    post_code?: string | null
    addr_info?: string | null
    addr_deta?: string | null
    tel__numb?: string | null
    phon_numb?: string | null
    mail_addr?: string | null
    fpas_ques?: string | null
    fpas_answ?: string | null
    job__code?: string | null
    appl_days?: Date | string | null
    modi_days?: Date | string | null
    out__days?: Date | string | null
    true_days?: Date | string | null
    mail_chek?: string | null
    bloc_code: string
    ctl1_code: string
    AccountLevel?: number
    AccountExpireDate?: Date | string
    vip?: number
    cash?: number
    RewardPlayer?: number
    ChaosPoints?: number
    BlessPoints?: number
    SoulPoints?: number
    LifePoints?: number
    CreationPoints?: number
    GuardianPoints?: number
    GemstonePoints?: number
    HarmonyPoints?: number
    LRefiningPoints?: number
    HRefiningPoints?: number
    LockPassword?: number
  }

  export type MEMB_INFOUpdateInput = {
    memb___id?: StringFieldUpdateOperationsInput | string
    memb__pwd?: StringFieldUpdateOperationsInput | string
    memb_name?: StringFieldUpdateOperationsInput | string
    sno__numb?: StringFieldUpdateOperationsInput | string
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    addr_info?: NullableStringFieldUpdateOperationsInput | string | null
    addr_deta?: NullableStringFieldUpdateOperationsInput | string | null
    tel__numb?: NullableStringFieldUpdateOperationsInput | string | null
    phon_numb?: NullableStringFieldUpdateOperationsInput | string | null
    mail_addr?: NullableStringFieldUpdateOperationsInput | string | null
    fpas_ques?: NullableStringFieldUpdateOperationsInput | string | null
    fpas_answ?: NullableStringFieldUpdateOperationsInput | string | null
    job__code?: NullableStringFieldUpdateOperationsInput | string | null
    appl_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modi_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    out__days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    true_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mail_chek?: NullableStringFieldUpdateOperationsInput | string | null
    bloc_code?: StringFieldUpdateOperationsInput | string
    ctl1_code?: StringFieldUpdateOperationsInput | string
    AccountLevel?: IntFieldUpdateOperationsInput | number
    AccountExpireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vip?: IntFieldUpdateOperationsInput | number
    cash?: IntFieldUpdateOperationsInput | number
    RewardPlayer?: IntFieldUpdateOperationsInput | number
    ChaosPoints?: IntFieldUpdateOperationsInput | number
    BlessPoints?: IntFieldUpdateOperationsInput | number
    SoulPoints?: IntFieldUpdateOperationsInput | number
    LifePoints?: IntFieldUpdateOperationsInput | number
    CreationPoints?: IntFieldUpdateOperationsInput | number
    GuardianPoints?: IntFieldUpdateOperationsInput | number
    GemstonePoints?: IntFieldUpdateOperationsInput | number
    HarmonyPoints?: IntFieldUpdateOperationsInput | number
    LRefiningPoints?: IntFieldUpdateOperationsInput | number
    HRefiningPoints?: IntFieldUpdateOperationsInput | number
    LockPassword?: IntFieldUpdateOperationsInput | number
  }

  export type MEMB_INFOUncheckedUpdateInput = {
    memb_guid?: IntFieldUpdateOperationsInput | number
    memb___id?: StringFieldUpdateOperationsInput | string
    memb__pwd?: StringFieldUpdateOperationsInput | string
    memb_name?: StringFieldUpdateOperationsInput | string
    sno__numb?: StringFieldUpdateOperationsInput | string
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    addr_info?: NullableStringFieldUpdateOperationsInput | string | null
    addr_deta?: NullableStringFieldUpdateOperationsInput | string | null
    tel__numb?: NullableStringFieldUpdateOperationsInput | string | null
    phon_numb?: NullableStringFieldUpdateOperationsInput | string | null
    mail_addr?: NullableStringFieldUpdateOperationsInput | string | null
    fpas_ques?: NullableStringFieldUpdateOperationsInput | string | null
    fpas_answ?: NullableStringFieldUpdateOperationsInput | string | null
    job__code?: NullableStringFieldUpdateOperationsInput | string | null
    appl_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modi_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    out__days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    true_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mail_chek?: NullableStringFieldUpdateOperationsInput | string | null
    bloc_code?: StringFieldUpdateOperationsInput | string
    ctl1_code?: StringFieldUpdateOperationsInput | string
    AccountLevel?: IntFieldUpdateOperationsInput | number
    AccountExpireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vip?: IntFieldUpdateOperationsInput | number
    cash?: IntFieldUpdateOperationsInput | number
    RewardPlayer?: IntFieldUpdateOperationsInput | number
    ChaosPoints?: IntFieldUpdateOperationsInput | number
    BlessPoints?: IntFieldUpdateOperationsInput | number
    SoulPoints?: IntFieldUpdateOperationsInput | number
    LifePoints?: IntFieldUpdateOperationsInput | number
    CreationPoints?: IntFieldUpdateOperationsInput | number
    GuardianPoints?: IntFieldUpdateOperationsInput | number
    GemstonePoints?: IntFieldUpdateOperationsInput | number
    HarmonyPoints?: IntFieldUpdateOperationsInput | number
    LRefiningPoints?: IntFieldUpdateOperationsInput | number
    HRefiningPoints?: IntFieldUpdateOperationsInput | number
    LockPassword?: IntFieldUpdateOperationsInput | number
  }

  export type MEMB_INFOCreateManyInput = {
    memb___id: string
    memb__pwd: string
    memb_name: string
    sno__numb: string
    post_code?: string | null
    addr_info?: string | null
    addr_deta?: string | null
    tel__numb?: string | null
    phon_numb?: string | null
    mail_addr?: string | null
    fpas_ques?: string | null
    fpas_answ?: string | null
    job__code?: string | null
    appl_days?: Date | string | null
    modi_days?: Date | string | null
    out__days?: Date | string | null
    true_days?: Date | string | null
    mail_chek?: string | null
    bloc_code: string
    ctl1_code: string
    AccountLevel?: number
    AccountExpireDate?: Date | string
    vip?: number
    cash?: number
    RewardPlayer?: number
    ChaosPoints?: number
    BlessPoints?: number
    SoulPoints?: number
    LifePoints?: number
    CreationPoints?: number
    GuardianPoints?: number
    GemstonePoints?: number
    HarmonyPoints?: number
    LRefiningPoints?: number
    HRefiningPoints?: number
    LockPassword?: number
  }

  export type MEMB_INFOUpdateManyMutationInput = {
    memb___id?: StringFieldUpdateOperationsInput | string
    memb__pwd?: StringFieldUpdateOperationsInput | string
    memb_name?: StringFieldUpdateOperationsInput | string
    sno__numb?: StringFieldUpdateOperationsInput | string
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    addr_info?: NullableStringFieldUpdateOperationsInput | string | null
    addr_deta?: NullableStringFieldUpdateOperationsInput | string | null
    tel__numb?: NullableStringFieldUpdateOperationsInput | string | null
    phon_numb?: NullableStringFieldUpdateOperationsInput | string | null
    mail_addr?: NullableStringFieldUpdateOperationsInput | string | null
    fpas_ques?: NullableStringFieldUpdateOperationsInput | string | null
    fpas_answ?: NullableStringFieldUpdateOperationsInput | string | null
    job__code?: NullableStringFieldUpdateOperationsInput | string | null
    appl_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modi_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    out__days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    true_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mail_chek?: NullableStringFieldUpdateOperationsInput | string | null
    bloc_code?: StringFieldUpdateOperationsInput | string
    ctl1_code?: StringFieldUpdateOperationsInput | string
    AccountLevel?: IntFieldUpdateOperationsInput | number
    AccountExpireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vip?: IntFieldUpdateOperationsInput | number
    cash?: IntFieldUpdateOperationsInput | number
    RewardPlayer?: IntFieldUpdateOperationsInput | number
    ChaosPoints?: IntFieldUpdateOperationsInput | number
    BlessPoints?: IntFieldUpdateOperationsInput | number
    SoulPoints?: IntFieldUpdateOperationsInput | number
    LifePoints?: IntFieldUpdateOperationsInput | number
    CreationPoints?: IntFieldUpdateOperationsInput | number
    GuardianPoints?: IntFieldUpdateOperationsInput | number
    GemstonePoints?: IntFieldUpdateOperationsInput | number
    HarmonyPoints?: IntFieldUpdateOperationsInput | number
    LRefiningPoints?: IntFieldUpdateOperationsInput | number
    HRefiningPoints?: IntFieldUpdateOperationsInput | number
    LockPassword?: IntFieldUpdateOperationsInput | number
  }

  export type MEMB_INFOUncheckedUpdateManyInput = {
    memb_guid?: IntFieldUpdateOperationsInput | number
    memb___id?: StringFieldUpdateOperationsInput | string
    memb__pwd?: StringFieldUpdateOperationsInput | string
    memb_name?: StringFieldUpdateOperationsInput | string
    sno__numb?: StringFieldUpdateOperationsInput | string
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    addr_info?: NullableStringFieldUpdateOperationsInput | string | null
    addr_deta?: NullableStringFieldUpdateOperationsInput | string | null
    tel__numb?: NullableStringFieldUpdateOperationsInput | string | null
    phon_numb?: NullableStringFieldUpdateOperationsInput | string | null
    mail_addr?: NullableStringFieldUpdateOperationsInput | string | null
    fpas_ques?: NullableStringFieldUpdateOperationsInput | string | null
    fpas_answ?: NullableStringFieldUpdateOperationsInput | string | null
    job__code?: NullableStringFieldUpdateOperationsInput | string | null
    appl_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modi_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    out__days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    true_days?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mail_chek?: NullableStringFieldUpdateOperationsInput | string | null
    bloc_code?: StringFieldUpdateOperationsInput | string
    ctl1_code?: StringFieldUpdateOperationsInput | string
    AccountLevel?: IntFieldUpdateOperationsInput | number
    AccountExpireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    vip?: IntFieldUpdateOperationsInput | number
    cash?: IntFieldUpdateOperationsInput | number
    RewardPlayer?: IntFieldUpdateOperationsInput | number
    ChaosPoints?: IntFieldUpdateOperationsInput | number
    BlessPoints?: IntFieldUpdateOperationsInput | number
    SoulPoints?: IntFieldUpdateOperationsInput | number
    LifePoints?: IntFieldUpdateOperationsInput | number
    CreationPoints?: IntFieldUpdateOperationsInput | number
    GuardianPoints?: IntFieldUpdateOperationsInput | number
    GemstonePoints?: IntFieldUpdateOperationsInput | number
    HarmonyPoints?: IntFieldUpdateOperationsInput | number
    LRefiningPoints?: IntFieldUpdateOperationsInput | number
    HRefiningPoints?: IntFieldUpdateOperationsInput | number
    LockPassword?: IntFieldUpdateOperationsInput | number
  }

  export type AccountCharacterCreateInput = {
    Number?: number
    Id: string
    GameID1?: string | null
    GameID2?: string | null
    GameID3?: string | null
    GameID4?: string | null
    GameID5?: string | null
    GameIDC?: string | null
    MoveCnt?: number | null
    ExtClass?: number
    ExtWarehouse?: number
    GameID6?: string | null
    GameID7?: string | null
    GameID8?: string | null
    GameID9?: string | null
    GameID10?: string | null
    MaxCharacter?: number
  }

  export type AccountCharacterUncheckedCreateInput = {
    Number?: number
    Id: string
    GameID1?: string | null
    GameID2?: string | null
    GameID3?: string | null
    GameID4?: string | null
    GameID5?: string | null
    GameIDC?: string | null
    MoveCnt?: number | null
    ExtClass?: number
    ExtWarehouse?: number
    GameID6?: string | null
    GameID7?: string | null
    GameID8?: string | null
    GameID9?: string | null
    GameID10?: string | null
    MaxCharacter?: number
  }

  export type AccountCharacterUpdateInput = {
    Number?: IntFieldUpdateOperationsInput | number
    Id?: StringFieldUpdateOperationsInput | string
    GameID1?: NullableStringFieldUpdateOperationsInput | string | null
    GameID2?: NullableStringFieldUpdateOperationsInput | string | null
    GameID3?: NullableStringFieldUpdateOperationsInput | string | null
    GameID4?: NullableStringFieldUpdateOperationsInput | string | null
    GameID5?: NullableStringFieldUpdateOperationsInput | string | null
    GameIDC?: NullableStringFieldUpdateOperationsInput | string | null
    MoveCnt?: NullableIntFieldUpdateOperationsInput | number | null
    ExtClass?: IntFieldUpdateOperationsInput | number
    ExtWarehouse?: IntFieldUpdateOperationsInput | number
    GameID6?: NullableStringFieldUpdateOperationsInput | string | null
    GameID7?: NullableStringFieldUpdateOperationsInput | string | null
    GameID8?: NullableStringFieldUpdateOperationsInput | string | null
    GameID9?: NullableStringFieldUpdateOperationsInput | string | null
    GameID10?: NullableStringFieldUpdateOperationsInput | string | null
    MaxCharacter?: IntFieldUpdateOperationsInput | number
  }

  export type AccountCharacterUncheckedUpdateInput = {
    Number?: IntFieldUpdateOperationsInput | number
    Id?: StringFieldUpdateOperationsInput | string
    GameID1?: NullableStringFieldUpdateOperationsInput | string | null
    GameID2?: NullableStringFieldUpdateOperationsInput | string | null
    GameID3?: NullableStringFieldUpdateOperationsInput | string | null
    GameID4?: NullableStringFieldUpdateOperationsInput | string | null
    GameID5?: NullableStringFieldUpdateOperationsInput | string | null
    GameIDC?: NullableStringFieldUpdateOperationsInput | string | null
    MoveCnt?: NullableIntFieldUpdateOperationsInput | number | null
    ExtClass?: IntFieldUpdateOperationsInput | number
    ExtWarehouse?: IntFieldUpdateOperationsInput | number
    GameID6?: NullableStringFieldUpdateOperationsInput | string | null
    GameID7?: NullableStringFieldUpdateOperationsInput | string | null
    GameID8?: NullableStringFieldUpdateOperationsInput | string | null
    GameID9?: NullableStringFieldUpdateOperationsInput | string | null
    GameID10?: NullableStringFieldUpdateOperationsInput | string | null
    MaxCharacter?: IntFieldUpdateOperationsInput | number
  }

  export type AccountCharacterCreateManyInput = {
    Id: string
    GameID1?: string | null
    GameID2?: string | null
    GameID3?: string | null
    GameID4?: string | null
    GameID5?: string | null
    GameIDC?: string | null
    MoveCnt?: number | null
    ExtClass?: number
    ExtWarehouse?: number
    GameID6?: string | null
    GameID7?: string | null
    GameID8?: string | null
    GameID9?: string | null
    GameID10?: string | null
    MaxCharacter?: number
  }

  export type AccountCharacterUpdateManyMutationInput = {
    Number?: IntFieldUpdateOperationsInput | number
    Id?: StringFieldUpdateOperationsInput | string
    GameID1?: NullableStringFieldUpdateOperationsInput | string | null
    GameID2?: NullableStringFieldUpdateOperationsInput | string | null
    GameID3?: NullableStringFieldUpdateOperationsInput | string | null
    GameID4?: NullableStringFieldUpdateOperationsInput | string | null
    GameID5?: NullableStringFieldUpdateOperationsInput | string | null
    GameIDC?: NullableStringFieldUpdateOperationsInput | string | null
    MoveCnt?: NullableIntFieldUpdateOperationsInput | number | null
    ExtClass?: IntFieldUpdateOperationsInput | number
    ExtWarehouse?: IntFieldUpdateOperationsInput | number
    GameID6?: NullableStringFieldUpdateOperationsInput | string | null
    GameID7?: NullableStringFieldUpdateOperationsInput | string | null
    GameID8?: NullableStringFieldUpdateOperationsInput | string | null
    GameID9?: NullableStringFieldUpdateOperationsInput | string | null
    GameID10?: NullableStringFieldUpdateOperationsInput | string | null
    MaxCharacter?: IntFieldUpdateOperationsInput | number
  }

  export type AccountCharacterUncheckedUpdateManyInput = {
    Number?: IntFieldUpdateOperationsInput | number
    Id?: StringFieldUpdateOperationsInput | string
    GameID1?: NullableStringFieldUpdateOperationsInput | string | null
    GameID2?: NullableStringFieldUpdateOperationsInput | string | null
    GameID3?: NullableStringFieldUpdateOperationsInput | string | null
    GameID4?: NullableStringFieldUpdateOperationsInput | string | null
    GameID5?: NullableStringFieldUpdateOperationsInput | string | null
    GameIDC?: NullableStringFieldUpdateOperationsInput | string | null
    MoveCnt?: NullableIntFieldUpdateOperationsInput | number | null
    ExtClass?: IntFieldUpdateOperationsInput | number
    ExtWarehouse?: IntFieldUpdateOperationsInput | number
    GameID6?: NullableStringFieldUpdateOperationsInput | string | null
    GameID7?: NullableStringFieldUpdateOperationsInput | string | null
    GameID8?: NullableStringFieldUpdateOperationsInput | string | null
    GameID9?: NullableStringFieldUpdateOperationsInput | string | null
    GameID10?: NullableStringFieldUpdateOperationsInput | string | null
    MaxCharacter?: IntFieldUpdateOperationsInput | number
  }

  export type CashShopDataCreateInput = {
    AccountID: string
    WCoinC?: number | null
    WCoinP?: number | null
    GoblinPoint?: number | null
  }

  export type CashShopDataUncheckedCreateInput = {
    AccountID: string
    WCoinC?: number | null
    WCoinP?: number | null
    GoblinPoint?: number | null
  }

  export type CashShopDataUpdateInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    WCoinC?: NullableIntFieldUpdateOperationsInput | number | null
    WCoinP?: NullableIntFieldUpdateOperationsInput | number | null
    GoblinPoint?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CashShopDataUncheckedUpdateInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    WCoinC?: NullableIntFieldUpdateOperationsInput | number | null
    WCoinP?: NullableIntFieldUpdateOperationsInput | number | null
    GoblinPoint?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CashShopDataCreateManyInput = {
    AccountID: string
    WCoinC?: number | null
    WCoinP?: number | null
    GoblinPoint?: number | null
  }

  export type CashShopDataUpdateManyMutationInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    WCoinC?: NullableIntFieldUpdateOperationsInput | number | null
    WCoinP?: NullableIntFieldUpdateOperationsInput | number | null
    GoblinPoint?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CashShopDataUncheckedUpdateManyInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    WCoinC?: NullableIntFieldUpdateOperationsInput | number | null
    WCoinP?: NullableIntFieldUpdateOperationsInput | number | null
    GoblinPoint?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CashShopInventoryCreateInput = {
    MainItemCode?: number | null
    AccountID?: string | null
    InventoryType?: number | null
    PackageMainIndex?: number | null
    ProductBaseIndex?: number | null
    ProductMainIndex?: number | null
    CoinValue?: number | null
    ProductType?: number | null
    GiftName?: string | null
    GiftText?: string | null
  }

  export type CashShopInventoryUncheckedCreateInput = {
    BaseItemCode?: number
    MainItemCode?: number | null
    AccountID?: string | null
    InventoryType?: number | null
    PackageMainIndex?: number | null
    ProductBaseIndex?: number | null
    ProductMainIndex?: number | null
    CoinValue?: number | null
    ProductType?: number | null
    GiftName?: string | null
    GiftText?: string | null
  }

  export type CashShopInventoryUpdateInput = {
    MainItemCode?: NullableIntFieldUpdateOperationsInput | number | null
    AccountID?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryType?: NullableIntFieldUpdateOperationsInput | number | null
    PackageMainIndex?: NullableIntFieldUpdateOperationsInput | number | null
    ProductBaseIndex?: NullableIntFieldUpdateOperationsInput | number | null
    ProductMainIndex?: NullableIntFieldUpdateOperationsInput | number | null
    CoinValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ProductType?: NullableIntFieldUpdateOperationsInput | number | null
    GiftName?: NullableStringFieldUpdateOperationsInput | string | null
    GiftText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashShopInventoryUncheckedUpdateInput = {
    BaseItemCode?: IntFieldUpdateOperationsInput | number
    MainItemCode?: NullableIntFieldUpdateOperationsInput | number | null
    AccountID?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryType?: NullableIntFieldUpdateOperationsInput | number | null
    PackageMainIndex?: NullableIntFieldUpdateOperationsInput | number | null
    ProductBaseIndex?: NullableIntFieldUpdateOperationsInput | number | null
    ProductMainIndex?: NullableIntFieldUpdateOperationsInput | number | null
    CoinValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ProductType?: NullableIntFieldUpdateOperationsInput | number | null
    GiftName?: NullableStringFieldUpdateOperationsInput | string | null
    GiftText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashShopInventoryCreateManyInput = {
    MainItemCode?: number | null
    AccountID?: string | null
    InventoryType?: number | null
    PackageMainIndex?: number | null
    ProductBaseIndex?: number | null
    ProductMainIndex?: number | null
    CoinValue?: number | null
    ProductType?: number | null
    GiftName?: string | null
    GiftText?: string | null
  }

  export type CashShopInventoryUpdateManyMutationInput = {
    MainItemCode?: NullableIntFieldUpdateOperationsInput | number | null
    AccountID?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryType?: NullableIntFieldUpdateOperationsInput | number | null
    PackageMainIndex?: NullableIntFieldUpdateOperationsInput | number | null
    ProductBaseIndex?: NullableIntFieldUpdateOperationsInput | number | null
    ProductMainIndex?: NullableIntFieldUpdateOperationsInput | number | null
    CoinValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ProductType?: NullableIntFieldUpdateOperationsInput | number | null
    GiftName?: NullableStringFieldUpdateOperationsInput | string | null
    GiftText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashShopInventoryUncheckedUpdateManyInput = {
    BaseItemCode?: IntFieldUpdateOperationsInput | number
    MainItemCode?: NullableIntFieldUpdateOperationsInput | number | null
    AccountID?: NullableStringFieldUpdateOperationsInput | string | null
    InventoryType?: NullableIntFieldUpdateOperationsInput | number | null
    PackageMainIndex?: NullableIntFieldUpdateOperationsInput | number | null
    ProductBaseIndex?: NullableIntFieldUpdateOperationsInput | number | null
    ProductMainIndex?: NullableIntFieldUpdateOperationsInput | number | null
    CoinValue?: NullableFloatFieldUpdateOperationsInput | number | null
    ProductType?: NullableIntFieldUpdateOperationsInput | number | null
    GiftName?: NullableStringFieldUpdateOperationsInput | string | null
    GiftText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashShopPeriodicItemCreateInput = {
    ItemSerial: number
    Time?: number | null
  }

  export type CashShopPeriodicItemUncheckedCreateInput = {
    ItemSerial: number
    Time?: number | null
  }

  export type CashShopPeriodicItemUpdateInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    Time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CashShopPeriodicItemUncheckedUpdateInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    Time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CashShopPeriodicItemCreateManyInput = {
    ItemSerial: number
    Time?: number | null
  }

  export type CashShopPeriodicItemUpdateManyMutationInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    Time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CashShopPeriodicItemUncheckedUpdateManyInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    Time?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterCreateInput = {
    AccountID: string
    Name: string
    cLevel?: number | null
    LevelUpPoint?: number | null
    Class?: number | null
    Experience?: number | null
    Strength?: number | null
    Dexterity?: number | null
    Vitality?: number | null
    Energy?: number | null
    Leadership?: number | null
    Inventory?: Buffer | null
    MagicList?: Buffer | null
    Money?: number | null
    Life?: number | null
    MaxLife?: number | null
    Mana?: number | null
    MaxMana?: number | null
    BP?: number | null
    MaxBP?: number | null
    Shield?: number | null
    MaxShield?: number | null
    MapNumber?: number | null
    MapPosX?: number | null
    MapPosY?: number | null
    MapDir?: number | null
    PkCount?: number | null
    PkLevel?: number | null
    PkTime?: number | null
    MDate?: Date | string | null
    LDate?: Date | string | null
    CtlCode?: number | null
    DbVersion?: number | null
    Quest?: Buffer | null
    ChatLimitTime?: number | null
    FruitPoint?: number | null
    EffectList?: Buffer | null
    FruitAddPoint?: number
    FruitSubPoint?: number
    ResetCount?: number
    MasterResetCount?: number
    ExtInventory?: number
    Resets?: number
    ResetsDay?: number
    ResetsWeek?: number
    ResetsMonth?: number
    MResets?: number
    MResetsDay?: number
    MResetsWeek?: number
    MResetsMonth?: number
    PKTotal?: number
    PKDay?: number
    PKWeek?: number
    PKMonth?: number
    HeroTotal?: number
    HeroDay?: number
    HeroWeek?: number
    HeroMonth?: number
    tradewins?: number
    matamata?: number
    duel_total?: number
    duel_semanal?: number
    duel_mensal?: number
  }

  export type CharacterUncheckedCreateInput = {
    AccountID: string
    Name: string
    cLevel?: number | null
    LevelUpPoint?: number | null
    Class?: number | null
    Experience?: number | null
    Strength?: number | null
    Dexterity?: number | null
    Vitality?: number | null
    Energy?: number | null
    Leadership?: number | null
    Inventory?: Buffer | null
    MagicList?: Buffer | null
    Money?: number | null
    Life?: number | null
    MaxLife?: number | null
    Mana?: number | null
    MaxMana?: number | null
    BP?: number | null
    MaxBP?: number | null
    Shield?: number | null
    MaxShield?: number | null
    MapNumber?: number | null
    MapPosX?: number | null
    MapPosY?: number | null
    MapDir?: number | null
    PkCount?: number | null
    PkLevel?: number | null
    PkTime?: number | null
    MDate?: Date | string | null
    LDate?: Date | string | null
    CtlCode?: number | null
    DbVersion?: number | null
    Quest?: Buffer | null
    ChatLimitTime?: number | null
    FruitPoint?: number | null
    EffectList?: Buffer | null
    FruitAddPoint?: number
    FruitSubPoint?: number
    ResetCount?: number
    MasterResetCount?: number
    ExtInventory?: number
    Resets?: number
    ResetsDay?: number
    ResetsWeek?: number
    ResetsMonth?: number
    MResets?: number
    MResetsDay?: number
    MResetsWeek?: number
    MResetsMonth?: number
    PKTotal?: number
    PKDay?: number
    PKWeek?: number
    PKMonth?: number
    HeroTotal?: number
    HeroDay?: number
    HeroWeek?: number
    HeroMonth?: number
    tradewins?: number
    matamata?: number
    duel_total?: number
    duel_semanal?: number
    duel_mensal?: number
  }

  export type CharacterUpdateInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    cLevel?: NullableIntFieldUpdateOperationsInput | number | null
    LevelUpPoint?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableIntFieldUpdateOperationsInput | number | null
    Experience?: NullableIntFieldUpdateOperationsInput | number | null
    Strength?: NullableIntFieldUpdateOperationsInput | number | null
    Dexterity?: NullableIntFieldUpdateOperationsInput | number | null
    Vitality?: NullableIntFieldUpdateOperationsInput | number | null
    Energy?: NullableIntFieldUpdateOperationsInput | number | null
    Leadership?: NullableIntFieldUpdateOperationsInput | number | null
    Inventory?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    MagicList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Money?: NullableIntFieldUpdateOperationsInput | number | null
    Life?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxLife?: NullableFloatFieldUpdateOperationsInput | number | null
    Mana?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxMana?: NullableFloatFieldUpdateOperationsInput | number | null
    BP?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxBP?: NullableFloatFieldUpdateOperationsInput | number | null
    Shield?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxShield?: NullableFloatFieldUpdateOperationsInput | number | null
    MapNumber?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosX?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosY?: NullableIntFieldUpdateOperationsInput | number | null
    MapDir?: NullableIntFieldUpdateOperationsInput | number | null
    PkCount?: NullableIntFieldUpdateOperationsInput | number | null
    PkLevel?: NullableIntFieldUpdateOperationsInput | number | null
    PkTime?: NullableIntFieldUpdateOperationsInput | number | null
    MDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CtlCode?: NullableIntFieldUpdateOperationsInput | number | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    Quest?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    ChatLimitTime?: NullableIntFieldUpdateOperationsInput | number | null
    FruitPoint?: NullableIntFieldUpdateOperationsInput | number | null
    EffectList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    FruitAddPoint?: IntFieldUpdateOperationsInput | number
    FruitSubPoint?: IntFieldUpdateOperationsInput | number
    ResetCount?: IntFieldUpdateOperationsInput | number
    MasterResetCount?: IntFieldUpdateOperationsInput | number
    ExtInventory?: IntFieldUpdateOperationsInput | number
    Resets?: IntFieldUpdateOperationsInput | number
    ResetsDay?: IntFieldUpdateOperationsInput | number
    ResetsWeek?: IntFieldUpdateOperationsInput | number
    ResetsMonth?: IntFieldUpdateOperationsInput | number
    MResets?: IntFieldUpdateOperationsInput | number
    MResetsDay?: IntFieldUpdateOperationsInput | number
    MResetsWeek?: IntFieldUpdateOperationsInput | number
    MResetsMonth?: IntFieldUpdateOperationsInput | number
    PKTotal?: IntFieldUpdateOperationsInput | number
    PKDay?: IntFieldUpdateOperationsInput | number
    PKWeek?: IntFieldUpdateOperationsInput | number
    PKMonth?: IntFieldUpdateOperationsInput | number
    HeroTotal?: IntFieldUpdateOperationsInput | number
    HeroDay?: IntFieldUpdateOperationsInput | number
    HeroWeek?: IntFieldUpdateOperationsInput | number
    HeroMonth?: IntFieldUpdateOperationsInput | number
    tradewins?: IntFieldUpdateOperationsInput | number
    matamata?: IntFieldUpdateOperationsInput | number
    duel_total?: IntFieldUpdateOperationsInput | number
    duel_semanal?: IntFieldUpdateOperationsInput | number
    duel_mensal?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterUncheckedUpdateInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    cLevel?: NullableIntFieldUpdateOperationsInput | number | null
    LevelUpPoint?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableIntFieldUpdateOperationsInput | number | null
    Experience?: NullableIntFieldUpdateOperationsInput | number | null
    Strength?: NullableIntFieldUpdateOperationsInput | number | null
    Dexterity?: NullableIntFieldUpdateOperationsInput | number | null
    Vitality?: NullableIntFieldUpdateOperationsInput | number | null
    Energy?: NullableIntFieldUpdateOperationsInput | number | null
    Leadership?: NullableIntFieldUpdateOperationsInput | number | null
    Inventory?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    MagicList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Money?: NullableIntFieldUpdateOperationsInput | number | null
    Life?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxLife?: NullableFloatFieldUpdateOperationsInput | number | null
    Mana?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxMana?: NullableFloatFieldUpdateOperationsInput | number | null
    BP?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxBP?: NullableFloatFieldUpdateOperationsInput | number | null
    Shield?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxShield?: NullableFloatFieldUpdateOperationsInput | number | null
    MapNumber?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosX?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosY?: NullableIntFieldUpdateOperationsInput | number | null
    MapDir?: NullableIntFieldUpdateOperationsInput | number | null
    PkCount?: NullableIntFieldUpdateOperationsInput | number | null
    PkLevel?: NullableIntFieldUpdateOperationsInput | number | null
    PkTime?: NullableIntFieldUpdateOperationsInput | number | null
    MDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CtlCode?: NullableIntFieldUpdateOperationsInput | number | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    Quest?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    ChatLimitTime?: NullableIntFieldUpdateOperationsInput | number | null
    FruitPoint?: NullableIntFieldUpdateOperationsInput | number | null
    EffectList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    FruitAddPoint?: IntFieldUpdateOperationsInput | number
    FruitSubPoint?: IntFieldUpdateOperationsInput | number
    ResetCount?: IntFieldUpdateOperationsInput | number
    MasterResetCount?: IntFieldUpdateOperationsInput | number
    ExtInventory?: IntFieldUpdateOperationsInput | number
    Resets?: IntFieldUpdateOperationsInput | number
    ResetsDay?: IntFieldUpdateOperationsInput | number
    ResetsWeek?: IntFieldUpdateOperationsInput | number
    ResetsMonth?: IntFieldUpdateOperationsInput | number
    MResets?: IntFieldUpdateOperationsInput | number
    MResetsDay?: IntFieldUpdateOperationsInput | number
    MResetsWeek?: IntFieldUpdateOperationsInput | number
    MResetsMonth?: IntFieldUpdateOperationsInput | number
    PKTotal?: IntFieldUpdateOperationsInput | number
    PKDay?: IntFieldUpdateOperationsInput | number
    PKWeek?: IntFieldUpdateOperationsInput | number
    PKMonth?: IntFieldUpdateOperationsInput | number
    HeroTotal?: IntFieldUpdateOperationsInput | number
    HeroDay?: IntFieldUpdateOperationsInput | number
    HeroWeek?: IntFieldUpdateOperationsInput | number
    HeroMonth?: IntFieldUpdateOperationsInput | number
    tradewins?: IntFieldUpdateOperationsInput | number
    matamata?: IntFieldUpdateOperationsInput | number
    duel_total?: IntFieldUpdateOperationsInput | number
    duel_semanal?: IntFieldUpdateOperationsInput | number
    duel_mensal?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterCreateManyInput = {
    AccountID: string
    Name: string
    cLevel?: number | null
    LevelUpPoint?: number | null
    Class?: number | null
    Experience?: number | null
    Strength?: number | null
    Dexterity?: number | null
    Vitality?: number | null
    Energy?: number | null
    Leadership?: number | null
    Inventory?: Buffer | null
    MagicList?: Buffer | null
    Money?: number | null
    Life?: number | null
    MaxLife?: number | null
    Mana?: number | null
    MaxMana?: number | null
    BP?: number | null
    MaxBP?: number | null
    Shield?: number | null
    MaxShield?: number | null
    MapNumber?: number | null
    MapPosX?: number | null
    MapPosY?: number | null
    MapDir?: number | null
    PkCount?: number | null
    PkLevel?: number | null
    PkTime?: number | null
    MDate?: Date | string | null
    LDate?: Date | string | null
    CtlCode?: number | null
    DbVersion?: number | null
    Quest?: Buffer | null
    ChatLimitTime?: number | null
    FruitPoint?: number | null
    EffectList?: Buffer | null
    FruitAddPoint?: number
    FruitSubPoint?: number
    ResetCount?: number
    MasterResetCount?: number
    ExtInventory?: number
    Resets?: number
    ResetsDay?: number
    ResetsWeek?: number
    ResetsMonth?: number
    MResets?: number
    MResetsDay?: number
    MResetsWeek?: number
    MResetsMonth?: number
    PKTotal?: number
    PKDay?: number
    PKWeek?: number
    PKMonth?: number
    HeroTotal?: number
    HeroDay?: number
    HeroWeek?: number
    HeroMonth?: number
    tradewins?: number
    matamata?: number
    duel_total?: number
    duel_semanal?: number
    duel_mensal?: number
  }

  export type CharacterUpdateManyMutationInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    cLevel?: NullableIntFieldUpdateOperationsInput | number | null
    LevelUpPoint?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableIntFieldUpdateOperationsInput | number | null
    Experience?: NullableIntFieldUpdateOperationsInput | number | null
    Strength?: NullableIntFieldUpdateOperationsInput | number | null
    Dexterity?: NullableIntFieldUpdateOperationsInput | number | null
    Vitality?: NullableIntFieldUpdateOperationsInput | number | null
    Energy?: NullableIntFieldUpdateOperationsInput | number | null
    Leadership?: NullableIntFieldUpdateOperationsInput | number | null
    Inventory?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    MagicList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Money?: NullableIntFieldUpdateOperationsInput | number | null
    Life?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxLife?: NullableFloatFieldUpdateOperationsInput | number | null
    Mana?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxMana?: NullableFloatFieldUpdateOperationsInput | number | null
    BP?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxBP?: NullableFloatFieldUpdateOperationsInput | number | null
    Shield?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxShield?: NullableFloatFieldUpdateOperationsInput | number | null
    MapNumber?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosX?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosY?: NullableIntFieldUpdateOperationsInput | number | null
    MapDir?: NullableIntFieldUpdateOperationsInput | number | null
    PkCount?: NullableIntFieldUpdateOperationsInput | number | null
    PkLevel?: NullableIntFieldUpdateOperationsInput | number | null
    PkTime?: NullableIntFieldUpdateOperationsInput | number | null
    MDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CtlCode?: NullableIntFieldUpdateOperationsInput | number | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    Quest?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    ChatLimitTime?: NullableIntFieldUpdateOperationsInput | number | null
    FruitPoint?: NullableIntFieldUpdateOperationsInput | number | null
    EffectList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    FruitAddPoint?: IntFieldUpdateOperationsInput | number
    FruitSubPoint?: IntFieldUpdateOperationsInput | number
    ResetCount?: IntFieldUpdateOperationsInput | number
    MasterResetCount?: IntFieldUpdateOperationsInput | number
    ExtInventory?: IntFieldUpdateOperationsInput | number
    Resets?: IntFieldUpdateOperationsInput | number
    ResetsDay?: IntFieldUpdateOperationsInput | number
    ResetsWeek?: IntFieldUpdateOperationsInput | number
    ResetsMonth?: IntFieldUpdateOperationsInput | number
    MResets?: IntFieldUpdateOperationsInput | number
    MResetsDay?: IntFieldUpdateOperationsInput | number
    MResetsWeek?: IntFieldUpdateOperationsInput | number
    MResetsMonth?: IntFieldUpdateOperationsInput | number
    PKTotal?: IntFieldUpdateOperationsInput | number
    PKDay?: IntFieldUpdateOperationsInput | number
    PKWeek?: IntFieldUpdateOperationsInput | number
    PKMonth?: IntFieldUpdateOperationsInput | number
    HeroTotal?: IntFieldUpdateOperationsInput | number
    HeroDay?: IntFieldUpdateOperationsInput | number
    HeroWeek?: IntFieldUpdateOperationsInput | number
    HeroMonth?: IntFieldUpdateOperationsInput | number
    tradewins?: IntFieldUpdateOperationsInput | number
    matamata?: IntFieldUpdateOperationsInput | number
    duel_total?: IntFieldUpdateOperationsInput | number
    duel_semanal?: IntFieldUpdateOperationsInput | number
    duel_mensal?: IntFieldUpdateOperationsInput | number
  }

  export type CharacterUncheckedUpdateManyInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    cLevel?: NullableIntFieldUpdateOperationsInput | number | null
    LevelUpPoint?: NullableIntFieldUpdateOperationsInput | number | null
    Class?: NullableIntFieldUpdateOperationsInput | number | null
    Experience?: NullableIntFieldUpdateOperationsInput | number | null
    Strength?: NullableIntFieldUpdateOperationsInput | number | null
    Dexterity?: NullableIntFieldUpdateOperationsInput | number | null
    Vitality?: NullableIntFieldUpdateOperationsInput | number | null
    Energy?: NullableIntFieldUpdateOperationsInput | number | null
    Leadership?: NullableIntFieldUpdateOperationsInput | number | null
    Inventory?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    MagicList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Money?: NullableIntFieldUpdateOperationsInput | number | null
    Life?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxLife?: NullableFloatFieldUpdateOperationsInput | number | null
    Mana?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxMana?: NullableFloatFieldUpdateOperationsInput | number | null
    BP?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxBP?: NullableFloatFieldUpdateOperationsInput | number | null
    Shield?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxShield?: NullableFloatFieldUpdateOperationsInput | number | null
    MapNumber?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosX?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosY?: NullableIntFieldUpdateOperationsInput | number | null
    MapDir?: NullableIntFieldUpdateOperationsInput | number | null
    PkCount?: NullableIntFieldUpdateOperationsInput | number | null
    PkLevel?: NullableIntFieldUpdateOperationsInput | number | null
    PkTime?: NullableIntFieldUpdateOperationsInput | number | null
    MDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CtlCode?: NullableIntFieldUpdateOperationsInput | number | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    Quest?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    ChatLimitTime?: NullableIntFieldUpdateOperationsInput | number | null
    FruitPoint?: NullableIntFieldUpdateOperationsInput | number | null
    EffectList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    FruitAddPoint?: IntFieldUpdateOperationsInput | number
    FruitSubPoint?: IntFieldUpdateOperationsInput | number
    ResetCount?: IntFieldUpdateOperationsInput | number
    MasterResetCount?: IntFieldUpdateOperationsInput | number
    ExtInventory?: IntFieldUpdateOperationsInput | number
    Resets?: IntFieldUpdateOperationsInput | number
    ResetsDay?: IntFieldUpdateOperationsInput | number
    ResetsWeek?: IntFieldUpdateOperationsInput | number
    ResetsMonth?: IntFieldUpdateOperationsInput | number
    MResets?: IntFieldUpdateOperationsInput | number
    MResetsDay?: IntFieldUpdateOperationsInput | number
    MResetsWeek?: IntFieldUpdateOperationsInput | number
    MResetsMonth?: IntFieldUpdateOperationsInput | number
    PKTotal?: IntFieldUpdateOperationsInput | number
    PKDay?: IntFieldUpdateOperationsInput | number
    PKWeek?: IntFieldUpdateOperationsInput | number
    PKMonth?: IntFieldUpdateOperationsInput | number
    HeroTotal?: IntFieldUpdateOperationsInput | number
    HeroDay?: IntFieldUpdateOperationsInput | number
    HeroWeek?: IntFieldUpdateOperationsInput | number
    HeroMonth?: IntFieldUpdateOperationsInput | number
    tradewins?: IntFieldUpdateOperationsInput | number
    matamata?: IntFieldUpdateOperationsInput | number
    duel_total?: IntFieldUpdateOperationsInput | number
    duel_semanal?: IntFieldUpdateOperationsInput | number
    duel_mensal?: IntFieldUpdateOperationsInput | number
  }

  export type DefaultClassTypeCreateInput = {
    Class: number
    Level?: number | null
    LevelUpPoint?: number | null
    Strength?: number | null
    Dexterity?: number | null
    Vitality?: number | null
    Energy?: number | null
    Leadership?: number | null
    Inventory?: Buffer | null
    MagicList?: Buffer | null
    Life?: number | null
    MaxLife?: number | null
    Mana?: number | null
    MaxMana?: number | null
    MapNumber?: number | null
    MapPosX?: number | null
    MapPosY?: number | null
    Quest?: Buffer | null
    DbVersion?: number | null
    EffectList?: Buffer | null
  }

  export type DefaultClassTypeUncheckedCreateInput = {
    Class: number
    Level?: number | null
    LevelUpPoint?: number | null
    Strength?: number | null
    Dexterity?: number | null
    Vitality?: number | null
    Energy?: number | null
    Leadership?: number | null
    Inventory?: Buffer | null
    MagicList?: Buffer | null
    Life?: number | null
    MaxLife?: number | null
    Mana?: number | null
    MaxMana?: number | null
    MapNumber?: number | null
    MapPosX?: number | null
    MapPosY?: number | null
    Quest?: Buffer | null
    DbVersion?: number | null
    EffectList?: Buffer | null
  }

  export type DefaultClassTypeUpdateInput = {
    Class?: IntFieldUpdateOperationsInput | number
    Level?: NullableIntFieldUpdateOperationsInput | number | null
    LevelUpPoint?: NullableIntFieldUpdateOperationsInput | number | null
    Strength?: NullableIntFieldUpdateOperationsInput | number | null
    Dexterity?: NullableIntFieldUpdateOperationsInput | number | null
    Vitality?: NullableIntFieldUpdateOperationsInput | number | null
    Energy?: NullableIntFieldUpdateOperationsInput | number | null
    Leadership?: NullableIntFieldUpdateOperationsInput | number | null
    Inventory?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    MagicList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Life?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxLife?: NullableFloatFieldUpdateOperationsInput | number | null
    Mana?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxMana?: NullableFloatFieldUpdateOperationsInput | number | null
    MapNumber?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosX?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosY?: NullableIntFieldUpdateOperationsInput | number | null
    Quest?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    EffectList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type DefaultClassTypeUncheckedUpdateInput = {
    Class?: IntFieldUpdateOperationsInput | number
    Level?: NullableIntFieldUpdateOperationsInput | number | null
    LevelUpPoint?: NullableIntFieldUpdateOperationsInput | number | null
    Strength?: NullableIntFieldUpdateOperationsInput | number | null
    Dexterity?: NullableIntFieldUpdateOperationsInput | number | null
    Vitality?: NullableIntFieldUpdateOperationsInput | number | null
    Energy?: NullableIntFieldUpdateOperationsInput | number | null
    Leadership?: NullableIntFieldUpdateOperationsInput | number | null
    Inventory?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    MagicList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Life?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxLife?: NullableFloatFieldUpdateOperationsInput | number | null
    Mana?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxMana?: NullableFloatFieldUpdateOperationsInput | number | null
    MapNumber?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosX?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosY?: NullableIntFieldUpdateOperationsInput | number | null
    Quest?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    EffectList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type DefaultClassTypeCreateManyInput = {
    Class: number
    Level?: number | null
    LevelUpPoint?: number | null
    Strength?: number | null
    Dexterity?: number | null
    Vitality?: number | null
    Energy?: number | null
    Leadership?: number | null
    Inventory?: Buffer | null
    MagicList?: Buffer | null
    Life?: number | null
    MaxLife?: number | null
    Mana?: number | null
    MaxMana?: number | null
    MapNumber?: number | null
    MapPosX?: number | null
    MapPosY?: number | null
    Quest?: Buffer | null
    DbVersion?: number | null
    EffectList?: Buffer | null
  }

  export type DefaultClassTypeUpdateManyMutationInput = {
    Class?: IntFieldUpdateOperationsInput | number
    Level?: NullableIntFieldUpdateOperationsInput | number | null
    LevelUpPoint?: NullableIntFieldUpdateOperationsInput | number | null
    Strength?: NullableIntFieldUpdateOperationsInput | number | null
    Dexterity?: NullableIntFieldUpdateOperationsInput | number | null
    Vitality?: NullableIntFieldUpdateOperationsInput | number | null
    Energy?: NullableIntFieldUpdateOperationsInput | number | null
    Leadership?: NullableIntFieldUpdateOperationsInput | number | null
    Inventory?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    MagicList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Life?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxLife?: NullableFloatFieldUpdateOperationsInput | number | null
    Mana?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxMana?: NullableFloatFieldUpdateOperationsInput | number | null
    MapNumber?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosX?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosY?: NullableIntFieldUpdateOperationsInput | number | null
    Quest?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    EffectList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type DefaultClassTypeUncheckedUpdateManyInput = {
    Class?: IntFieldUpdateOperationsInput | number
    Level?: NullableIntFieldUpdateOperationsInput | number | null
    LevelUpPoint?: NullableIntFieldUpdateOperationsInput | number | null
    Strength?: NullableIntFieldUpdateOperationsInput | number | null
    Dexterity?: NullableIntFieldUpdateOperationsInput | number | null
    Vitality?: NullableIntFieldUpdateOperationsInput | number | null
    Energy?: NullableIntFieldUpdateOperationsInput | number | null
    Leadership?: NullableIntFieldUpdateOperationsInput | number | null
    Inventory?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    MagicList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Life?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxLife?: NullableFloatFieldUpdateOperationsInput | number | null
    Mana?: NullableFloatFieldUpdateOperationsInput | number | null
    MaxMana?: NullableFloatFieldUpdateOperationsInput | number | null
    MapNumber?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosX?: NullableIntFieldUpdateOperationsInput | number | null
    MapPosY?: NullableIntFieldUpdateOperationsInput | number | null
    Quest?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    EffectList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type EventLeoTheHelperCreateInput = {
    Name: string
    Status?: number | null
  }

  export type EventLeoTheHelperUncheckedCreateInput = {
    Name: string
    Status?: number | null
  }

  export type EventLeoTheHelperUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventLeoTheHelperUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventLeoTheHelperCreateManyInput = {
    Name: string
    Status?: number | null
  }

  export type EventLeoTheHelperUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventLeoTheHelperUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventSantaClausCreateInput = {
    Name: string
    Status?: number | null
  }

  export type EventSantaClausUncheckedCreateInput = {
    Name: string
    Status?: number | null
  }

  export type EventSantaClausUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventSantaClausUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventSantaClausCreateManyInput = {
    Name: string
    Status?: number | null
  }

  export type EventSantaClausUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventSantaClausUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameServerInfoCreateInput = {
    Number?: number
    ItemCount: number
    ZenCount?: number | null
    AceItemCount?: number | null
  }

  export type GameServerInfoUncheckedCreateInput = {
    Number?: number
    ItemCount: number
    ZenCount?: number | null
    AceItemCount?: number | null
  }

  export type GameServerInfoUpdateInput = {
    Number?: IntFieldUpdateOperationsInput | number
    ItemCount?: IntFieldUpdateOperationsInput | number
    ZenCount?: NullableIntFieldUpdateOperationsInput | number | null
    AceItemCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameServerInfoUncheckedUpdateInput = {
    Number?: IntFieldUpdateOperationsInput | number
    ItemCount?: IntFieldUpdateOperationsInput | number
    ZenCount?: NullableIntFieldUpdateOperationsInput | number | null
    AceItemCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameServerInfoCreateManyInput = {
    Number?: number
    ItemCount: number
    ZenCount?: number | null
    AceItemCount?: number | null
  }

  export type GameServerInfoUpdateManyMutationInput = {
    Number?: IntFieldUpdateOperationsInput | number
    ItemCount?: IntFieldUpdateOperationsInput | number
    ZenCount?: NullableIntFieldUpdateOperationsInput | number | null
    AceItemCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameServerInfoUncheckedUpdateManyInput = {
    Number?: IntFieldUpdateOperationsInput | number
    ItemCount?: IntFieldUpdateOperationsInput | number
    ZenCount?: NullableIntFieldUpdateOperationsInput | number | null
    AceItemCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gens_RankCreateInput = {
    Name: string
    Family?: number | null
    Contribution?: number | null
  }

  export type Gens_RankUncheckedCreateInput = {
    Name: string
    Family?: number | null
    Contribution?: number | null
  }

  export type Gens_RankUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Family?: NullableIntFieldUpdateOperationsInput | number | null
    Contribution?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gens_RankUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Family?: NullableIntFieldUpdateOperationsInput | number | null
    Contribution?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gens_RankCreateManyInput = {
    Name: string
    Family?: number | null
    Contribution?: number | null
  }

  export type Gens_RankUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Family?: NullableIntFieldUpdateOperationsInput | number | null
    Contribution?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gens_RankUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Family?: NullableIntFieldUpdateOperationsInput | number | null
    Contribution?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gens_RewardCreateInput = {
    Name: string
    Rank?: number | null
    Status?: number | null
  }

  export type Gens_RewardUncheckedCreateInput = {
    Name: string
    Rank?: number | null
    Status?: number | null
  }

  export type Gens_RewardUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Rank?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gens_RewardUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Rank?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gens_RewardCreateManyInput = {
    Name: string
    Rank?: number | null
    Status?: number | null
  }

  export type Gens_RewardUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Rank?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Gens_RewardUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Rank?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildCreateInput = {
    G_Name: string
    G_Mark?: Buffer | null
    G_Score?: number | null
    G_Master?: string | null
    G_Count?: number | null
    G_Notice?: string | null
    Number?: number
    G_Type?: number
    G_Rival?: number
    G_Union?: number
    MemberCount?: number | null
  }

  export type GuildUncheckedCreateInput = {
    G_Name: string
    G_Mark?: Buffer | null
    G_Score?: number | null
    G_Master?: string | null
    G_Count?: number | null
    G_Notice?: string | null
    Number?: number
    G_Type?: number
    G_Rival?: number
    G_Union?: number
    MemberCount?: number | null
  }

  export type GuildUpdateInput = {
    G_Name?: StringFieldUpdateOperationsInput | string
    G_Mark?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    G_Score?: NullableIntFieldUpdateOperationsInput | number | null
    G_Master?: NullableStringFieldUpdateOperationsInput | string | null
    G_Count?: NullableIntFieldUpdateOperationsInput | number | null
    G_Notice?: NullableStringFieldUpdateOperationsInput | string | null
    Number?: IntFieldUpdateOperationsInput | number
    G_Type?: IntFieldUpdateOperationsInput | number
    G_Rival?: IntFieldUpdateOperationsInput | number
    G_Union?: IntFieldUpdateOperationsInput | number
    MemberCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildUncheckedUpdateInput = {
    G_Name?: StringFieldUpdateOperationsInput | string
    G_Mark?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    G_Score?: NullableIntFieldUpdateOperationsInput | number | null
    G_Master?: NullableStringFieldUpdateOperationsInput | string | null
    G_Count?: NullableIntFieldUpdateOperationsInput | number | null
    G_Notice?: NullableStringFieldUpdateOperationsInput | string | null
    Number?: IntFieldUpdateOperationsInput | number
    G_Type?: IntFieldUpdateOperationsInput | number
    G_Rival?: IntFieldUpdateOperationsInput | number
    G_Union?: IntFieldUpdateOperationsInput | number
    MemberCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildCreateManyInput = {
    G_Name: string
    G_Mark?: Buffer | null
    G_Score?: number | null
    G_Master?: string | null
    G_Count?: number | null
    G_Notice?: string | null
    G_Type?: number
    G_Rival?: number
    G_Union?: number
    MemberCount?: number | null
  }

  export type GuildUpdateManyMutationInput = {
    G_Name?: StringFieldUpdateOperationsInput | string
    G_Mark?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    G_Score?: NullableIntFieldUpdateOperationsInput | number | null
    G_Master?: NullableStringFieldUpdateOperationsInput | string | null
    G_Count?: NullableIntFieldUpdateOperationsInput | number | null
    G_Notice?: NullableStringFieldUpdateOperationsInput | string | null
    Number?: IntFieldUpdateOperationsInput | number
    G_Type?: IntFieldUpdateOperationsInput | number
    G_Rival?: IntFieldUpdateOperationsInput | number
    G_Union?: IntFieldUpdateOperationsInput | number
    MemberCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildUncheckedUpdateManyInput = {
    G_Name?: StringFieldUpdateOperationsInput | string
    G_Mark?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    G_Score?: NullableIntFieldUpdateOperationsInput | number | null
    G_Master?: NullableStringFieldUpdateOperationsInput | string | null
    G_Count?: NullableIntFieldUpdateOperationsInput | number | null
    G_Notice?: NullableStringFieldUpdateOperationsInput | string | null
    Number?: IntFieldUpdateOperationsInput | number
    G_Type?: IntFieldUpdateOperationsInput | number
    G_Rival?: IntFieldUpdateOperationsInput | number
    G_Union?: IntFieldUpdateOperationsInput | number
    MemberCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuildMemberCreateInput = {
    Name: string
    G_Name: string
    G_Level?: number | null
    G_Status?: number
  }

  export type GuildMemberUncheckedCreateInput = {
    Name: string
    G_Name: string
    G_Level?: number | null
    G_Status?: number
  }

  export type GuildMemberUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    G_Name?: StringFieldUpdateOperationsInput | string
    G_Level?: NullableIntFieldUpdateOperationsInput | number | null
    G_Status?: IntFieldUpdateOperationsInput | number
  }

  export type GuildMemberUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    G_Name?: StringFieldUpdateOperationsInput | string
    G_Level?: NullableIntFieldUpdateOperationsInput | number | null
    G_Status?: IntFieldUpdateOperationsInput | number
  }

  export type GuildMemberCreateManyInput = {
    Name: string
    G_Name: string
    G_Level?: number | null
    G_Status?: number
  }

  export type GuildMemberUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    G_Name?: StringFieldUpdateOperationsInput | string
    G_Level?: NullableIntFieldUpdateOperationsInput | number | null
    G_Status?: IntFieldUpdateOperationsInput | number
  }

  export type GuildMemberUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    G_Name?: StringFieldUpdateOperationsInput | string
    G_Level?: NullableIntFieldUpdateOperationsInput | number | null
    G_Status?: IntFieldUpdateOperationsInput | number
  }

  export type HelperDataCreateInput = {
    Name: string
    Data?: Buffer | null
  }

  export type HelperDataUncheckedCreateInput = {
    Name: string
    Data?: Buffer | null
  }

  export type HelperDataUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type HelperDataUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type HelperDataCreateManyInput = {
    Name: string
    Data?: Buffer | null
  }

  export type HelperDataUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type HelperDataUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Data?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type LuckyCoinCreateInput = {
    AccountID: string
    LuckyCoin?: number | null
  }

  export type LuckyCoinUncheckedCreateInput = {
    AccountID: string
    LuckyCoin?: number | null
  }

  export type LuckyCoinUpdateInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    LuckyCoin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuckyCoinUncheckedUpdateInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    LuckyCoin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuckyCoinCreateManyInput = {
    AccountID: string
    LuckyCoin?: number | null
  }

  export type LuckyCoinUpdateManyMutationInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    LuckyCoin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuckyCoinUncheckedUpdateManyInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    LuckyCoin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuckyItemCreateInput = {
    ItemSerial: number
    DurabilitySmall?: number | null
  }

  export type LuckyItemUncheckedCreateInput = {
    ItemSerial: number
    DurabilitySmall?: number | null
  }

  export type LuckyItemUpdateInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    DurabilitySmall?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuckyItemUncheckedUpdateInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    DurabilitySmall?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuckyItemCreateManyInput = {
    ItemSerial: number
    DurabilitySmall?: number | null
  }

  export type LuckyItemUpdateManyMutationInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    DurabilitySmall?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LuckyItemUncheckedUpdateManyInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    DurabilitySmall?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MEMB_STATCreateInput = {
    memb___id: string
    ConnectStat?: number | null
    ServerName?: string | null
    IP?: string | null
    ConnectTM?: Date | string | null
    DisConnectTM?: Date | string | null
    OnlineHours?: number | null
    HWID?: string | null
  }

  export type MEMB_STATUncheckedCreateInput = {
    memb___id: string
    ConnectStat?: number | null
    ServerName?: string | null
    IP?: string | null
    ConnectTM?: Date | string | null
    DisConnectTM?: Date | string | null
    OnlineHours?: number | null
    HWID?: string | null
  }

  export type MEMB_STATUpdateInput = {
    memb___id?: StringFieldUpdateOperationsInput | string
    ConnectStat?: NullableIntFieldUpdateOperationsInput | number | null
    ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectTM?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DisConnectTM?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnlineHours?: NullableIntFieldUpdateOperationsInput | number | null
    HWID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MEMB_STATUncheckedUpdateInput = {
    memb___id?: StringFieldUpdateOperationsInput | string
    ConnectStat?: NullableIntFieldUpdateOperationsInput | number | null
    ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectTM?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DisConnectTM?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnlineHours?: NullableIntFieldUpdateOperationsInput | number | null
    HWID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MEMB_STATCreateManyInput = {
    memb___id: string
    ConnectStat?: number | null
    ServerName?: string | null
    IP?: string | null
    ConnectTM?: Date | string | null
    DisConnectTM?: Date | string | null
    OnlineHours?: number | null
    HWID?: string | null
  }

  export type MEMB_STATUpdateManyMutationInput = {
    memb___id?: StringFieldUpdateOperationsInput | string
    ConnectStat?: NullableIntFieldUpdateOperationsInput | number | null
    ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectTM?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DisConnectTM?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnlineHours?: NullableIntFieldUpdateOperationsInput | number | null
    HWID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MEMB_STATUncheckedUpdateManyInput = {
    memb___id?: StringFieldUpdateOperationsInput | string
    ConnectStat?: NullableIntFieldUpdateOperationsInput | number | null
    ServerName?: NullableStringFieldUpdateOperationsInput | string | null
    IP?: NullableStringFieldUpdateOperationsInput | string | null
    ConnectTM?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DisConnectTM?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OnlineHours?: NullableIntFieldUpdateOperationsInput | number | null
    HWID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterSkillTreeCreateInput = {
    Name: string
    MasterLevel?: number | null
    MasterPoint?: number | null
    MasterExperience?: bigint | number | null
    MasterSkill?: Buffer | null
  }

  export type MasterSkillTreeUncheckedCreateInput = {
    Name: string
    MasterLevel?: number | null
    MasterPoint?: number | null
    MasterExperience?: bigint | number | null
    MasterSkill?: Buffer | null
  }

  export type MasterSkillTreeUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    MasterLevel?: NullableIntFieldUpdateOperationsInput | number | null
    MasterPoint?: NullableIntFieldUpdateOperationsInput | number | null
    MasterExperience?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MasterSkill?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type MasterSkillTreeUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    MasterLevel?: NullableIntFieldUpdateOperationsInput | number | null
    MasterPoint?: NullableIntFieldUpdateOperationsInput | number | null
    MasterExperience?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MasterSkill?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type MasterSkillTreeCreateManyInput = {
    Name: string
    MasterLevel?: number | null
    MasterPoint?: number | null
    MasterExperience?: bigint | number | null
    MasterSkill?: Buffer | null
  }

  export type MasterSkillTreeUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    MasterLevel?: NullableIntFieldUpdateOperationsInput | number | null
    MasterPoint?: NullableIntFieldUpdateOperationsInput | number | null
    MasterExperience?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MasterSkill?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type MasterSkillTreeUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    MasterLevel?: NullableIntFieldUpdateOperationsInput | number | null
    MasterPoint?: NullableIntFieldUpdateOperationsInput | number | null
    MasterExperience?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    MasterSkill?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type MuCastle_DATACreateInput = {
    MAP_SVR_GROUP: number
    SIEGE_START_DATE: Date | string
    SIEGE_END_DATE: Date | string
    SIEGE_GUILDLIST_SETTED: boolean
    SIEGE_ENDED?: boolean
    CASTLE_OCCUPY?: boolean
    OWNER_GUILD: string
    MONEY?: number
    TAX_RATE_CHAOS?: number
    TAX_RATE_STORE?: number
    TAX_HUNT_ZONE?: number
  }

  export type MuCastle_DATAUncheckedCreateInput = {
    MAP_SVR_GROUP: number
    SIEGE_START_DATE: Date | string
    SIEGE_END_DATE: Date | string
    SIEGE_GUILDLIST_SETTED: boolean
    SIEGE_ENDED?: boolean
    CASTLE_OCCUPY?: boolean
    OWNER_GUILD: string
    MONEY?: number
    TAX_RATE_CHAOS?: number
    TAX_RATE_STORE?: number
    TAX_HUNT_ZONE?: number
  }

  export type MuCastle_DATAUpdateInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    SIEGE_START_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    SIEGE_END_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    SIEGE_GUILDLIST_SETTED?: BoolFieldUpdateOperationsInput | boolean
    SIEGE_ENDED?: BoolFieldUpdateOperationsInput | boolean
    CASTLE_OCCUPY?: BoolFieldUpdateOperationsInput | boolean
    OWNER_GUILD?: StringFieldUpdateOperationsInput | string
    MONEY?: FloatFieldUpdateOperationsInput | number
    TAX_RATE_CHAOS?: IntFieldUpdateOperationsInput | number
    TAX_RATE_STORE?: IntFieldUpdateOperationsInput | number
    TAX_HUNT_ZONE?: IntFieldUpdateOperationsInput | number
  }

  export type MuCastle_DATAUncheckedUpdateInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    SIEGE_START_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    SIEGE_END_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    SIEGE_GUILDLIST_SETTED?: BoolFieldUpdateOperationsInput | boolean
    SIEGE_ENDED?: BoolFieldUpdateOperationsInput | boolean
    CASTLE_OCCUPY?: BoolFieldUpdateOperationsInput | boolean
    OWNER_GUILD?: StringFieldUpdateOperationsInput | string
    MONEY?: FloatFieldUpdateOperationsInput | number
    TAX_RATE_CHAOS?: IntFieldUpdateOperationsInput | number
    TAX_RATE_STORE?: IntFieldUpdateOperationsInput | number
    TAX_HUNT_ZONE?: IntFieldUpdateOperationsInput | number
  }

  export type MuCastle_DATACreateManyInput = {
    MAP_SVR_GROUP: number
    SIEGE_START_DATE: Date | string
    SIEGE_END_DATE: Date | string
    SIEGE_GUILDLIST_SETTED: boolean
    SIEGE_ENDED?: boolean
    CASTLE_OCCUPY?: boolean
    OWNER_GUILD: string
    MONEY?: number
    TAX_RATE_CHAOS?: number
    TAX_RATE_STORE?: number
    TAX_HUNT_ZONE?: number
  }

  export type MuCastle_DATAUpdateManyMutationInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    SIEGE_START_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    SIEGE_END_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    SIEGE_GUILDLIST_SETTED?: BoolFieldUpdateOperationsInput | boolean
    SIEGE_ENDED?: BoolFieldUpdateOperationsInput | boolean
    CASTLE_OCCUPY?: BoolFieldUpdateOperationsInput | boolean
    OWNER_GUILD?: StringFieldUpdateOperationsInput | string
    MONEY?: FloatFieldUpdateOperationsInput | number
    TAX_RATE_CHAOS?: IntFieldUpdateOperationsInput | number
    TAX_RATE_STORE?: IntFieldUpdateOperationsInput | number
    TAX_HUNT_ZONE?: IntFieldUpdateOperationsInput | number
  }

  export type MuCastle_DATAUncheckedUpdateManyInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    SIEGE_START_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    SIEGE_END_DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    SIEGE_GUILDLIST_SETTED?: BoolFieldUpdateOperationsInput | boolean
    SIEGE_ENDED?: BoolFieldUpdateOperationsInput | boolean
    CASTLE_OCCUPY?: BoolFieldUpdateOperationsInput | boolean
    OWNER_GUILD?: StringFieldUpdateOperationsInput | string
    MONEY?: FloatFieldUpdateOperationsInput | number
    TAX_RATE_CHAOS?: IntFieldUpdateOperationsInput | number
    TAX_RATE_STORE?: IntFieldUpdateOperationsInput | number
    TAX_HUNT_ZONE?: IntFieldUpdateOperationsInput | number
  }

  export type MuCastle_NPCCreateInput = {
    MAP_SVR_GROUP: number
    NPC_NUMBER: number
    NPC_INDEX: number
    NPC_DF_LEVEL: number
    NPC_RG_LEVEL: number
    NPC_MAXHP: number
    NPC_HP: number
    NPC_X: number
    NPC_Y: number
    NPC_DIR: number
    NPC_CREATEDATE: Date | string
  }

  export type MuCastle_NPCUncheckedCreateInput = {
    MAP_SVR_GROUP: number
    NPC_NUMBER: number
    NPC_INDEX: number
    NPC_DF_LEVEL: number
    NPC_RG_LEVEL: number
    NPC_MAXHP: number
    NPC_HP: number
    NPC_X: number
    NPC_Y: number
    NPC_DIR: number
    NPC_CREATEDATE: Date | string
  }

  export type MuCastle_NPCUpdateInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    NPC_NUMBER?: IntFieldUpdateOperationsInput | number
    NPC_INDEX?: IntFieldUpdateOperationsInput | number
    NPC_DF_LEVEL?: IntFieldUpdateOperationsInput | number
    NPC_RG_LEVEL?: IntFieldUpdateOperationsInput | number
    NPC_MAXHP?: IntFieldUpdateOperationsInput | number
    NPC_HP?: IntFieldUpdateOperationsInput | number
    NPC_X?: IntFieldUpdateOperationsInput | number
    NPC_Y?: IntFieldUpdateOperationsInput | number
    NPC_DIR?: IntFieldUpdateOperationsInput | number
    NPC_CREATEDATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuCastle_NPCUncheckedUpdateInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    NPC_NUMBER?: IntFieldUpdateOperationsInput | number
    NPC_INDEX?: IntFieldUpdateOperationsInput | number
    NPC_DF_LEVEL?: IntFieldUpdateOperationsInput | number
    NPC_RG_LEVEL?: IntFieldUpdateOperationsInput | number
    NPC_MAXHP?: IntFieldUpdateOperationsInput | number
    NPC_HP?: IntFieldUpdateOperationsInput | number
    NPC_X?: IntFieldUpdateOperationsInput | number
    NPC_Y?: IntFieldUpdateOperationsInput | number
    NPC_DIR?: IntFieldUpdateOperationsInput | number
    NPC_CREATEDATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuCastle_NPCCreateManyInput = {
    MAP_SVR_GROUP: number
    NPC_NUMBER: number
    NPC_INDEX: number
    NPC_DF_LEVEL: number
    NPC_RG_LEVEL: number
    NPC_MAXHP: number
    NPC_HP: number
    NPC_X: number
    NPC_Y: number
    NPC_DIR: number
    NPC_CREATEDATE: Date | string
  }

  export type MuCastle_NPCUpdateManyMutationInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    NPC_NUMBER?: IntFieldUpdateOperationsInput | number
    NPC_INDEX?: IntFieldUpdateOperationsInput | number
    NPC_DF_LEVEL?: IntFieldUpdateOperationsInput | number
    NPC_RG_LEVEL?: IntFieldUpdateOperationsInput | number
    NPC_MAXHP?: IntFieldUpdateOperationsInput | number
    NPC_HP?: IntFieldUpdateOperationsInput | number
    NPC_X?: IntFieldUpdateOperationsInput | number
    NPC_Y?: IntFieldUpdateOperationsInput | number
    NPC_DIR?: IntFieldUpdateOperationsInput | number
    NPC_CREATEDATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuCastle_NPCUncheckedUpdateManyInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    NPC_NUMBER?: IntFieldUpdateOperationsInput | number
    NPC_INDEX?: IntFieldUpdateOperationsInput | number
    NPC_DF_LEVEL?: IntFieldUpdateOperationsInput | number
    NPC_RG_LEVEL?: IntFieldUpdateOperationsInput | number
    NPC_MAXHP?: IntFieldUpdateOperationsInput | number
    NPC_HP?: IntFieldUpdateOperationsInput | number
    NPC_X?: IntFieldUpdateOperationsInput | number
    NPC_Y?: IntFieldUpdateOperationsInput | number
    NPC_DIR?: IntFieldUpdateOperationsInput | number
    NPC_CREATEDATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuCastle_REG_SIEGECreateInput = {
    MAP_SVR_GROUP: number
    REG_SIEGE_GUILD: string
    REG_MARKS: number
    IS_GIVEUP: number
    SEQ_NUM: number
  }

  export type MuCastle_REG_SIEGEUncheckedCreateInput = {
    MAP_SVR_GROUP: number
    REG_SIEGE_GUILD: string
    REG_MARKS: number
    IS_GIVEUP: number
    SEQ_NUM: number
  }

  export type MuCastle_REG_SIEGEUpdateInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    REG_SIEGE_GUILD?: StringFieldUpdateOperationsInput | string
    REG_MARKS?: IntFieldUpdateOperationsInput | number
    IS_GIVEUP?: IntFieldUpdateOperationsInput | number
    SEQ_NUM?: IntFieldUpdateOperationsInput | number
  }

  export type MuCastle_REG_SIEGEUncheckedUpdateInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    REG_SIEGE_GUILD?: StringFieldUpdateOperationsInput | string
    REG_MARKS?: IntFieldUpdateOperationsInput | number
    IS_GIVEUP?: IntFieldUpdateOperationsInput | number
    SEQ_NUM?: IntFieldUpdateOperationsInput | number
  }

  export type MuCastle_REG_SIEGECreateManyInput = {
    MAP_SVR_GROUP: number
    REG_SIEGE_GUILD: string
    REG_MARKS: number
    IS_GIVEUP: number
    SEQ_NUM: number
  }

  export type MuCastle_REG_SIEGEUpdateManyMutationInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    REG_SIEGE_GUILD?: StringFieldUpdateOperationsInput | string
    REG_MARKS?: IntFieldUpdateOperationsInput | number
    IS_GIVEUP?: IntFieldUpdateOperationsInput | number
    SEQ_NUM?: IntFieldUpdateOperationsInput | number
  }

  export type MuCastle_REG_SIEGEUncheckedUpdateManyInput = {
    MAP_SVR_GROUP?: IntFieldUpdateOperationsInput | number
    REG_SIEGE_GUILD?: StringFieldUpdateOperationsInput | string
    REG_MARKS?: IntFieldUpdateOperationsInput | number
    IS_GIVEUP?: IntFieldUpdateOperationsInput | number
    SEQ_NUM?: IntFieldUpdateOperationsInput | number
  }

  export type OptionDataCreateInput = {
    Name: string
    SkillKey?: Buffer | null
    GameOption?: number | null
    Qkey?: number | null
    Wkey?: number | null
    Ekey?: number | null
    ChatWindow?: number | null
    Rkey?: number | null
    QWERLevel?: number | null
  }

  export type OptionDataUncheckedCreateInput = {
    Name: string
    SkillKey?: Buffer | null
    GameOption?: number | null
    Qkey?: number | null
    Wkey?: number | null
    Ekey?: number | null
    ChatWindow?: number | null
    Rkey?: number | null
    QWERLevel?: number | null
  }

  export type OptionDataUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    SkillKey?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    GameOption?: NullableIntFieldUpdateOperationsInput | number | null
    Qkey?: NullableIntFieldUpdateOperationsInput | number | null
    Wkey?: NullableIntFieldUpdateOperationsInput | number | null
    Ekey?: NullableIntFieldUpdateOperationsInput | number | null
    ChatWindow?: NullableIntFieldUpdateOperationsInput | number | null
    Rkey?: NullableIntFieldUpdateOperationsInput | number | null
    QWERLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OptionDataUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    SkillKey?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    GameOption?: NullableIntFieldUpdateOperationsInput | number | null
    Qkey?: NullableIntFieldUpdateOperationsInput | number | null
    Wkey?: NullableIntFieldUpdateOperationsInput | number | null
    Ekey?: NullableIntFieldUpdateOperationsInput | number | null
    ChatWindow?: NullableIntFieldUpdateOperationsInput | number | null
    Rkey?: NullableIntFieldUpdateOperationsInput | number | null
    QWERLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OptionDataCreateManyInput = {
    Name: string
    SkillKey?: Buffer | null
    GameOption?: number | null
    Qkey?: number | null
    Wkey?: number | null
    Ekey?: number | null
    ChatWindow?: number | null
    Rkey?: number | null
    QWERLevel?: number | null
  }

  export type OptionDataUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    SkillKey?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    GameOption?: NullableIntFieldUpdateOperationsInput | number | null
    Qkey?: NullableIntFieldUpdateOperationsInput | number | null
    Wkey?: NullableIntFieldUpdateOperationsInput | number | null
    Ekey?: NullableIntFieldUpdateOperationsInput | number | null
    ChatWindow?: NullableIntFieldUpdateOperationsInput | number | null
    Rkey?: NullableIntFieldUpdateOperationsInput | number | null
    QWERLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OptionDataUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    SkillKey?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    GameOption?: NullableIntFieldUpdateOperationsInput | number | null
    Qkey?: NullableIntFieldUpdateOperationsInput | number | null
    Wkey?: NullableIntFieldUpdateOperationsInput | number | null
    Ekey?: NullableIntFieldUpdateOperationsInput | number | null
    ChatWindow?: NullableIntFieldUpdateOperationsInput | number | null
    Rkey?: NullableIntFieldUpdateOperationsInput | number | null
    QWERLevel?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestKillCountCreateInput = {
    Name: string
    QuestIndex?: number | null
    MonsterClass1?: number | null
    KillCount1?: number | null
    MonsterClass2?: number | null
    KillCount2?: number | null
    MonsterClass3?: number | null
    KillCount3?: number | null
    MonsterClass4?: number | null
    KillCount4?: number | null
    MonsterClass5?: number | null
    KillCount5?: number | null
  }

  export type QuestKillCountUncheckedCreateInput = {
    Name: string
    QuestIndex?: number | null
    MonsterClass1?: number | null
    KillCount1?: number | null
    MonsterClass2?: number | null
    KillCount2?: number | null
    MonsterClass3?: number | null
    KillCount3?: number | null
    MonsterClass4?: number | null
    KillCount4?: number | null
    MonsterClass5?: number | null
    KillCount5?: number | null
  }

  export type QuestKillCountUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    QuestIndex?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass1?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount1?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass2?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount2?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass3?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount3?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass4?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount4?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass5?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount5?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestKillCountUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    QuestIndex?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass1?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount1?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass2?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount2?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass3?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount3?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass4?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount4?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass5?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount5?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestKillCountCreateManyInput = {
    Name: string
    QuestIndex?: number | null
    MonsterClass1?: number | null
    KillCount1?: number | null
    MonsterClass2?: number | null
    KillCount2?: number | null
    MonsterClass3?: number | null
    KillCount3?: number | null
    MonsterClass4?: number | null
    KillCount4?: number | null
    MonsterClass5?: number | null
    KillCount5?: number | null
  }

  export type QuestKillCountUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    QuestIndex?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass1?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount1?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass2?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount2?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass3?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount3?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass4?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount4?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass5?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount5?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestKillCountUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    QuestIndex?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass1?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount1?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass2?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount2?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass3?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount3?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass4?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount4?: NullableIntFieldUpdateOperationsInput | number | null
    MonsterClass5?: NullableIntFieldUpdateOperationsInput | number | null
    KillCount5?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestWorldCreateInput = {
    Name: string
    QuestWorldList?: Buffer | null
  }

  export type QuestWorldUncheckedCreateInput = {
    Name: string
    QuestWorldList?: Buffer | null
  }

  export type QuestWorldUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    QuestWorldList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type QuestWorldUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    QuestWorldList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type QuestWorldCreateManyInput = {
    Name: string
    QuestWorldList?: Buffer | null
  }

  export type QuestWorldUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    QuestWorldList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type QuestWorldUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    QuestWorldList?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type RankingBloodCastleCreateInput = {
    Name: string
    Score?: number | null
  }

  export type RankingBloodCastleUncheckedCreateInput = {
    Name: string
    Score?: number | null
  }

  export type RankingBloodCastleUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingBloodCastleUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingBloodCastleCreateManyInput = {
    Name: string
    Score?: number | null
  }

  export type RankingBloodCastleUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingBloodCastleUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingChaosCastleCreateInput = {
    Name: string
    Score?: number | null
  }

  export type RankingChaosCastleUncheckedCreateInput = {
    Name: string
    Score?: number | null
  }

  export type RankingChaosCastleUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingChaosCastleUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingChaosCastleCreateManyInput = {
    Name: string
    Score?: number | null
  }

  export type RankingChaosCastleUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingChaosCastleUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingDevilSquareCreateInput = {
    Name: string
    Score?: number | null
  }

  export type RankingDevilSquareUncheckedCreateInput = {
    Name: string
    Score?: number | null
  }

  export type RankingDevilSquareUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingDevilSquareUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingDevilSquareCreateManyInput = {
    Name: string
    Score?: number | null
  }

  export type RankingDevilSquareUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingDevilSquareUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingDuelCreateInput = {
    Name: string
    WinScore?: number | null
    LoseScore?: number | null
  }

  export type RankingDuelUncheckedCreateInput = {
    Name: string
    WinScore?: number | null
    LoseScore?: number | null
  }

  export type RankingDuelUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    WinScore?: NullableIntFieldUpdateOperationsInput | number | null
    LoseScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingDuelUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    WinScore?: NullableIntFieldUpdateOperationsInput | number | null
    LoseScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingDuelCreateManyInput = {
    Name: string
    WinScore?: number | null
    LoseScore?: number | null
  }

  export type RankingDuelUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    WinScore?: NullableIntFieldUpdateOperationsInput | number | null
    LoseScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingDuelUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    WinScore?: NullableIntFieldUpdateOperationsInput | number | null
    LoseScore?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingIllusionTempleCreateInput = {
    Name: string
    Score?: number | null
  }

  export type RankingIllusionTempleUncheckedCreateInput = {
    Name: string
    Score?: number | null
  }

  export type RankingIllusionTempleUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingIllusionTempleUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingIllusionTempleCreateManyInput = {
    Name: string
    Score?: number | null
  }

  export type RankingIllusionTempleUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RankingIllusionTempleUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_CGuidCreateInput = {
    Name: string
  }

  export type T_CGuidUncheckedCreateInput = {
    GUID?: number
    Name: string
  }

  export type T_CGuidUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type T_CGuidUncheckedUpdateInput = {
    GUID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type T_CGuidCreateManyInput = {
    Name: string
  }

  export type T_CGuidUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type T_CGuidUncheckedUpdateManyInput = {
    GUID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type T_FriendMailCreateInput = {
    MemoIndex?: number
    GUID: number
    FriendName?: string | null
    wDate?: Date | string
    Subject?: string | null
    bRead?: boolean
    Memo?: Buffer | null
    Photo?: Buffer | null
    Dir?: number | null
    Act?: number | null
  }

  export type T_FriendMailUncheckedCreateInput = {
    MemoIndex?: number
    GUID: number
    FriendName?: string | null
    wDate?: Date | string
    Subject?: string | null
    bRead?: boolean
    Memo?: Buffer | null
    Photo?: Buffer | null
    Dir?: number | null
    Act?: number | null
  }

  export type T_FriendMailUpdateInput = {
    MemoIndex?: IntFieldUpdateOperationsInput | number
    GUID?: IntFieldUpdateOperationsInput | number
    FriendName?: NullableStringFieldUpdateOperationsInput | string | null
    wDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    bRead?: BoolFieldUpdateOperationsInput | boolean
    Memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Dir?: NullableIntFieldUpdateOperationsInput | number | null
    Act?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_FriendMailUncheckedUpdateInput = {
    MemoIndex?: IntFieldUpdateOperationsInput | number
    GUID?: IntFieldUpdateOperationsInput | number
    FriendName?: NullableStringFieldUpdateOperationsInput | string | null
    wDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    bRead?: BoolFieldUpdateOperationsInput | boolean
    Memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Dir?: NullableIntFieldUpdateOperationsInput | number | null
    Act?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_FriendMailCreateManyInput = {
    MemoIndex?: number
    GUID: number
    FriendName?: string | null
    wDate?: Date | string
    Subject?: string | null
    bRead?: boolean
    Memo?: Buffer | null
    Photo?: Buffer | null
    Dir?: number | null
    Act?: number | null
  }

  export type T_FriendMailUpdateManyMutationInput = {
    MemoIndex?: IntFieldUpdateOperationsInput | number
    GUID?: IntFieldUpdateOperationsInput | number
    FriendName?: NullableStringFieldUpdateOperationsInput | string | null
    wDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    bRead?: BoolFieldUpdateOperationsInput | boolean
    Memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Dir?: NullableIntFieldUpdateOperationsInput | number | null
    Act?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_FriendMailUncheckedUpdateManyInput = {
    MemoIndex?: IntFieldUpdateOperationsInput | number
    GUID?: IntFieldUpdateOperationsInput | number
    FriendName?: NullableStringFieldUpdateOperationsInput | string | null
    wDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Subject?: NullableStringFieldUpdateOperationsInput | string | null
    bRead?: BoolFieldUpdateOperationsInput | boolean
    Memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Photo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Dir?: NullableIntFieldUpdateOperationsInput | number | null
    Act?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_FriendMainCreateInput = {
    GUID: number
    Name: string
    FriendCount?: number | null
    MemoCount?: number | null
    MemoTotal?: number | null
  }

  export type T_FriendMainUncheckedCreateInput = {
    GUID: number
    Name: string
    FriendCount?: number | null
    MemoCount?: number | null
    MemoTotal?: number | null
  }

  export type T_FriendMainUpdateInput = {
    GUID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    FriendCount?: NullableIntFieldUpdateOperationsInput | number | null
    MemoCount?: NullableIntFieldUpdateOperationsInput | number | null
    MemoTotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_FriendMainUncheckedUpdateInput = {
    GUID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    FriendCount?: NullableIntFieldUpdateOperationsInput | number | null
    MemoCount?: NullableIntFieldUpdateOperationsInput | number | null
    MemoTotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_FriendMainCreateManyInput = {
    GUID: number
    Name: string
    FriendCount?: number | null
    MemoCount?: number | null
    MemoTotal?: number | null
  }

  export type T_FriendMainUpdateManyMutationInput = {
    GUID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    FriendCount?: NullableIntFieldUpdateOperationsInput | number | null
    MemoCount?: NullableIntFieldUpdateOperationsInput | number | null
    MemoTotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_FriendMainUncheckedUpdateManyInput = {
    GUID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    FriendCount?: NullableIntFieldUpdateOperationsInput | number | null
    MemoCount?: NullableIntFieldUpdateOperationsInput | number | null
    MemoTotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_PetItem_InfoCreateInput = {
    ItemSerial: number
    Pet_Level?: number | null
    Pet_Exp?: number | null
  }

  export type T_PetItem_InfoUncheckedCreateInput = {
    ItemSerial: number
    Pet_Level?: number | null
    Pet_Exp?: number | null
  }

  export type T_PetItem_InfoUpdateInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    Pet_Level?: NullableIntFieldUpdateOperationsInput | number | null
    Pet_Exp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_PetItem_InfoUncheckedUpdateInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    Pet_Level?: NullableIntFieldUpdateOperationsInput | number | null
    Pet_Exp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_PetItem_InfoCreateManyInput = {
    ItemSerial: number
    Pet_Level?: number | null
    Pet_Exp?: number | null
  }

  export type T_PetItem_InfoUpdateManyMutationInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    Pet_Level?: NullableIntFieldUpdateOperationsInput | number | null
    Pet_Exp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type T_PetItem_InfoUncheckedUpdateManyInput = {
    ItemSerial?: IntFieldUpdateOperationsInput | number
    Pet_Level?: NullableIntFieldUpdateOperationsInput | number | null
    Pet_Exp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type warehouseCreateInput = {
    AccountID: string
    Items?: Buffer | null
    Money?: number | null
    EndUseDate?: Date | string | null
    DbVersion?: number | null
    pw?: number | null
    VaultCounts?: number
    LastVaultID?: number
  }

  export type warehouseUncheckedCreateInput = {
    AccountID: string
    Items?: Buffer | null
    Money?: number | null
    EndUseDate?: Date | string | null
    DbVersion?: number | null
    pw?: number | null
    VaultCounts?: number
    LastVaultID?: number
  }

  export type warehouseUpdateInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    Items?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Money?: NullableIntFieldUpdateOperationsInput | number | null
    EndUseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    pw?: NullableIntFieldUpdateOperationsInput | number | null
    VaultCounts?: IntFieldUpdateOperationsInput | number
    LastVaultID?: IntFieldUpdateOperationsInput | number
  }

  export type warehouseUncheckedUpdateInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    Items?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Money?: NullableIntFieldUpdateOperationsInput | number | null
    EndUseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    pw?: NullableIntFieldUpdateOperationsInput | number | null
    VaultCounts?: IntFieldUpdateOperationsInput | number
    LastVaultID?: IntFieldUpdateOperationsInput | number
  }

  export type warehouseCreateManyInput = {
    AccountID: string
    Items?: Buffer | null
    Money?: number | null
    EndUseDate?: Date | string | null
    DbVersion?: number | null
    pw?: number | null
    VaultCounts?: number
    LastVaultID?: number
  }

  export type warehouseUpdateManyMutationInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    Items?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Money?: NullableIntFieldUpdateOperationsInput | number | null
    EndUseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    pw?: NullableIntFieldUpdateOperationsInput | number | null
    VaultCounts?: IntFieldUpdateOperationsInput | number
    LastVaultID?: IntFieldUpdateOperationsInput | number
  }

  export type warehouseUncheckedUpdateManyInput = {
    AccountID?: StringFieldUpdateOperationsInput | string
    Items?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    Money?: NullableIntFieldUpdateOperationsInput | number | null
    EndUseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DbVersion?: NullableIntFieldUpdateOperationsInput | number | null
    pw?: NullableIntFieldUpdateOperationsInput | number | null
    VaultCounts?: IntFieldUpdateOperationsInput | number
    LastVaultID?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MEMB_INFOCountOrderByAggregateInput = {
    memb_guid?: SortOrder
    memb___id?: SortOrder
    memb__pwd?: SortOrder
    memb_name?: SortOrder
    sno__numb?: SortOrder
    post_code?: SortOrder
    addr_info?: SortOrder
    addr_deta?: SortOrder
    tel__numb?: SortOrder
    phon_numb?: SortOrder
    mail_addr?: SortOrder
    fpas_ques?: SortOrder
    fpas_answ?: SortOrder
    job__code?: SortOrder
    appl_days?: SortOrder
    modi_days?: SortOrder
    out__days?: SortOrder
    true_days?: SortOrder
    mail_chek?: SortOrder
    bloc_code?: SortOrder
    ctl1_code?: SortOrder
    AccountLevel?: SortOrder
    AccountExpireDate?: SortOrder
    vip?: SortOrder
    cash?: SortOrder
    RewardPlayer?: SortOrder
    ChaosPoints?: SortOrder
    BlessPoints?: SortOrder
    SoulPoints?: SortOrder
    LifePoints?: SortOrder
    CreationPoints?: SortOrder
    GuardianPoints?: SortOrder
    GemstonePoints?: SortOrder
    HarmonyPoints?: SortOrder
    LRefiningPoints?: SortOrder
    HRefiningPoints?: SortOrder
    LockPassword?: SortOrder
  }

  export type MEMB_INFOAvgOrderByAggregateInput = {
    memb_guid?: SortOrder
    AccountLevel?: SortOrder
    vip?: SortOrder
    cash?: SortOrder
    RewardPlayer?: SortOrder
    ChaosPoints?: SortOrder
    BlessPoints?: SortOrder
    SoulPoints?: SortOrder
    LifePoints?: SortOrder
    CreationPoints?: SortOrder
    GuardianPoints?: SortOrder
    GemstonePoints?: SortOrder
    HarmonyPoints?: SortOrder
    LRefiningPoints?: SortOrder
    HRefiningPoints?: SortOrder
    LockPassword?: SortOrder
  }

  export type MEMB_INFOMaxOrderByAggregateInput = {
    memb_guid?: SortOrder
    memb___id?: SortOrder
    memb__pwd?: SortOrder
    memb_name?: SortOrder
    sno__numb?: SortOrder
    post_code?: SortOrder
    addr_info?: SortOrder
    addr_deta?: SortOrder
    tel__numb?: SortOrder
    phon_numb?: SortOrder
    mail_addr?: SortOrder
    fpas_ques?: SortOrder
    fpas_answ?: SortOrder
    job__code?: SortOrder
    appl_days?: SortOrder
    modi_days?: SortOrder
    out__days?: SortOrder
    true_days?: SortOrder
    mail_chek?: SortOrder
    bloc_code?: SortOrder
    ctl1_code?: SortOrder
    AccountLevel?: SortOrder
    AccountExpireDate?: SortOrder
    vip?: SortOrder
    cash?: SortOrder
    RewardPlayer?: SortOrder
    ChaosPoints?: SortOrder
    BlessPoints?: SortOrder
    SoulPoints?: SortOrder
    LifePoints?: SortOrder
    CreationPoints?: SortOrder
    GuardianPoints?: SortOrder
    GemstonePoints?: SortOrder
    HarmonyPoints?: SortOrder
    LRefiningPoints?: SortOrder
    HRefiningPoints?: SortOrder
    LockPassword?: SortOrder
  }

  export type MEMB_INFOMinOrderByAggregateInput = {
    memb_guid?: SortOrder
    memb___id?: SortOrder
    memb__pwd?: SortOrder
    memb_name?: SortOrder
    sno__numb?: SortOrder
    post_code?: SortOrder
    addr_info?: SortOrder
    addr_deta?: SortOrder
    tel__numb?: SortOrder
    phon_numb?: SortOrder
    mail_addr?: SortOrder
    fpas_ques?: SortOrder
    fpas_answ?: SortOrder
    job__code?: SortOrder
    appl_days?: SortOrder
    modi_days?: SortOrder
    out__days?: SortOrder
    true_days?: SortOrder
    mail_chek?: SortOrder
    bloc_code?: SortOrder
    ctl1_code?: SortOrder
    AccountLevel?: SortOrder
    AccountExpireDate?: SortOrder
    vip?: SortOrder
    cash?: SortOrder
    RewardPlayer?: SortOrder
    ChaosPoints?: SortOrder
    BlessPoints?: SortOrder
    SoulPoints?: SortOrder
    LifePoints?: SortOrder
    CreationPoints?: SortOrder
    GuardianPoints?: SortOrder
    GemstonePoints?: SortOrder
    HarmonyPoints?: SortOrder
    LRefiningPoints?: SortOrder
    HRefiningPoints?: SortOrder
    LockPassword?: SortOrder
  }

  export type MEMB_INFOSumOrderByAggregateInput = {
    memb_guid?: SortOrder
    AccountLevel?: SortOrder
    vip?: SortOrder
    cash?: SortOrder
    RewardPlayer?: SortOrder
    ChaosPoints?: SortOrder
    BlessPoints?: SortOrder
    SoulPoints?: SortOrder
    LifePoints?: SortOrder
    CreationPoints?: SortOrder
    GuardianPoints?: SortOrder
    GemstonePoints?: SortOrder
    HarmonyPoints?: SortOrder
    LRefiningPoints?: SortOrder
    HRefiningPoints?: SortOrder
    LockPassword?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountCharacterCountOrderByAggregateInput = {
    Number?: SortOrder
    Id?: SortOrder
    GameID1?: SortOrder
    GameID2?: SortOrder
    GameID3?: SortOrder
    GameID4?: SortOrder
    GameID5?: SortOrder
    GameIDC?: SortOrder
    MoveCnt?: SortOrder
    ExtClass?: SortOrder
    ExtWarehouse?: SortOrder
    GameID6?: SortOrder
    GameID7?: SortOrder
    GameID8?: SortOrder
    GameID9?: SortOrder
    GameID10?: SortOrder
    MaxCharacter?: SortOrder
  }

  export type AccountCharacterAvgOrderByAggregateInput = {
    Number?: SortOrder
    MoveCnt?: SortOrder
    ExtClass?: SortOrder
    ExtWarehouse?: SortOrder
    MaxCharacter?: SortOrder
  }

  export type AccountCharacterMaxOrderByAggregateInput = {
    Number?: SortOrder
    Id?: SortOrder
    GameID1?: SortOrder
    GameID2?: SortOrder
    GameID3?: SortOrder
    GameID4?: SortOrder
    GameID5?: SortOrder
    GameIDC?: SortOrder
    MoveCnt?: SortOrder
    ExtClass?: SortOrder
    ExtWarehouse?: SortOrder
    GameID6?: SortOrder
    GameID7?: SortOrder
    GameID8?: SortOrder
    GameID9?: SortOrder
    GameID10?: SortOrder
    MaxCharacter?: SortOrder
  }

  export type AccountCharacterMinOrderByAggregateInput = {
    Number?: SortOrder
    Id?: SortOrder
    GameID1?: SortOrder
    GameID2?: SortOrder
    GameID3?: SortOrder
    GameID4?: SortOrder
    GameID5?: SortOrder
    GameIDC?: SortOrder
    MoveCnt?: SortOrder
    ExtClass?: SortOrder
    ExtWarehouse?: SortOrder
    GameID6?: SortOrder
    GameID7?: SortOrder
    GameID8?: SortOrder
    GameID9?: SortOrder
    GameID10?: SortOrder
    MaxCharacter?: SortOrder
  }

  export type AccountCharacterSumOrderByAggregateInput = {
    Number?: SortOrder
    MoveCnt?: SortOrder
    ExtClass?: SortOrder
    ExtWarehouse?: SortOrder
    MaxCharacter?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CashShopDataCountOrderByAggregateInput = {
    AccountID?: SortOrder
    WCoinC?: SortOrder
    WCoinP?: SortOrder
    GoblinPoint?: SortOrder
  }

  export type CashShopDataAvgOrderByAggregateInput = {
    WCoinC?: SortOrder
    WCoinP?: SortOrder
    GoblinPoint?: SortOrder
  }

  export type CashShopDataMaxOrderByAggregateInput = {
    AccountID?: SortOrder
    WCoinC?: SortOrder
    WCoinP?: SortOrder
    GoblinPoint?: SortOrder
  }

  export type CashShopDataMinOrderByAggregateInput = {
    AccountID?: SortOrder
    WCoinC?: SortOrder
    WCoinP?: SortOrder
    GoblinPoint?: SortOrder
  }

  export type CashShopDataSumOrderByAggregateInput = {
    WCoinC?: SortOrder
    WCoinP?: SortOrder
    GoblinPoint?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CashShopInventoryCountOrderByAggregateInput = {
    BaseItemCode?: SortOrder
    MainItemCode?: SortOrder
    AccountID?: SortOrder
    InventoryType?: SortOrder
    PackageMainIndex?: SortOrder
    ProductBaseIndex?: SortOrder
    ProductMainIndex?: SortOrder
    CoinValue?: SortOrder
    ProductType?: SortOrder
    GiftName?: SortOrder
    GiftText?: SortOrder
  }

  export type CashShopInventoryAvgOrderByAggregateInput = {
    BaseItemCode?: SortOrder
    MainItemCode?: SortOrder
    InventoryType?: SortOrder
    PackageMainIndex?: SortOrder
    ProductBaseIndex?: SortOrder
    ProductMainIndex?: SortOrder
    CoinValue?: SortOrder
    ProductType?: SortOrder
  }

  export type CashShopInventoryMaxOrderByAggregateInput = {
    BaseItemCode?: SortOrder
    MainItemCode?: SortOrder
    AccountID?: SortOrder
    InventoryType?: SortOrder
    PackageMainIndex?: SortOrder
    ProductBaseIndex?: SortOrder
    ProductMainIndex?: SortOrder
    CoinValue?: SortOrder
    ProductType?: SortOrder
    GiftName?: SortOrder
    GiftText?: SortOrder
  }

  export type CashShopInventoryMinOrderByAggregateInput = {
    BaseItemCode?: SortOrder
    MainItemCode?: SortOrder
    AccountID?: SortOrder
    InventoryType?: SortOrder
    PackageMainIndex?: SortOrder
    ProductBaseIndex?: SortOrder
    ProductMainIndex?: SortOrder
    CoinValue?: SortOrder
    ProductType?: SortOrder
    GiftName?: SortOrder
    GiftText?: SortOrder
  }

  export type CashShopInventorySumOrderByAggregateInput = {
    BaseItemCode?: SortOrder
    MainItemCode?: SortOrder
    InventoryType?: SortOrder
    PackageMainIndex?: SortOrder
    ProductBaseIndex?: SortOrder
    ProductMainIndex?: SortOrder
    CoinValue?: SortOrder
    ProductType?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CashShopPeriodicItemCountOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Time?: SortOrder
  }

  export type CashShopPeriodicItemAvgOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Time?: SortOrder
  }

  export type CashShopPeriodicItemMaxOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Time?: SortOrder
  }

  export type CashShopPeriodicItemMinOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Time?: SortOrder
  }

  export type CashShopPeriodicItemSumOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Time?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type CharacterCountOrderByAggregateInput = {
    AccountID?: SortOrder
    Name?: SortOrder
    cLevel?: SortOrder
    LevelUpPoint?: SortOrder
    Class?: SortOrder
    Experience?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Inventory?: SortOrder
    MagicList?: SortOrder
    Money?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    BP?: SortOrder
    MaxBP?: SortOrder
    Shield?: SortOrder
    MaxShield?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    MapDir?: SortOrder
    PkCount?: SortOrder
    PkLevel?: SortOrder
    PkTime?: SortOrder
    MDate?: SortOrder
    LDate?: SortOrder
    CtlCode?: SortOrder
    DbVersion?: SortOrder
    Quest?: SortOrder
    ChatLimitTime?: SortOrder
    FruitPoint?: SortOrder
    EffectList?: SortOrder
    FruitAddPoint?: SortOrder
    FruitSubPoint?: SortOrder
    ResetCount?: SortOrder
    MasterResetCount?: SortOrder
    ExtInventory?: SortOrder
    Resets?: SortOrder
    ResetsDay?: SortOrder
    ResetsWeek?: SortOrder
    ResetsMonth?: SortOrder
    MResets?: SortOrder
    MResetsDay?: SortOrder
    MResetsWeek?: SortOrder
    MResetsMonth?: SortOrder
    PKTotal?: SortOrder
    PKDay?: SortOrder
    PKWeek?: SortOrder
    PKMonth?: SortOrder
    HeroTotal?: SortOrder
    HeroDay?: SortOrder
    HeroWeek?: SortOrder
    HeroMonth?: SortOrder
    tradewins?: SortOrder
    matamata?: SortOrder
    duel_total?: SortOrder
    duel_semanal?: SortOrder
    duel_mensal?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    cLevel?: SortOrder
    LevelUpPoint?: SortOrder
    Class?: SortOrder
    Experience?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Money?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    BP?: SortOrder
    MaxBP?: SortOrder
    Shield?: SortOrder
    MaxShield?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    MapDir?: SortOrder
    PkCount?: SortOrder
    PkLevel?: SortOrder
    PkTime?: SortOrder
    CtlCode?: SortOrder
    DbVersion?: SortOrder
    ChatLimitTime?: SortOrder
    FruitPoint?: SortOrder
    FruitAddPoint?: SortOrder
    FruitSubPoint?: SortOrder
    ResetCount?: SortOrder
    MasterResetCount?: SortOrder
    ExtInventory?: SortOrder
    Resets?: SortOrder
    ResetsDay?: SortOrder
    ResetsWeek?: SortOrder
    ResetsMonth?: SortOrder
    MResets?: SortOrder
    MResetsDay?: SortOrder
    MResetsWeek?: SortOrder
    MResetsMonth?: SortOrder
    PKTotal?: SortOrder
    PKDay?: SortOrder
    PKWeek?: SortOrder
    PKMonth?: SortOrder
    HeroTotal?: SortOrder
    HeroDay?: SortOrder
    HeroWeek?: SortOrder
    HeroMonth?: SortOrder
    tradewins?: SortOrder
    matamata?: SortOrder
    duel_total?: SortOrder
    duel_semanal?: SortOrder
    duel_mensal?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    AccountID?: SortOrder
    Name?: SortOrder
    cLevel?: SortOrder
    LevelUpPoint?: SortOrder
    Class?: SortOrder
    Experience?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Inventory?: SortOrder
    MagicList?: SortOrder
    Money?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    BP?: SortOrder
    MaxBP?: SortOrder
    Shield?: SortOrder
    MaxShield?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    MapDir?: SortOrder
    PkCount?: SortOrder
    PkLevel?: SortOrder
    PkTime?: SortOrder
    MDate?: SortOrder
    LDate?: SortOrder
    CtlCode?: SortOrder
    DbVersion?: SortOrder
    Quest?: SortOrder
    ChatLimitTime?: SortOrder
    FruitPoint?: SortOrder
    EffectList?: SortOrder
    FruitAddPoint?: SortOrder
    FruitSubPoint?: SortOrder
    ResetCount?: SortOrder
    MasterResetCount?: SortOrder
    ExtInventory?: SortOrder
    Resets?: SortOrder
    ResetsDay?: SortOrder
    ResetsWeek?: SortOrder
    ResetsMonth?: SortOrder
    MResets?: SortOrder
    MResetsDay?: SortOrder
    MResetsWeek?: SortOrder
    MResetsMonth?: SortOrder
    PKTotal?: SortOrder
    PKDay?: SortOrder
    PKWeek?: SortOrder
    PKMonth?: SortOrder
    HeroTotal?: SortOrder
    HeroDay?: SortOrder
    HeroWeek?: SortOrder
    HeroMonth?: SortOrder
    tradewins?: SortOrder
    matamata?: SortOrder
    duel_total?: SortOrder
    duel_semanal?: SortOrder
    duel_mensal?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    AccountID?: SortOrder
    Name?: SortOrder
    cLevel?: SortOrder
    LevelUpPoint?: SortOrder
    Class?: SortOrder
    Experience?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Inventory?: SortOrder
    MagicList?: SortOrder
    Money?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    BP?: SortOrder
    MaxBP?: SortOrder
    Shield?: SortOrder
    MaxShield?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    MapDir?: SortOrder
    PkCount?: SortOrder
    PkLevel?: SortOrder
    PkTime?: SortOrder
    MDate?: SortOrder
    LDate?: SortOrder
    CtlCode?: SortOrder
    DbVersion?: SortOrder
    Quest?: SortOrder
    ChatLimitTime?: SortOrder
    FruitPoint?: SortOrder
    EffectList?: SortOrder
    FruitAddPoint?: SortOrder
    FruitSubPoint?: SortOrder
    ResetCount?: SortOrder
    MasterResetCount?: SortOrder
    ExtInventory?: SortOrder
    Resets?: SortOrder
    ResetsDay?: SortOrder
    ResetsWeek?: SortOrder
    ResetsMonth?: SortOrder
    MResets?: SortOrder
    MResetsDay?: SortOrder
    MResetsWeek?: SortOrder
    MResetsMonth?: SortOrder
    PKTotal?: SortOrder
    PKDay?: SortOrder
    PKWeek?: SortOrder
    PKMonth?: SortOrder
    HeroTotal?: SortOrder
    HeroDay?: SortOrder
    HeroWeek?: SortOrder
    HeroMonth?: SortOrder
    tradewins?: SortOrder
    matamata?: SortOrder
    duel_total?: SortOrder
    duel_semanal?: SortOrder
    duel_mensal?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    cLevel?: SortOrder
    LevelUpPoint?: SortOrder
    Class?: SortOrder
    Experience?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Money?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    BP?: SortOrder
    MaxBP?: SortOrder
    Shield?: SortOrder
    MaxShield?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    MapDir?: SortOrder
    PkCount?: SortOrder
    PkLevel?: SortOrder
    PkTime?: SortOrder
    CtlCode?: SortOrder
    DbVersion?: SortOrder
    ChatLimitTime?: SortOrder
    FruitPoint?: SortOrder
    FruitAddPoint?: SortOrder
    FruitSubPoint?: SortOrder
    ResetCount?: SortOrder
    MasterResetCount?: SortOrder
    ExtInventory?: SortOrder
    Resets?: SortOrder
    ResetsDay?: SortOrder
    ResetsWeek?: SortOrder
    ResetsMonth?: SortOrder
    MResets?: SortOrder
    MResetsDay?: SortOrder
    MResetsWeek?: SortOrder
    MResetsMonth?: SortOrder
    PKTotal?: SortOrder
    PKDay?: SortOrder
    PKWeek?: SortOrder
    PKMonth?: SortOrder
    HeroTotal?: SortOrder
    HeroDay?: SortOrder
    HeroWeek?: SortOrder
    HeroMonth?: SortOrder
    tradewins?: SortOrder
    matamata?: SortOrder
    duel_total?: SortOrder
    duel_semanal?: SortOrder
    duel_mensal?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type DefaultClassTypeCountOrderByAggregateInput = {
    Class?: SortOrder
    Level?: SortOrder
    LevelUpPoint?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Inventory?: SortOrder
    MagicList?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    Quest?: SortOrder
    DbVersion?: SortOrder
    EffectList?: SortOrder
  }

  export type DefaultClassTypeAvgOrderByAggregateInput = {
    Class?: SortOrder
    Level?: SortOrder
    LevelUpPoint?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    DbVersion?: SortOrder
  }

  export type DefaultClassTypeMaxOrderByAggregateInput = {
    Class?: SortOrder
    Level?: SortOrder
    LevelUpPoint?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Inventory?: SortOrder
    MagicList?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    Quest?: SortOrder
    DbVersion?: SortOrder
    EffectList?: SortOrder
  }

  export type DefaultClassTypeMinOrderByAggregateInput = {
    Class?: SortOrder
    Level?: SortOrder
    LevelUpPoint?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Inventory?: SortOrder
    MagicList?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    Quest?: SortOrder
    DbVersion?: SortOrder
    EffectList?: SortOrder
  }

  export type DefaultClassTypeSumOrderByAggregateInput = {
    Class?: SortOrder
    Level?: SortOrder
    LevelUpPoint?: SortOrder
    Strength?: SortOrder
    Dexterity?: SortOrder
    Vitality?: SortOrder
    Energy?: SortOrder
    Leadership?: SortOrder
    Life?: SortOrder
    MaxLife?: SortOrder
    Mana?: SortOrder
    MaxMana?: SortOrder
    MapNumber?: SortOrder
    MapPosX?: SortOrder
    MapPosY?: SortOrder
    DbVersion?: SortOrder
  }

  export type EventLeoTheHelperCountOrderByAggregateInput = {
    Name?: SortOrder
    Status?: SortOrder
  }

  export type EventLeoTheHelperAvgOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type EventLeoTheHelperMaxOrderByAggregateInput = {
    Name?: SortOrder
    Status?: SortOrder
  }

  export type EventLeoTheHelperMinOrderByAggregateInput = {
    Name?: SortOrder
    Status?: SortOrder
  }

  export type EventLeoTheHelperSumOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type EventSantaClausCountOrderByAggregateInput = {
    Name?: SortOrder
    Status?: SortOrder
  }

  export type EventSantaClausAvgOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type EventSantaClausMaxOrderByAggregateInput = {
    Name?: SortOrder
    Status?: SortOrder
  }

  export type EventSantaClausMinOrderByAggregateInput = {
    Name?: SortOrder
    Status?: SortOrder
  }

  export type EventSantaClausSumOrderByAggregateInput = {
    Status?: SortOrder
  }

  export type GameServerInfoCountOrderByAggregateInput = {
    Number?: SortOrder
    ItemCount?: SortOrder
    ZenCount?: SortOrder
    AceItemCount?: SortOrder
  }

  export type GameServerInfoAvgOrderByAggregateInput = {
    Number?: SortOrder
    ItemCount?: SortOrder
    ZenCount?: SortOrder
    AceItemCount?: SortOrder
  }

  export type GameServerInfoMaxOrderByAggregateInput = {
    Number?: SortOrder
    ItemCount?: SortOrder
    ZenCount?: SortOrder
    AceItemCount?: SortOrder
  }

  export type GameServerInfoMinOrderByAggregateInput = {
    Number?: SortOrder
    ItemCount?: SortOrder
    ZenCount?: SortOrder
    AceItemCount?: SortOrder
  }

  export type GameServerInfoSumOrderByAggregateInput = {
    Number?: SortOrder
    ItemCount?: SortOrder
    ZenCount?: SortOrder
    AceItemCount?: SortOrder
  }

  export type Gens_RankCountOrderByAggregateInput = {
    Name?: SortOrder
    Family?: SortOrder
    Contribution?: SortOrder
  }

  export type Gens_RankAvgOrderByAggregateInput = {
    Family?: SortOrder
    Contribution?: SortOrder
  }

  export type Gens_RankMaxOrderByAggregateInput = {
    Name?: SortOrder
    Family?: SortOrder
    Contribution?: SortOrder
  }

  export type Gens_RankMinOrderByAggregateInput = {
    Name?: SortOrder
    Family?: SortOrder
    Contribution?: SortOrder
  }

  export type Gens_RankSumOrderByAggregateInput = {
    Family?: SortOrder
    Contribution?: SortOrder
  }

  export type Gens_RewardCountOrderByAggregateInput = {
    Name?: SortOrder
    Rank?: SortOrder
    Status?: SortOrder
  }

  export type Gens_RewardAvgOrderByAggregateInput = {
    Rank?: SortOrder
    Status?: SortOrder
  }

  export type Gens_RewardMaxOrderByAggregateInput = {
    Name?: SortOrder
    Rank?: SortOrder
    Status?: SortOrder
  }

  export type Gens_RewardMinOrderByAggregateInput = {
    Name?: SortOrder
    Rank?: SortOrder
    Status?: SortOrder
  }

  export type Gens_RewardSumOrderByAggregateInput = {
    Rank?: SortOrder
    Status?: SortOrder
  }

  export type GuildCountOrderByAggregateInput = {
    G_Name?: SortOrder
    G_Mark?: SortOrder
    G_Score?: SortOrder
    G_Master?: SortOrder
    G_Count?: SortOrder
    G_Notice?: SortOrder
    Number?: SortOrder
    G_Type?: SortOrder
    G_Rival?: SortOrder
    G_Union?: SortOrder
    MemberCount?: SortOrder
  }

  export type GuildAvgOrderByAggregateInput = {
    G_Score?: SortOrder
    G_Count?: SortOrder
    Number?: SortOrder
    G_Type?: SortOrder
    G_Rival?: SortOrder
    G_Union?: SortOrder
    MemberCount?: SortOrder
  }

  export type GuildMaxOrderByAggregateInput = {
    G_Name?: SortOrder
    G_Mark?: SortOrder
    G_Score?: SortOrder
    G_Master?: SortOrder
    G_Count?: SortOrder
    G_Notice?: SortOrder
    Number?: SortOrder
    G_Type?: SortOrder
    G_Rival?: SortOrder
    G_Union?: SortOrder
    MemberCount?: SortOrder
  }

  export type GuildMinOrderByAggregateInput = {
    G_Name?: SortOrder
    G_Mark?: SortOrder
    G_Score?: SortOrder
    G_Master?: SortOrder
    G_Count?: SortOrder
    G_Notice?: SortOrder
    Number?: SortOrder
    G_Type?: SortOrder
    G_Rival?: SortOrder
    G_Union?: SortOrder
    MemberCount?: SortOrder
  }

  export type GuildSumOrderByAggregateInput = {
    G_Score?: SortOrder
    G_Count?: SortOrder
    Number?: SortOrder
    G_Type?: SortOrder
    G_Rival?: SortOrder
    G_Union?: SortOrder
    MemberCount?: SortOrder
  }

  export type GuildMemberCountOrderByAggregateInput = {
    Name?: SortOrder
    G_Name?: SortOrder
    G_Level?: SortOrder
    G_Status?: SortOrder
  }

  export type GuildMemberAvgOrderByAggregateInput = {
    G_Level?: SortOrder
    G_Status?: SortOrder
  }

  export type GuildMemberMaxOrderByAggregateInput = {
    Name?: SortOrder
    G_Name?: SortOrder
    G_Level?: SortOrder
    G_Status?: SortOrder
  }

  export type GuildMemberMinOrderByAggregateInput = {
    Name?: SortOrder
    G_Name?: SortOrder
    G_Level?: SortOrder
    G_Status?: SortOrder
  }

  export type GuildMemberSumOrderByAggregateInput = {
    G_Level?: SortOrder
    G_Status?: SortOrder
  }

  export type HelperDataCountOrderByAggregateInput = {
    Name?: SortOrder
    Data?: SortOrder
  }

  export type HelperDataMaxOrderByAggregateInput = {
    Name?: SortOrder
    Data?: SortOrder
  }

  export type HelperDataMinOrderByAggregateInput = {
    Name?: SortOrder
    Data?: SortOrder
  }

  export type LuckyCoinCountOrderByAggregateInput = {
    AccountID?: SortOrder
    LuckyCoin?: SortOrder
  }

  export type LuckyCoinAvgOrderByAggregateInput = {
    LuckyCoin?: SortOrder
  }

  export type LuckyCoinMaxOrderByAggregateInput = {
    AccountID?: SortOrder
    LuckyCoin?: SortOrder
  }

  export type LuckyCoinMinOrderByAggregateInput = {
    AccountID?: SortOrder
    LuckyCoin?: SortOrder
  }

  export type LuckyCoinSumOrderByAggregateInput = {
    LuckyCoin?: SortOrder
  }

  export type LuckyItemCountOrderByAggregateInput = {
    ItemSerial?: SortOrder
    DurabilitySmall?: SortOrder
  }

  export type LuckyItemAvgOrderByAggregateInput = {
    ItemSerial?: SortOrder
    DurabilitySmall?: SortOrder
  }

  export type LuckyItemMaxOrderByAggregateInput = {
    ItemSerial?: SortOrder
    DurabilitySmall?: SortOrder
  }

  export type LuckyItemMinOrderByAggregateInput = {
    ItemSerial?: SortOrder
    DurabilitySmall?: SortOrder
  }

  export type LuckyItemSumOrderByAggregateInput = {
    ItemSerial?: SortOrder
    DurabilitySmall?: SortOrder
  }

  export type MEMB_STATCountOrderByAggregateInput = {
    memb___id?: SortOrder
    ConnectStat?: SortOrder
    ServerName?: SortOrder
    IP?: SortOrder
    ConnectTM?: SortOrder
    DisConnectTM?: SortOrder
    OnlineHours?: SortOrder
    HWID?: SortOrder
  }

  export type MEMB_STATAvgOrderByAggregateInput = {
    ConnectStat?: SortOrder
    OnlineHours?: SortOrder
  }

  export type MEMB_STATMaxOrderByAggregateInput = {
    memb___id?: SortOrder
    ConnectStat?: SortOrder
    ServerName?: SortOrder
    IP?: SortOrder
    ConnectTM?: SortOrder
    DisConnectTM?: SortOrder
    OnlineHours?: SortOrder
    HWID?: SortOrder
  }

  export type MEMB_STATMinOrderByAggregateInput = {
    memb___id?: SortOrder
    ConnectStat?: SortOrder
    ServerName?: SortOrder
    IP?: SortOrder
    ConnectTM?: SortOrder
    DisConnectTM?: SortOrder
    OnlineHours?: SortOrder
    HWID?: SortOrder
  }

  export type MEMB_STATSumOrderByAggregateInput = {
    ConnectStat?: SortOrder
    OnlineHours?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type MasterSkillTreeCountOrderByAggregateInput = {
    Name?: SortOrder
    MasterLevel?: SortOrder
    MasterPoint?: SortOrder
    MasterExperience?: SortOrder
    MasterSkill?: SortOrder
  }

  export type MasterSkillTreeAvgOrderByAggregateInput = {
    MasterLevel?: SortOrder
    MasterPoint?: SortOrder
    MasterExperience?: SortOrder
  }

  export type MasterSkillTreeMaxOrderByAggregateInput = {
    Name?: SortOrder
    MasterLevel?: SortOrder
    MasterPoint?: SortOrder
    MasterExperience?: SortOrder
    MasterSkill?: SortOrder
  }

  export type MasterSkillTreeMinOrderByAggregateInput = {
    Name?: SortOrder
    MasterLevel?: SortOrder
    MasterPoint?: SortOrder
    MasterExperience?: SortOrder
    MasterSkill?: SortOrder
  }

  export type MasterSkillTreeSumOrderByAggregateInput = {
    MasterLevel?: SortOrder
    MasterPoint?: SortOrder
    MasterExperience?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MuCastle_DATACountOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    SIEGE_START_DATE?: SortOrder
    SIEGE_END_DATE?: SortOrder
    SIEGE_GUILDLIST_SETTED?: SortOrder
    SIEGE_ENDED?: SortOrder
    CASTLE_OCCUPY?: SortOrder
    OWNER_GUILD?: SortOrder
    MONEY?: SortOrder
    TAX_RATE_CHAOS?: SortOrder
    TAX_RATE_STORE?: SortOrder
    TAX_HUNT_ZONE?: SortOrder
  }

  export type MuCastle_DATAAvgOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    MONEY?: SortOrder
    TAX_RATE_CHAOS?: SortOrder
    TAX_RATE_STORE?: SortOrder
    TAX_HUNT_ZONE?: SortOrder
  }

  export type MuCastle_DATAMaxOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    SIEGE_START_DATE?: SortOrder
    SIEGE_END_DATE?: SortOrder
    SIEGE_GUILDLIST_SETTED?: SortOrder
    SIEGE_ENDED?: SortOrder
    CASTLE_OCCUPY?: SortOrder
    OWNER_GUILD?: SortOrder
    MONEY?: SortOrder
    TAX_RATE_CHAOS?: SortOrder
    TAX_RATE_STORE?: SortOrder
    TAX_HUNT_ZONE?: SortOrder
  }

  export type MuCastle_DATAMinOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    SIEGE_START_DATE?: SortOrder
    SIEGE_END_DATE?: SortOrder
    SIEGE_GUILDLIST_SETTED?: SortOrder
    SIEGE_ENDED?: SortOrder
    CASTLE_OCCUPY?: SortOrder
    OWNER_GUILD?: SortOrder
    MONEY?: SortOrder
    TAX_RATE_CHAOS?: SortOrder
    TAX_RATE_STORE?: SortOrder
    TAX_HUNT_ZONE?: SortOrder
  }

  export type MuCastle_DATASumOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    MONEY?: SortOrder
    TAX_RATE_CHAOS?: SortOrder
    TAX_RATE_STORE?: SortOrder
    TAX_HUNT_ZONE?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type MuCastle_NPCMAP_SVR_GROUPNPC_NUMBERNPC_INDEXCompoundUniqueInput = {
    MAP_SVR_GROUP: number
    NPC_NUMBER: number
    NPC_INDEX: number
  }

  export type MuCastle_NPCCountOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    NPC_NUMBER?: SortOrder
    NPC_INDEX?: SortOrder
    NPC_DF_LEVEL?: SortOrder
    NPC_RG_LEVEL?: SortOrder
    NPC_MAXHP?: SortOrder
    NPC_HP?: SortOrder
    NPC_X?: SortOrder
    NPC_Y?: SortOrder
    NPC_DIR?: SortOrder
    NPC_CREATEDATE?: SortOrder
  }

  export type MuCastle_NPCAvgOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    NPC_NUMBER?: SortOrder
    NPC_INDEX?: SortOrder
    NPC_DF_LEVEL?: SortOrder
    NPC_RG_LEVEL?: SortOrder
    NPC_MAXHP?: SortOrder
    NPC_HP?: SortOrder
    NPC_X?: SortOrder
    NPC_Y?: SortOrder
    NPC_DIR?: SortOrder
  }

  export type MuCastle_NPCMaxOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    NPC_NUMBER?: SortOrder
    NPC_INDEX?: SortOrder
    NPC_DF_LEVEL?: SortOrder
    NPC_RG_LEVEL?: SortOrder
    NPC_MAXHP?: SortOrder
    NPC_HP?: SortOrder
    NPC_X?: SortOrder
    NPC_Y?: SortOrder
    NPC_DIR?: SortOrder
    NPC_CREATEDATE?: SortOrder
  }

  export type MuCastle_NPCMinOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    NPC_NUMBER?: SortOrder
    NPC_INDEX?: SortOrder
    NPC_DF_LEVEL?: SortOrder
    NPC_RG_LEVEL?: SortOrder
    NPC_MAXHP?: SortOrder
    NPC_HP?: SortOrder
    NPC_X?: SortOrder
    NPC_Y?: SortOrder
    NPC_DIR?: SortOrder
    NPC_CREATEDATE?: SortOrder
  }

  export type MuCastle_NPCSumOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    NPC_NUMBER?: SortOrder
    NPC_INDEX?: SortOrder
    NPC_DF_LEVEL?: SortOrder
    NPC_RG_LEVEL?: SortOrder
    NPC_MAXHP?: SortOrder
    NPC_HP?: SortOrder
    NPC_X?: SortOrder
    NPC_Y?: SortOrder
    NPC_DIR?: SortOrder
  }

  export type MuCastle_REG_SIEGEMAP_SVR_GROUPREG_SIEGE_GUILDCompoundUniqueInput = {
    MAP_SVR_GROUP: number
    REG_SIEGE_GUILD: string
  }

  export type MuCastle_REG_SIEGECountOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    REG_SIEGE_GUILD?: SortOrder
    REG_MARKS?: SortOrder
    IS_GIVEUP?: SortOrder
    SEQ_NUM?: SortOrder
  }

  export type MuCastle_REG_SIEGEAvgOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    REG_MARKS?: SortOrder
    IS_GIVEUP?: SortOrder
    SEQ_NUM?: SortOrder
  }

  export type MuCastle_REG_SIEGEMaxOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    REG_SIEGE_GUILD?: SortOrder
    REG_MARKS?: SortOrder
    IS_GIVEUP?: SortOrder
    SEQ_NUM?: SortOrder
  }

  export type MuCastle_REG_SIEGEMinOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    REG_SIEGE_GUILD?: SortOrder
    REG_MARKS?: SortOrder
    IS_GIVEUP?: SortOrder
    SEQ_NUM?: SortOrder
  }

  export type MuCastle_REG_SIEGESumOrderByAggregateInput = {
    MAP_SVR_GROUP?: SortOrder
    REG_MARKS?: SortOrder
    IS_GIVEUP?: SortOrder
    SEQ_NUM?: SortOrder
  }

  export type OptionDataCountOrderByAggregateInput = {
    Name?: SortOrder
    SkillKey?: SortOrder
    GameOption?: SortOrder
    Qkey?: SortOrder
    Wkey?: SortOrder
    Ekey?: SortOrder
    ChatWindow?: SortOrder
    Rkey?: SortOrder
    QWERLevel?: SortOrder
  }

  export type OptionDataAvgOrderByAggregateInput = {
    GameOption?: SortOrder
    Qkey?: SortOrder
    Wkey?: SortOrder
    Ekey?: SortOrder
    ChatWindow?: SortOrder
    Rkey?: SortOrder
    QWERLevel?: SortOrder
  }

  export type OptionDataMaxOrderByAggregateInput = {
    Name?: SortOrder
    SkillKey?: SortOrder
    GameOption?: SortOrder
    Qkey?: SortOrder
    Wkey?: SortOrder
    Ekey?: SortOrder
    ChatWindow?: SortOrder
    Rkey?: SortOrder
    QWERLevel?: SortOrder
  }

  export type OptionDataMinOrderByAggregateInput = {
    Name?: SortOrder
    SkillKey?: SortOrder
    GameOption?: SortOrder
    Qkey?: SortOrder
    Wkey?: SortOrder
    Ekey?: SortOrder
    ChatWindow?: SortOrder
    Rkey?: SortOrder
    QWERLevel?: SortOrder
  }

  export type OptionDataSumOrderByAggregateInput = {
    GameOption?: SortOrder
    Qkey?: SortOrder
    Wkey?: SortOrder
    Ekey?: SortOrder
    ChatWindow?: SortOrder
    Rkey?: SortOrder
    QWERLevel?: SortOrder
  }

  export type QuestKillCountCountOrderByAggregateInput = {
    Name?: SortOrder
    QuestIndex?: SortOrder
    MonsterClass1?: SortOrder
    KillCount1?: SortOrder
    MonsterClass2?: SortOrder
    KillCount2?: SortOrder
    MonsterClass3?: SortOrder
    KillCount3?: SortOrder
    MonsterClass4?: SortOrder
    KillCount4?: SortOrder
    MonsterClass5?: SortOrder
    KillCount5?: SortOrder
  }

  export type QuestKillCountAvgOrderByAggregateInput = {
    QuestIndex?: SortOrder
    MonsterClass1?: SortOrder
    KillCount1?: SortOrder
    MonsterClass2?: SortOrder
    KillCount2?: SortOrder
    MonsterClass3?: SortOrder
    KillCount3?: SortOrder
    MonsterClass4?: SortOrder
    KillCount4?: SortOrder
    MonsterClass5?: SortOrder
    KillCount5?: SortOrder
  }

  export type QuestKillCountMaxOrderByAggregateInput = {
    Name?: SortOrder
    QuestIndex?: SortOrder
    MonsterClass1?: SortOrder
    KillCount1?: SortOrder
    MonsterClass2?: SortOrder
    KillCount2?: SortOrder
    MonsterClass3?: SortOrder
    KillCount3?: SortOrder
    MonsterClass4?: SortOrder
    KillCount4?: SortOrder
    MonsterClass5?: SortOrder
    KillCount5?: SortOrder
  }

  export type QuestKillCountMinOrderByAggregateInput = {
    Name?: SortOrder
    QuestIndex?: SortOrder
    MonsterClass1?: SortOrder
    KillCount1?: SortOrder
    MonsterClass2?: SortOrder
    KillCount2?: SortOrder
    MonsterClass3?: SortOrder
    KillCount3?: SortOrder
    MonsterClass4?: SortOrder
    KillCount4?: SortOrder
    MonsterClass5?: SortOrder
    KillCount5?: SortOrder
  }

  export type QuestKillCountSumOrderByAggregateInput = {
    QuestIndex?: SortOrder
    MonsterClass1?: SortOrder
    KillCount1?: SortOrder
    MonsterClass2?: SortOrder
    KillCount2?: SortOrder
    MonsterClass3?: SortOrder
    KillCount3?: SortOrder
    MonsterClass4?: SortOrder
    KillCount4?: SortOrder
    MonsterClass5?: SortOrder
    KillCount5?: SortOrder
  }

  export type QuestWorldCountOrderByAggregateInput = {
    Name?: SortOrder
    QuestWorldList?: SortOrder
  }

  export type QuestWorldMaxOrderByAggregateInput = {
    Name?: SortOrder
    QuestWorldList?: SortOrder
  }

  export type QuestWorldMinOrderByAggregateInput = {
    Name?: SortOrder
    QuestWorldList?: SortOrder
  }

  export type RankingBloodCastleCountOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingBloodCastleAvgOrderByAggregateInput = {
    Score?: SortOrder
  }

  export type RankingBloodCastleMaxOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingBloodCastleMinOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingBloodCastleSumOrderByAggregateInput = {
    Score?: SortOrder
  }

  export type RankingChaosCastleCountOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingChaosCastleAvgOrderByAggregateInput = {
    Score?: SortOrder
  }

  export type RankingChaosCastleMaxOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingChaosCastleMinOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingChaosCastleSumOrderByAggregateInput = {
    Score?: SortOrder
  }

  export type RankingDevilSquareCountOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingDevilSquareAvgOrderByAggregateInput = {
    Score?: SortOrder
  }

  export type RankingDevilSquareMaxOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingDevilSquareMinOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingDevilSquareSumOrderByAggregateInput = {
    Score?: SortOrder
  }

  export type RankingDuelCountOrderByAggregateInput = {
    Name?: SortOrder
    WinScore?: SortOrder
    LoseScore?: SortOrder
  }

  export type RankingDuelAvgOrderByAggregateInput = {
    WinScore?: SortOrder
    LoseScore?: SortOrder
  }

  export type RankingDuelMaxOrderByAggregateInput = {
    Name?: SortOrder
    WinScore?: SortOrder
    LoseScore?: SortOrder
  }

  export type RankingDuelMinOrderByAggregateInput = {
    Name?: SortOrder
    WinScore?: SortOrder
    LoseScore?: SortOrder
  }

  export type RankingDuelSumOrderByAggregateInput = {
    WinScore?: SortOrder
    LoseScore?: SortOrder
  }

  export type RankingIllusionTempleCountOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingIllusionTempleAvgOrderByAggregateInput = {
    Score?: SortOrder
  }

  export type RankingIllusionTempleMaxOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingIllusionTempleMinOrderByAggregateInput = {
    Name?: SortOrder
    Score?: SortOrder
  }

  export type RankingIllusionTempleSumOrderByAggregateInput = {
    Score?: SortOrder
  }

  export type T_CGuidCountOrderByAggregateInput = {
    GUID?: SortOrder
    Name?: SortOrder
  }

  export type T_CGuidAvgOrderByAggregateInput = {
    GUID?: SortOrder
  }

  export type T_CGuidMaxOrderByAggregateInput = {
    GUID?: SortOrder
    Name?: SortOrder
  }

  export type T_CGuidMinOrderByAggregateInput = {
    GUID?: SortOrder
    Name?: SortOrder
  }

  export type T_CGuidSumOrderByAggregateInput = {
    GUID?: SortOrder
  }

  export type T_FriendMailGUIDMemoIndexCompoundUniqueInput = {
    GUID: number
    MemoIndex: number
  }

  export type T_FriendMailCountOrderByAggregateInput = {
    MemoIndex?: SortOrder
    GUID?: SortOrder
    FriendName?: SortOrder
    wDate?: SortOrder
    Subject?: SortOrder
    bRead?: SortOrder
    Memo?: SortOrder
    Photo?: SortOrder
    Dir?: SortOrder
    Act?: SortOrder
  }

  export type T_FriendMailAvgOrderByAggregateInput = {
    MemoIndex?: SortOrder
    GUID?: SortOrder
    Dir?: SortOrder
    Act?: SortOrder
  }

  export type T_FriendMailMaxOrderByAggregateInput = {
    MemoIndex?: SortOrder
    GUID?: SortOrder
    FriendName?: SortOrder
    wDate?: SortOrder
    Subject?: SortOrder
    bRead?: SortOrder
    Memo?: SortOrder
    Photo?: SortOrder
    Dir?: SortOrder
    Act?: SortOrder
  }

  export type T_FriendMailMinOrderByAggregateInput = {
    MemoIndex?: SortOrder
    GUID?: SortOrder
    FriendName?: SortOrder
    wDate?: SortOrder
    Subject?: SortOrder
    bRead?: SortOrder
    Memo?: SortOrder
    Photo?: SortOrder
    Dir?: SortOrder
    Act?: SortOrder
  }

  export type T_FriendMailSumOrderByAggregateInput = {
    MemoIndex?: SortOrder
    GUID?: SortOrder
    Dir?: SortOrder
    Act?: SortOrder
  }

  export type T_FriendMainCountOrderByAggregateInput = {
    GUID?: SortOrder
    Name?: SortOrder
    FriendCount?: SortOrder
    MemoCount?: SortOrder
    MemoTotal?: SortOrder
  }

  export type T_FriendMainAvgOrderByAggregateInput = {
    GUID?: SortOrder
    FriendCount?: SortOrder
    MemoCount?: SortOrder
    MemoTotal?: SortOrder
  }

  export type T_FriendMainMaxOrderByAggregateInput = {
    GUID?: SortOrder
    Name?: SortOrder
    FriendCount?: SortOrder
    MemoCount?: SortOrder
    MemoTotal?: SortOrder
  }

  export type T_FriendMainMinOrderByAggregateInput = {
    GUID?: SortOrder
    Name?: SortOrder
    FriendCount?: SortOrder
    MemoCount?: SortOrder
    MemoTotal?: SortOrder
  }

  export type T_FriendMainSumOrderByAggregateInput = {
    GUID?: SortOrder
    FriendCount?: SortOrder
    MemoCount?: SortOrder
    MemoTotal?: SortOrder
  }

  export type T_PetItem_InfoCountOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Pet_Level?: SortOrder
    Pet_Exp?: SortOrder
  }

  export type T_PetItem_InfoAvgOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Pet_Level?: SortOrder
    Pet_Exp?: SortOrder
  }

  export type T_PetItem_InfoMaxOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Pet_Level?: SortOrder
    Pet_Exp?: SortOrder
  }

  export type T_PetItem_InfoMinOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Pet_Level?: SortOrder
    Pet_Exp?: SortOrder
  }

  export type T_PetItem_InfoSumOrderByAggregateInput = {
    ItemSerial?: SortOrder
    Pet_Level?: SortOrder
    Pet_Exp?: SortOrder
  }

  export type warehouseCountOrderByAggregateInput = {
    AccountID?: SortOrder
    Items?: SortOrder
    Money?: SortOrder
    EndUseDate?: SortOrder
    DbVersion?: SortOrder
    pw?: SortOrder
    VaultCounts?: SortOrder
    LastVaultID?: SortOrder
  }

  export type warehouseAvgOrderByAggregateInput = {
    Money?: SortOrder
    DbVersion?: SortOrder
    pw?: SortOrder
    VaultCounts?: SortOrder
    LastVaultID?: SortOrder
  }

  export type warehouseMaxOrderByAggregateInput = {
    AccountID?: SortOrder
    Items?: SortOrder
    Money?: SortOrder
    EndUseDate?: SortOrder
    DbVersion?: SortOrder
    pw?: SortOrder
    VaultCounts?: SortOrder
    LastVaultID?: SortOrder
  }

  export type warehouseMinOrderByAggregateInput = {
    AccountID?: SortOrder
    Items?: SortOrder
    Money?: SortOrder
    EndUseDate?: SortOrder
    DbVersion?: SortOrder
    pw?: SortOrder
    VaultCounts?: SortOrder
    LastVaultID?: SortOrder
  }

  export type warehouseSumOrderByAggregateInput = {
    Money?: SortOrder
    DbVersion?: SortOrder
    pw?: SortOrder
    VaultCounts?: SortOrder
    LastVaultID?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEMB_INFODefaultArgs instead
     */
    export type MEMB_INFOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEMB_INFODefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCharacterDefaultArgs instead
     */
    export type AccountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashShopDataDefaultArgs instead
     */
    export type CashShopDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashShopDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashShopInventoryDefaultArgs instead
     */
    export type CashShopInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashShopInventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashShopPeriodicItemDefaultArgs instead
     */
    export type CashShopPeriodicItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashShopPeriodicItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterDefaultArgs instead
     */
    export type CharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DefaultClassTypeDefaultArgs instead
     */
    export type DefaultClassTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DefaultClassTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventLeoTheHelperDefaultArgs instead
     */
    export type EventLeoTheHelperArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventLeoTheHelperDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventSantaClausDefaultArgs instead
     */
    export type EventSantaClausArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventSantaClausDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameServerInfoDefaultArgs instead
     */
    export type GameServerInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameServerInfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Gens_RankDefaultArgs instead
     */
    export type Gens_RankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Gens_RankDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Gens_RewardDefaultArgs instead
     */
    export type Gens_RewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Gens_RewardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildDefaultArgs instead
     */
    export type GuildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GuildMemberDefaultArgs instead
     */
    export type GuildMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GuildMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelperDataDefaultArgs instead
     */
    export type HelperDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelperDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LuckyCoinDefaultArgs instead
     */
    export type LuckyCoinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LuckyCoinDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LuckyItemDefaultArgs instead
     */
    export type LuckyItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LuckyItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MEMB_STATDefaultArgs instead
     */
    export type MEMB_STATArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MEMB_STATDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MasterSkillTreeDefaultArgs instead
     */
    export type MasterSkillTreeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MasterSkillTreeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MuCastle_DATADefaultArgs instead
     */
    export type MuCastle_DATAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MuCastle_DATADefaultArgs<ExtArgs>
    /**
     * @deprecated Use MuCastle_NPCDefaultArgs instead
     */
    export type MuCastle_NPCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MuCastle_NPCDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MuCastle_REG_SIEGEDefaultArgs instead
     */
    export type MuCastle_REG_SIEGEArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MuCastle_REG_SIEGEDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OptionDataDefaultArgs instead
     */
    export type OptionDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OptionDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestKillCountDefaultArgs instead
     */
    export type QuestKillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestKillCountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestWorldDefaultArgs instead
     */
    export type QuestWorldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestWorldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RankingBloodCastleDefaultArgs instead
     */
    export type RankingBloodCastleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RankingBloodCastleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RankingChaosCastleDefaultArgs instead
     */
    export type RankingChaosCastleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RankingChaosCastleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RankingDevilSquareDefaultArgs instead
     */
    export type RankingDevilSquareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RankingDevilSquareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RankingDuelDefaultArgs instead
     */
    export type RankingDuelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RankingDuelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RankingIllusionTempleDefaultArgs instead
     */
    export type RankingIllusionTempleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RankingIllusionTempleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use T_CGuidDefaultArgs instead
     */
    export type T_CGuidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = T_CGuidDefaultArgs<ExtArgs>
    /**
     * @deprecated Use T_FriendMailDefaultArgs instead
     */
    export type T_FriendMailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = T_FriendMailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use T_FriendMainDefaultArgs instead
     */
    export type T_FriendMainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = T_FriendMainDefaultArgs<ExtArgs>
    /**
     * @deprecated Use T_PetItem_InfoDefaultArgs instead
     */
    export type T_PetItem_InfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = T_PetItem_InfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use warehouseDefaultArgs instead
     */
    export type warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = warehouseDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}